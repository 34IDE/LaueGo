#pragma rtGlobals=1		// Use modern global access method.#pragma IgorVersion = 4.0#pragma version = 1.0Menu "Analysis"		"-"		"undulator E->gap",print energy2gap(NaN,NaN,1)		"undulator gap->E",print gap2energy(NaN,1,NaN)EndFunction energy2gap(id,energy,harm)	//	Subroutine for energy to gap conversion.  - Undulator	Variable id						// undulator id 33 or 34	Variable energy					// x-ray energy (keV)	Variable harm					// harmonic to use	if (numtype(id) || numtype(energy) || numtype(harm))		id = (numtype(id) || id<33 || id>34) ? 34 : id		energy = numtype(energy) ? 9.5 : energy		harm = numtype(harm) ? 1 : harm		id -=32		Prompt id, "undulator id",popup,"33;34"		Prompt energy "x-ray energy (kev)"		Prompt harm, "harmonic"		DoPrompt "desired energy",energy,harm,id		id += 32	endif	Variable beamEnergy =7.0		// electron energy (GeV)	Variable gapValue, bField 	// trap energy values greater than 1000.0 or less than .005keV	if (energy >=1000 || energy <= 0.005)		return NaN	endif	if (id==33)		WAVE undGap = root:Packages:undulator:undGap33		WAVE logBeff = root:Packages:undulator:logBeff33	elseif (id==34)		WAVE undGap = root:Packages:undulator:undGap34		WAVE logBeff = root:Packages:undulator:logBeff34	endif	bField = energyToB(energy,beamEnergy,harm,id)	Variable pt = BinarySearchInterp(logBeff,ln(bField*10000.0))	gapValue = undGap[pt]	// Now make sure that the converted gap is within the operating limits.	Variable minGap = NumberByKey("Minimum_Gap", note(undGap))	Variable maxGap = undGap[numpnts(undGap)-1]	if ( (gapValue < minGap) || (gapValue > maxGap) )		return NaN	endif	return gapValueEndFunction gap2energy(gapValue,harm,id)	// convert gap to energy	Variable gapValue		// undulator gap	Variable harm	Variable id				// undulator id (33 or 34)	if (numtype(id) || numtype(gapValue) || numtype(harm))		id = (numtype(id) || id<33 || id>34) ? 34 : id		gapValue = (numtype(gapValue) || gapValue<0) ? 15 : gapValue		harm = numtype(harm) ? 1 : harm		id -=32		Prompt id, "undulator id",popup,"33;34"		Prompt gapValue "undulator gap"		Prompt harm, "harmonic"		DoPrompt "desired gap",gapValue,harm,id		id += 32	endif	Variable energy			// x-ray energy (keV)	Variable GeV =7.0	Variable bField = gapToB(gapValue,id)	if (numtype(bField))		return NaN	endif	energy = bToEnergy(bField/10000.0,harm,GeV,id)	return energyEndFunction bToEnergy(bField,harm,GeV,id)	// Field to Energy Conversion	Variable bField	Variable harm	Variable GeV				// electron energy (GeV)	Variable id					// undulator id (33 or 34)	if (id==33)		WAVE undGap = root:Packages:undulator:undGap33	elseif (id==34)		WAVE undGap = root:Packages:undulator:undGap34	endif	Variable periodLength = NumberByKey("Period_Length", note(undGap))	Variable energy				// x-ray energy (keV)	Variable C1=0.94963408		// convertion factor [keV*cm*GeV^-2]	Variable K_CNV=0.93372875	// convertion factor [(Tesla^-1) * (cm^-1)]	Variable K = K_CNV*bField*periodLength;	energy = C1*(harm+1)*GeV*GeV/(periodLength*(1+K*K/2.0))	return energyEndFunction gapToB(gapValue,id)	// Gap to Field Conversion	Variable gapValue	Variable id	Variable bField	Variable lower=0, upper=0, lowerBound=0, upperBound=0	Variable logBfield	Variable i, done	Variable MAX_GAP=210	if (id==33)		WAVE undGap = root:Packages:undulator:undGap33		WAVE Beff = root:Packages:undulator:Beff33		WAVE logBeff = root:Packages:undulator:logBeff33	elseif (id==34)		WAVE undGap = root:Packages:undulator:undGap34		WAVE Beff = root:Packages:undulator:Beff34		WAVE logBeff = root:Packages:undulator:logBeff34	endif	String snote = note(undGap)	Variable minimumGap=NumberByKey("Minimum_Gap", snote)	Variable m=NumberByKey("m", snote)	Variable c=NumberByKey("c", snote)	Variable numData=numpnts(undGap)	if (gapValue < minimumGap)		return NaN	endif	done = 0  	for(i=1; (!done) && (i<numData); i+=1)		if (gapValue <= undGap[i])			done = 1			lowerBound = logBeff[i-1];			upperBound = logBeff[i]			lower = undGap[i-1]			upper = undGap[i]		endif	endfor	if ( (!done) && (gapValue >= minimumGap) && (gapValue <= MAX_GAP) )		done = 2;		logBfield = m * gapValue + c;		bField = exp(logBfield);	endif	if (!done)		return NaN	endif	if (done == 1)		logBfield = interpolateLin(lower,upper,lowerBound,upperBound,gapValue)		bField = exp(logBfield)	endif	return bFieldEndFunction energyToB(energy,GeV,harm,id)	// Energy to Field Conversion	Variable energy			// x-ray energy (keV)	Variable GeV 			// electron energy (GeV), probably 7	Variable harm			// harmonic	Variable id				// 33 or 34	if (id==33)		WAVE undGap = root:Packages:undulator:undGap33	elseif (id==34)		WAVE undGap = root:Packages:undulator:undGap34	endif	Variable K, bField	Variable periodLength = NumberByKey("Period_Length", note(undGap))	Variable  C1=0.94963408    	 // convertion factor [keV*cm*GeV^-2]	Variable K_CNV=0.93372875	// convertion factor [(Tesla^-1) * (cm^-1)]	K = sqrt( 2*(C1*GeV*GeV/(energy*periodLength/(harm+1)) -1) )	bField = K/(K_CNV*periodLength)    return bFieldEndFunction interpolateLin(xi, xf, yi, yf, x)		// linear interpolation 	Variable xi, xf, yi, yf, x	return( (xf != xi) ? yi+(x-xi)*(yf-yi)/(xf-xi) : (yf + yi)/2.0 )EndFunction undulatorInitPackage()	NewDataFolder /O root:Packages	NewDataFolder /O root:Packages:undulator	Make/O root:Packages:undulator:undGap33={10.5,11.5,13.5,15.5,18.5,24.5,30}	Make/O root:Packages:undulator:Beff33={8912,8039,6560,5374,3993,2233,1318}	Make/O root:Packages:undulator:undGap34={10.5,11.5,13.5,15.5,18.5,24.5,30}	Make/O root:Packages:undulator:Beff34={9062,8166,6648,5427,4030,2250,1330}	WAVE undGap33=root:Packages:undulator:undGap33	WAVE Beff33=root:Packages:undulator:Beff33	WAVE undGap34=root:Packages:undulator:undGap34	WAVE Beff34=root:Packages:undulator:Beff34	Note /K undGap33	Note /K Beff33	Note /K undGap34	Note /K Beff34	String snote="id:18_3.3cm;Period_Length:3.3 cm;Minimum_Gap:10.5 mm;Hard_Stops:10.4 mm;"	Note undGap33 snote	Note Beff33 snote	snote = "id:27_3.3cm;Period_Length:3.3 cm;Minimum_Gap:10.5 mm;Hard_Stops:10.4 mm;"	Note undGap34, snote	Note Beff34, snote	Duplicate/O root:Packages:undulator:Beff33 root:Packages:undulator:logBeff33	Duplicate/O root:Packages:undulator:Beff34 root:Packages:undulator:logBeff34	WAVE logBeff33=root:Packages:undulator:logBeff33	WAVE logBeff34=root:Packages:undulator:logBeff34	logBeff33 = (Beff33>0) ? ln(Beff33) : 0	logBeff34 = (Beff34>0) ? ln(Beff34) : 0	moreInit(undGap33,Beff33,logBeff33)	moreInit(undGap34,Beff34,logBeff34)EndFunction moreInit(undGap,Beff,logBeff)	Wave undGap,Beff,logBeff	Variable numData=numpnts(undGap)	if (numData < 1)		return -1	endif	Variable i	Variable sum_x=0, sum_xx=0, sum_xy=0, sum_y=0	Variable gap, logB	for (i=0;i<numData;i+=1)		gap = undGap[i]		logB = logBeff[i]		sum_x += gap		sum_xx += gap^2		sum_xy += gap*logB		sum_y += logB	endfor	Variable det, det_m, det_c	Variable m, c,minimumField, maximumField	Variable MAX_GAP=210	det = sum_xx*numData - sum_x*sum_x	det_m = sum_xy*numData - sum_x*sum_y	det_c = sum_xx*sum_y - sum_xy*sum_x	m = (det != 0) ? det_m/det : 1	// the last data point is used to calculate offset instead of the least 	// square fit, this avoids discontinuity from the function of field vs. gap 	String snote = note(undGap)	Variable minimumGap=NumberByKey("Minimum_Gap", snote)	c = logBeff[numData-1] - m * gap	minimumField = exp(m * MAX_GAP + c)	maximumField = exp(m * (minimumGap - undGap[0]) + logBeff[0] )	String str	sprintf str, "c:%g;m:%g;minimumField:%g;maximumField:%g;",c,m,minimumField,maximumField	snote += str	Note/K undGap	Note/K Beff	Note/K logBeff	Note undGap snote	Note Beff snote	Note logBeff snoteEnd