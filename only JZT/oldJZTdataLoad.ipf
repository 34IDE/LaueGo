#pragma rtGlobals=1		// Use modern global access method.#pragma version = 0.01Macro Load_oldJZTstd(fileName,path)		// read in data from a spec data file		// set global variable V_flag > 0 if there is an error (0=no error)		// values for V_flag are:		//				//		0=(no error)		//		1=(the data folder already exists)		//		// For users who wish to include additional information from the data		// file in igor, create a macro named "extraSpecRead".  An example is		// in "specMore.ipf"	String fileName=StrVarOrDefault("root:oldJZTDefaultFile","")	String path=StrVarOrDefault("root:oldJZTDefaultPath","home")	Prompt path, "path for data", popup, PathList("*", ";", "")	Silent 1	Variable fileVar			// file ref number	String line				// line of input from file	Variable i	Variable/G :V_flag = 0	if (exists(":oldJZTdataFileIndex")==2)		Variable index = :oldJZTdataFileIndex + 1	else		Variable index = 0	endif	String fldrSav= GetDataFolder(1)	String folderName = "data"+num2istr(index)	if (DataFolderExists(folderName))		Print "the data folder already exists"		:V_flag = 1		return	endif	Variable isMac=!cmpstr(IgorInfo(2),"Macintosh")	if (isMac)		Open /R/T="TEXT"/P=$path/M="data file"/Z fileVar as fileName	else		Open /R/P=$path/M="data file"/Z fileVar as fileName	endif	if (:V_flag)		if (isMac)			Open /R/T="TEXT"/M="spec data file" fileVar as fileName		else			Open /R/M="spec data file" fileVar as fileName		endif	endif	FStatus(fileVar)	if (exists("root:oldJZTDefaultFile")!=2)		String /G root:oldJZTDefaultFile	endif	root:oldJZTDefaultFile = S_fileName	if (exists("root:oldJZTDefaultPath")!=2)		String /G root:oldJZTDefaultPath	endif	root:oldJZTDefaultPath = path	// file starts here	FStatus fileVar	Variable FilePos = V_filePos	String line1,VarList="",arrayList=""	do		FReadLine fileVar, line		FStatus fileVar					// check for EOF		if ((V_logEOF<(V_filePos+2)) %| (char2num(line[0,0])==64))	// 64==ascii("@")			break		endif		if (char2num(line[0,0])==36)							// 33==ascii("$")			if (strsearch(line,"$array_",0)==0)					// do not load arrays here				if (FindListItem(line[7], arrayList)<0)					arrayList += line[7]+";"						// names of arrys to process later				endif			else				FReadLine fileVar, line1				VarList += MakeInfoIntoListItem(line,line1)			endif		endif	while (1)	String/G S_folder = folderName	NewDataFolder /S $folderName	String/G :VarList = VarList	FSetPos fileVar, 0								// reset file position to start	// now read in arrays listed in arrayList	i = 0	do		LoadOLDJZTarray(fileVar,StringFromList(i,arrayList))		i += 1	while (i<ItemsInList(arrayList))	SetDataFolder fldrSav	Close fileVar	Variable/G :oldJZTdataFileIndex=index	:V_flag = 0									// set V_flag to no errorEndFunction LoadOLDJZTarray(fileVar,letter)	Variable fileVar			// file ref number	String letter	FStatus fileVar	Variable FilePos = V_filePos	String line	Variable i,ncol,nrow	line = FindLineStartingWith(fileVar,"$array_"+letter+"_size")	if (strlen(line)<1)		return 1	endif	FReadLine fileVar, line	i = str2num(line)	if ((i<1) %| (i>2))		FSetPos fileVar, FilePos				// reset file position to starting point		LoadOLDJZTarray2d(fileVar,letter)		return 1	endif	if (i==2)		FReadLine fileVar, line		ncol = str2num(line)	else		ncol = 1	endif	FReadLine fileVar, line	nrow = str2num(line)	// array_letter is nrow x ncol	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_label_1")	String nameList=""	if (strlen(line)>1)		i = 0		do			FReadLine fileVar, line			line = TrimLeadingWhiteSpace(line)			line = TrimTraiingWhiteSpace(line)			nameList += ValidIgorWaveName(line)+","			i += 1		while(i<ncol)	else		i = 0		do			line = "array_"+letter			if (i>0)				line += "_"+num2istr(i)			endif			nameList += ValidIgorWaveName(line)+","			i += 1		while (i<ncol)	endif	// array_letter column labels now stored in the list nameList	String ScaleCommand=""	String unit="", xlabel=""	// set x-scaling for the wave	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_range_1")	if (strlen(line)>1)		Variable x1,x2		FReadLine fileVar, line		x1 = str2num(line)		FReadLine fileVar, line		x2 = str2num(line)		FReadLine fileVar, xlabel		xlabel = TrimLeadingWhiteSpace(xlabel)		xlabel = TrimTraiingWhiteSpace(xlabel)		FReadLine fileVar, unit		unit = TrimLeadingWhiteSpace(unit)		unit = TrimTraiingWhiteSpace(unit)		sprintf line, "SetScale/I x %g,%g,\"%s\", %s ; " x1,x2,unit,nameList		ScaleCommand += line	endif	// set y-value scaling for the wave	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_label_2")	if (strlen(line)>1)		FReadLine fileVar, unit		unit = TrimLeadingWhiteSpace(unit)		unit = TrimTraiingWhiteSpace(unit)		sprintf line, "SetScale d 0,0,\"%s\", %s ; "  unit,nameList		ScaleCommand += line	endif	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_data")	if (strlen(line)<1)		return 1	endif	FStatus fileVar							// V_filePos now contains current file position	FReadLine fileVar, unit	Variable DataPos = V_filePos			// position of start of data	// read in lines to count how many to start of data	FSetPos fileVar, 0						// reset file position to starting point	Variable firstLine=0	do		FReadLine fileVar, line		FStatus fileVar		firstLine += 1	while (V_filePos<DataPos)//	LoadWave /Q/A=array_B/J/K=0/V={"\t, ", " ", 0, 0 }/L={0, firstLine, nrow, 0, 0 } S_path+S_fileName	LoadWave /Q/A=array_B/G/L={0, firstLine, nrow, 0, 0 } S_path+S_fileName	String command	i = 0	do		command = "Rename "+StringFromList(i,S_waveNames,";")+" "+StringFromList(i,nameList,",")		Execute command		i += 1	while(i<ncol)	Execute ScaleCommand	if (strlen(xlabel)>0)					// put plot labels into wave note		String noteStr=note($StringFromList(0,nameList,","))		Note/K $StringFromList(0,nameList,",")		Note $StringFromList(0,nameList,","),"xlabel:"+xlabel+";"+noteStr	endifEndFunction LoadOLDJZTarrayREAL_OLD(fileVar,letter)	Variable fileVar			// file ref number	String letter	FStatus fileVar	Variable FilePos = V_filePos	String line	Variable i,ncol,nrow	line = FindLineStartingWith(fileVar,"$array_"+letter+"_size")	if (strlen(line)<1)		return 1	endif	FReadLine fileVar, line	i = str2num(line)	if ((i<1) %| (i>2))		return 1	endif	if (i==2)		FReadLine fileVar, line		ncol = str2num(line)	else		ncol = 1	endif	FReadLine fileVar, line	nrow = str2num(line)	// array_letter is nrow x ncol	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_label_1")	String nameList=""	if (strlen(line)>1)		i = 0		do			FReadLine fileVar, line			line = TrimLeadingWhiteSpace(line)			line = TrimTraiingWhiteSpace(line)			nameList += ValidIgorWaveName(line)+","			i += 1		while(i<ncol)	else		i = 0		do			line = "wave"+num2istr(i)			nameList += ValidIgorWaveName(line)+","			i += 1		while (i<ncol)	endif	// array_letter column labels now stored in the list nameList	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_data")	if (strlen(line)<1)		return 1	endif	String command = "Make/N="+num2istr(nrow)+"/O"	i = 0	do		command += " "+StringFromList(i,nameList,",")		i += 1	while(i<ncol)	Execute command	i = 0	do		FReadLine fileVar, line		AssignOneLine(line,i,ncol,nameList)		i += 1	while(i<nrow)EndFunction LoadOLDJZTarray2d(fileVar,letter)	Variable fileVar			// file ref number	String letter	FStatus fileVar	Variable FilePos = V_filePos	String line	Variable i,nx,ny	line = FindLineStartingWith(fileVar,"$array_"+letter+"_size")	if (strlen(line)<1)		return 1	endif	FReadLine fileVar, line	i = str2num(line)	if (i != 3)								// this routine specialized for surfaces		return 1	endif	// array_letter is nx x ny	FReadLine fileVar, line	nx = abs(str2num(line))	FReadLine fileVar, line	ny = abs(str2num(line))	FReadLine fileVar, line	i = str2num(line)	if (i!=1)								// can only handle one array at a time		return 2	endif	String wname	wname = ValidIgorWaveName("array_"+letter)	String unit="", ScaleCommand="", xlabel="", ylabel=""	Variable x1,x2	// set x-scaling for the wave	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_range_1")	if (strlen(line)>1)		FReadLine fileVar, line		x1 = str2num(line)		FReadLine fileVar, line		x2 = str2num(line)		FReadLine fileVar, xlabel		xlabel = TrimLeadingWhiteSpace(xlabel)		xlabel = TrimTraiingWhiteSpace(xlabel)		FReadLine fileVar, unit		unit = TrimLeadingWhiteSpace(unit)		unit = TrimTraiingWhiteSpace(unit)		sprintf line, "SetScale/I x %g,%g,\"%s\", %s ; " x1,x2,unit,wname		ScaleCommand += line	endif	// set y-value scaling for the wave	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_range_2")	if (strlen(line)>1)		FReadLine fileVar, line		x1 = str2num(line)		FReadLine fileVar, line		x2 = str2num(line)		FReadLine fileVar, ylabel		ylabel = TrimLeadingWhiteSpace(ylabel)		ylabel = TrimTraiingWhiteSpace(ylabel)		FReadLine fileVar, unit		unit = TrimLeadingWhiteSpace(unit)		unit = TrimTraiingWhiteSpace(unit)		sprintf line, "SetScale/I y %g,%g,\"%s\", %s ; " x1,x2,unit,wname		ScaleCommand += line	endif	// set z-value units for the wave	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_label_3")	if (strlen(line)>1)		FReadLine fileVar, unit		unit = TrimLeadingWhiteSpace(unit)		unit = TrimTraiingWhiteSpace(unit)		sprintf line, "SetScale d 0,0,\"%s\", %s ; "  unit,wname		ScaleCommand += line	endif	FSetPos fileVar, FilePos					// reset file position to starting point	line = FindLineStartingWith(fileVar,"$array_"+letter+"_data")	if (strlen(line)<1)		return 1	endif	FStatus fileVar							// V_filePos now contains current file position	FReadLine fileVar, unit	Variable DataPos = V_filePos			// position of start of data	// read in lines to count how many to start of data	FSetPos fileVar, 0						// reset file position to starting point	Variable firstLine=0	do		FReadLine fileVar, line		FStatus fileVar		firstLine += 1	while (V_filePos<DataPos)//	now read in the values	LoadWave /Q/A/J/M/V={"\t, ", " ", 0, 0 }/L={0, firstLine, nx, 0, 0 } S_path+S_fileName	line = StringFromList(0, S_waveNames)	Rename $line $wname					// set the wave name	WAVE wav=$wname	wav = wav[p][q+1]						// shift all 1 to the left	Redimension /N=(nx,ny) wav	Execute ScaleCommand	String noteStr	if (strlen(xlabel)>0)					// put plot labels into wave note		noteStr=note(wav)		note/K wav		Note wav,"xlabel:"+xlabel+";"+noteStr	endif	if (strlen(ylabel)>0)		noteStr=note(wav)		note/K wav		Note wav,"ylabel:"+ylabel+";"+noteStr	endifEndFunction/T FindLineStartingWith(fileVar,start)	Variable fileVar			// file ref number	String start	String line	Variable foundStart=0	do		FReadLine fileVar, line		foundStart = strsearch(line,start, 0)==0		if (strlen(line)<1)						// checks for end of file			return ""		endif	while ((!foundStart))	return lineEndStatic Function/T TrimLeadingWhiteSpace(str)	String str	Variable i	i = -1	do											// skip leading white space		i += 1	while ((char2num(str[i])<=32)&&(char2num(str[i])>0))	return str[i,strlen(str)-1]EndStatic Function/T TrimTraiingWhiteSpace(str)	String str	Variable i	i = strlen(str)	do											// skip leading white space		i -= 1	while ((char2num(str[i])<=32)&&(char2num(str[i])>0))	return str[0,i]EndFunction/T ChangePartsOfString(str,delim,new)	String str	String delim	String new	Variable id=strlen(delim)	Variable i	do		i = strsearch(str,delim,0 )		if (i>=0)			str[i,i+id-1] = new		endif	while(i>=0)	return strEndFunction/T MakeInfoIntoListItem(line,line1)	String line,line1	String key,value	line = TrimLeadingWhiteSpace(line)	line = TrimTraiingWhiteSpace(line)	Variable i = strsearch(line," ",0)	if (i>1)		key = line[1,i-1]	else		key = line[1,strlen(line)]	endif	if (strlen(key)<1)							// nothing to save		return ""	endif	value = TrimLeadingWhiteSpace(line1)		// skip leading white space	value = TrimTraiingWhiteSpace(value)	if (strlen(value)<1)						// nothing to save		return ""	endif	return key+":"+value+";"EndFunction/T ValidIgorWaveName(name)	// if necessary converts name to a valid Igor wave name	String name	if (cmpstr("2theta", name)==0)		// special for 2theta		return "ttheta"	endif	// special for "Æ"	Variable i=strsearch(name,"Æ",0)	if (i>=0)		name[i,i] = "delta_"	endif	name = CleanupName(name, 0)	name = ChangePartsOfString(name,"___","_")	name = ChangePartsOfString(name,"__","_")	i = strlen(name)-1	if (stringmatch(name[i],"_"))			// suppress unnecessary trailing "_"		name[i,i]=""	endif	name = CleanupName(name, 0)	if (CheckName(name, 1))		name = name+"_"	endif	if (WaveExists($name))		name = name+"_1"	endif	if (CheckName(name, 1))		Abort "cannot form legal wave name from '"+name+"'"		return ""	endif	return nameEndFunction AssignOneLine(line,point,ncols,list)//	String line="6398.5 11773 5 3.16608e+06 1447 305824 0 0 0 1.49217e+06 339"	String line	Variable point	Variable ncols	String list	line = ChangePartsOfString(line,"\t"," ")		// change tab delimited to space	String name			// name of data wave	Variable i=0	Variable j = 0	do		name = StringFromList(i,list, ",")		// loop over any leading white space (i.e. if line[j+1]<" ", incrment j		j -= 1										// because loop always gives extra incrment		do			j += 1		while (char2num(line[j])<=32)			// check character		if (char2num(name[0])>32)				// do not actually save if name starts with a space			Wave w=$name			w[point] = str2num(line[j,inf])		endif		j = strsearch(line," ",j)				// j is now position of next space		i += 1	while(i<ncols)End