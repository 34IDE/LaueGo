#pragma rtGlobals=2		// Use modern global access method.#pragma IgorVersion = 4.1#pragma version = 0.01#include "spec", version>=2.17Function deadTime(det)	Variable det	Variable W0 = 559897.975452345	Variable W1 = -563471.687494516	Variable W2 = 1.89519906301593e-06	Variable corrected = -ln((det-W0)/W1)/W2	if (numtype(corrected) || corrected<det)		return det	else		return corrected	endifEnd// An Example, puts peak statistics on the plot////Function addMoreAnnotation2specPlot(scanNum)//	Variable scanNum////	String fldr = Find_specDataFolder(scanNum)//	Wave xw = $(fldr+StrVarOrDefault(fldr+"xAxisName",""))//	Wave yw = $(fldr+StrVarOrDefault(fldr+"yAxisName",""))//	if (!WaveExists(yw))//		return 1//	endif////	String list = peakStats(yw,xw)//	String str, units = SelectString(WaveExists(xw), WaveUnits(yw,0), WaveUnits(xw,-1))//	if (strlen(list))//		sprintf str,"\\Zr080FWHM = %.4g\rcenter = %.4g\rmax = %.4g\r  at  %g%s",NumberByKey("fwhm",list),NumberByKey("center",list),NumberByKey("max",list),NumberByKey("Xmax",list),units//		TextBox/C/N=textPeak/F=0/B=1 str//	endif////	Wave Hw=$(fldr+"H"), Kw=$(fldr+"K"), Lw=$(fldr+"L")//	if (!WaveExists(Hw) || !WaveExists(Kw) || !WaveExists(Lw))//		return 1//	endif//	Variable m = NumberByKey("centerPnt",list)//	sprintf str,"\\Zr080hkl = (%.3f, %.3f, %.3f)\\M",Hw[m],Kw[m],Lw[m]//	AppendText/N=text0 str//	ModifyGraph mode=4,marker=19,msize=2//	return 0//End//////Static Function/T peakStats(yw,xw)//	Wave yw,xw////	WaveStats/Q yw//	PulseStats/B=1/F=0.5/L=(0,V_max)/P/Q yw//	if (V_flag!=1 || numtype(V_PulseLoc1+V_PulseLoc2) || V_PulsePolarity<1)	// must have exactly 2 level crossings//		return ""//	endif//	Variable xlo,xhi, xmax//	if (WaveExists(xw))//		xlo = xw[V_PulseLoc1]//		xhi = xw[V_PulseLoc2]//		xmax = xw[(V_maxloc-DimOffset(yw,0))/DimDelta(yw,0)]//	else//		xlo = DimOffset(xw,0) + V_PulseLoc1*DimDelta(xw,0)//		xhi = DimOffset(xw,0) + V_PulseLoc2*DimDelta(xw,0)//		xmax = V_maxloc//	endif//	String list = ReplaceNumberByKey("fwhm","",abs(xhi-xlo))//	list = ReplaceNumberByKey("center",list,(xlo+xhi)/2)//	list = ReplaceNumberByKey("centerPnt",list,(V_PulseLoc1+V_PulseLoc2)/2)//	list = ReplaceNumberByKey("max",list,V_max)//	list = ReplaceNumberByKey("Xmax",list,xmax)//	return list//EndFunction extraSpecReadProcess(extra)	Variable extra	if (!extra)		return 0	endif	Variable ringPeriod = 3.68258537e-6 		// ring period, time between P0 pulses (s)	SVAR specCommand=specCommand	if (strsearch(specCommand,"dumpLeCroyScope",0)>=0 && exists("LeCroy"))		Wave LeCroy=LeCroy		SVAR specValues=specValues		// horiz_interval	= time between each point in LeCroy		// laser_delay	= time between laser start of LeCroy and excimer		Variable laser_delay = NumberByKey("laser_delay",specValues)		Variable horiz_interval = NumberByKey("horiz_interval",specValues)		laser_delay = numtype(laser_delay) ? 271.5*ringPeriod : laser_delay		// 271.5 = 1e-3/ringPeriod, so 271.5*ringPeriod = 1ms		horiz_interval = numtype(horiz_interval) ? ringPeriod : horiz_interval		horiz_interval = (horiz_interval==1) ? ringPeriod : horiz_interval		SetScale/P x -laser_delay*horiz_interval,horiz_interval ,"s", LeCroy	endif	if (exists("I0")==1)							// set Io wave if it exists		Wave wI0 = I0	elseif (exists("Io")==1)		Wave wI0 = Io	elseif (exists("I0_mon")==1)		Wave wI0 = I0_mon	endif	if ((exists("sig")!=1) && WaveExists(wI0))	// make a normalized wave		String fldr= GetDataFolder(0)		Variable scanNum = str2num(fldr[4,inf])		Variable filterTrans=specInfo(scanNum,"filterTrans")		filterTrans = numtype(filterTrans) ? 1 : filterTrans		if (exists("filter"))			Wave filterWave=filter			filterTrans = 1		endif		if (WaveDims(wI0)==1)			SVAR axisName=yAxisName			if (!SVAR_EXISTS(axisName))				SVAR axisName=specYwave			endif		elseif (WaveDims(wI0)==2)			SVAR axisName=zAxisName		else			DoAlert 0,"cannot yet deal with 3-d data"			return 1		endif//		SVAR yAxisName=yAxisName//		if (!SVAR_EXISTS(yAxisName))//			SVAR yAxisName=specYwave//		endif		axisName = StringFromList(0,axisName)	// only support one y wave here		if (exists("corr"))			Wave corr = corr			WaveStats/Q corr			axisName = SelectString(V_max!=0 || V_min!=0, axisName,"corr")		endif		Duplicate $axisName sig		// list of names that are probably photon counting detectors (obviously I0 is not in this list)		String photonCounter="detector;scint;NaI;oxfo;oxford;Bicr;Bicron;harmonic;Det_bot;Det_top;top_harmonic"		WAVE seconds=seconds		SVAR dark_Io_Name=root:Packages:spec:dark_Io_Name		Variable darkRate = specInfo(scanNum,dark_Io_Name)		String noteStr = ""		darkRate = numtype(darkRate) ? 0 : darkRate		if ((FindListItem(axisName, photonCounter)>=0) && (exists("sig_err")!=1) && (exists("seconds")==1))			Wave harm=harmonic			if (WaveExists(harm))				sig += 2*harm[p]			elseif (exists("deadtime")==6 && exists("seconds")==1)				sig /= seconds				sig = deadTime(sig)					// dead time works on counts/second only				sig *= seconds			endif			Duplicate $axisName sig_err			sig_err = sqrt(sig) / max(1,wI0-seconds*darkRate) / filterTrans			if (WaveExists(filterWave))				sig_err /= filterWave			endif			// add to wave note of sig_err, identifiying it as an err and its source			noteStr = note(sig_err)			noteStr  = ReplaceStringByKey("ErrorWaveSource", noteStr, "ErrorWaveSource:sig")			Note/K sig_err, noteStr		endif		if (exists("seconds")==1)			sig = sig / max(1,wI0-seconds*darkRate) / filterTrans		else			sig = sig / wI0 / filterTrans		endif		if (WaveExists(filterWave))			sig /= filterWave		endif		noteStr = note(sig)		Note/K sig, ReplaceStringByKey("GraphAxisLabelVert", noteStr, WordToGreek(axisName) + " / I\\Bo\\M")		sig *= NumVarOrDefault("root:Packages:spec:scaleFactor",1)		axisName = "sig"	endifEnd//Function extraSpecReadProcess(extra)//	Variable extra//	if (!extra)//		return 0//	endif////	Variable ringPeriod = 3.68258537e-6 		// ring period, time between P0 pulses (s)////	SVAR specCommand=specCommand//	if (strsearch(specCommand,"dumpLeCroyScope",0)>=0 && exists("LeCroy"))//		Wave LeCroy=LeCroy//		SVAR specValues=specValues//		// horiz_interval	= time between each point in LeCroy//		// laser_delay	= time between laser start of LeCroy and excimer//		Variable laser_delay = NumberByKey("laser_delay",specValues)//		Variable horiz_interval = NumberByKey("horiz_interval",specValues)//		laser_delay = numtype(laser_delay) ? 271.5*ringPeriod : laser_delay//		// 271.5 = 1e-3/ringPeriod, so 271.5*ringPeriod = 1ms//		horiz_interval = numtype(horiz_interval) ? ringPeriod : horiz_interval//		horiz_interval = (horiz_interval==1) ? ringPeriod : horiz_interval//		SetScale/P x -laser_delay*horiz_interval,horiz_interval ,"s", LeCroy//	endif////	if (exists("I0")==1)							// set Io wave if it exists//		Wave wI0 = I0//	elseif (exists("Io")==1)//		Wave wI0 = Io//	elseif (exists("I0_mon")==1)//		Wave wI0 = I0_mon//	endif////	if ((exists("sig")!=1) && WaveExists(wI0))	// make a normalized wave//		String fldr= GetDataFolder(0)//		Variable scanNum = str2num(fldr[4,inf])//		Variable filterTrans=specInfo(scanNum,"filterTrans")//		filterTrans = numtype(filterTrans) ? 1 : filterTrans//		SVAR yAxisName=yAxisName//		if (!SVAR_EXISTS(yAxisName))//			SVAR yAxisName=specYwave//		endif//		yAxisName = StringFromList(0,yAxisName)	// only support one y wave here//		Duplicate $yAxisName sig//		// list of names that are probably photon counting detectors (obviously I0 is not in this list)//		String photonCounter="detector;scint;NaI;oxfo;oxford;Bicr;Bicron;harmonic;Det_bot;Det_top;top_harmonic"//		WAVE seconds=seconds//		SVAR dark_Io_Name=root:Packages:spec:dark_Io_Name//		Variable darkRate = specInfo(scanNum,dark_Io_Name)//		darkRate = numtype(darkRate) ? 0 : darkRate//		if ((FindListItem(yAxisName, photonCounter)>=0) && (exists("sig_err")!=1) && (exists("seconds")==1))//			if (exists("deadtime")==6 && exists("seconds")==1)//				sig /= seconds//				sig = deadTime(sig)					// dead time works on counts/second only//				sig *= seconds//			endif//			Duplicate $yAxisName sig_err//			sig_err = sqrt(sig) / (wI0-seconds*darkRate) / filterTrans//			// add to wave note of sig_err, identifiying it as an err and its source//			String noteStr = note(sig_err)//			noteStr  = ReplaceStringByKey("ErrorWaveSource", noteStr, "ErrorWaveSource:sig")//			Note/K sig_err//			Note sig_err, noteStr//		endif//		if (exists("seconds")==1)//			sig = sig / (wI0-seconds*darkRate) / filterTrans//		else//			sig = sig / wI0 / filterTrans//		endif//		yAxisName = "sig"//	endif//End//Proc extraSpecReadProcessOLD(extra)//	Variable extra//	Silent 1//	if (!extra)//		return//	endif////	string wI0=""								// find name of Io wave if it exists//	if (exists("I0")==1)//		wI0 = "I0"//	endif//	if (exists("Io")==1)//		wI0 = "Io"//	endif////	if ((exists("sig")!=1) && strlen(wI0))		// make a normalized wave//		String fldr= GetDataFolder(0)//		Variable scanNum = str2num(fldr[4,inf])//		Variable filterTrans=specInfo(scanNum,"filterTrans")//		filterTrans = numtype(filterTrans) ? 1 : filterTrans//		Duplicate $specYwave sig//		String photonCounter="detector;scint;NaI;scint;oxfo;oxford;Bicr;Bicron;harmonic;Det_bot;Det_top"//		if ((FindListItem( :specYwave, photonCounter)>=0) && (exists("sig_err")!=1))//			if (exists("deadtime")==6 && exists("seconds")==1)//				sig /= seconds//				sig = deadTime(sig)			// dead time works on counts/second only//				sig *= seconds//			endif//			Duplicate $specYwave sig_err//			sig_err = sqrt(sig) / $wI0 / filterTrans//		endif//		sig = sig / $wI0 / filterTrans//		specYwave = "sig"//	endif//End//////Proc extraSpecReadProcessOLDer(extra)//	Variable extra//	Silent 1//	if (!extra)//		return//	endif////	string wI0=""								// find name of Io wave if it exists//	if (exists("I0")==1)//		wI0 = "I0"//	endif//	if (exists("Io")==1)//		wI0 = "Io"//	endif////	if ((exists("sig")!=1) && strlen(wI0))		// make a normalized wave//		String fldr= GetDataFolder(0)//		Variable scanNum = str2num(fldr[4,inf])//		Variable filterTrans=specInfo(scanNum,"filterTrans")//		filterTrans = numtype(filterTrans) ? 1 : filterTrans//		String photonCounter="detector;scint;NaI;scint;oxfo;oxford;Bicr;Bicron;harmonic;Det_bot;Det_top"//		if ((FindListItem( :specYwave, photonCounter)>=0) && (exists("sig_err")!=1))//			Duplicate $specYwave sig_err//			sig_err = sqrt($specYwave) / $wI0 / filterTrans//		endif//		Duplicate $specYwave sig//		sig = sig / $wI0 / filterTrans//		specYwave = "sig"//	endif//EndFunction extraSpecRead(fileVar)	Variable fileVar							// file ref number	String line1,line2						// line of input from file	Variable i	FStatus fileVar							// this section special for reading #BL and #B lines	Variable FilePos = V_filePos			// this should be the start of the scan	line1 = FindDataLineType(fileVar,"##",1)	FReadLine fileVar, line2		if (strlen(line1)>2 && strlen(line2)>2)		// line1 = line1[4,inf]		Variable vertical_offset,vertical_gain,horiz_interval, laser_delay,laser_width		sscanf line1,"##vertical_offset=%g  vertical_gain=%g  horiz_interval=%g", vertical_offset,vertical_gain,horiz_interval		if (V_flag==3)			String/G specValues			SVAR dest=specValues			dest = ReplaceNumberByKey("vertical_offset", dest, vertical_offset)			dest = ReplaceNumberByKey("vertical_gain", dest, vertical_gain)			// horiz_interval	= time between each point in LeCroy			dest = ReplaceNumberByKey("horiz_interval", dest, horiz_interval)		endif		sscanf line2,"##laser_delay=%g  laser_width=%g", laser_delay,laser_width		if (V_flag==2)			String/G specValues			SVAR dest=specValues			// laser_delay	= time between laser start of LeCroy and excimer			// laser_width	= width of laser pulse			dest = ReplaceNumberByKey("laser_delay", dest, laser_delay)			dest = ReplaceNumberByKey("laser_width", dest, laser_width)		endif	endif	line1 = FindDataLineType(fileVar,"#G4 ",1)	if (strlen(line1)>2)		line1 = line1[4,inf]		SetValuesIntoList("--;--;--;wavelength",line1,"specValues")	endif	FSetPos fileVar, FilePos					// reset file position to start of scan	line1 = FindDataLineType(fileVar,"#R1 ",0)	if (strlen(line1)>2)		line1 = line1[4,inf]		String r1Names="--  peakXmax  peakmax  peakFWHM  peakCWHM  peakCOM  peakSUM"		SetBValues(r1Names,line1)	endif	FSetPos fileVar, FilePos					// reset file position to start of scanEnd//	Proc extraSpecRead(fileVar)//		Variable fileVar							// file ref number//		Silent 1//	//		String line1,line2						// line of input from file//		Variable i//	//		FStatus fileVar							// this section special for reading #BL and #B lines//		Variable FilePos = V_filePos			// this should be the start of the scan//	//	//		line1 = FindDataLineType(fileVar,"##",1)//		FReadLine fileVar, line2	//		if (strlen(line1)>2 && strlen(line2)>2)//			// line1 = line1[4,inf]//			Variable vertical_offset,vertical_gain,horiz_interval, laser_delay,laser_width//			sscanf line1,"##vertical_offset=%g  vertical_gain=%g  horiz_interval=%g", vertical_offset,vertical_gain,horiz_interval//			if (V_flag==3)//				String/G specValues//				SVAR dest=specValues//				dest = ReplaceNumberByKey("vertical_offset", dest, vertical_offset)//				dest = ReplaceNumberByKey("vertical_gain", dest, vertical_gain)//				dest = ReplaceNumberByKey("horiz_interval", dest, horiz_interval)//			endif//			sscanf line2,"##laser_delay=%g  laser_width=%g", laser_delay,laser_width//			if (V_flag==2)//				String/G specValues//				SVAR dest=specValues//				dest = ReplaceNumberByKey("laser_delay", dest, laser_delay)//				dest = ReplaceNumberByKey("laser_width", dest, laser_width)//			endif//		endif//	//		FSetPos fileVar, FilePos					// reset file position to start of scan//		line1 = FindDataLineType(fileVar,"#G4 ",1)//		if (strlen(line1)>2)//			line1 = line1[4,inf]//			SetValuesIntoList("--;--;--;wavelength",line1,"specValues")//		endif//	//		line1 = FindDataLineType(fileVar,"#I ",1)//		if (strlen(line1)>2)//			line1 = line1[3,inf]//			SetBValues("filter",line1)//		endif//	//	//	line1 = FindDataLineType(fileVar,"#B0 ",1)//	//	if (strlen(line1)>2)//	//		line1 = line1[4,inf]//	//		line2 = FindDataLineType(fileVar,"#B1 ",1)//	//		line2=line2[4,inf]//	//		SetBValues(line1,line2)//	//	endif//	////	//	line1 = FindDataLineType(fileVar,"#B2 ",1)//	//	if (strlen(line1)>2)//	//		line1 = line1[4,inf]//	//		line2 = FindDataLineType(fileVar,"#B3 ",1)//	//		line2=line2[4,inf]//	//		SetBValues(line1,line2)//	//	endif//	////	//	line1 = FindDataLineType(fileVar,"#B4 ",1)//	//	if (strlen(line1)>2)//	//		line1 = line1[4,inf]//	//		line2 = FindDataLineType(fileVar,"#B5 ",1)//	//		line2=line2[4,inf]//	//		SetBValues(line1,line2)//	//	endif//	////	//	line1 = FindDataLineType(fileVar,"#B6 ",1)//	//	if (strlen(line1)>2)//	//		line1 = line1[4,inf]//	//		line2 = FindDataLineType(fileVar,"#B7 ",1)//	//		line2=line2[4,inf]//	//		SetBValues(line1,line2)//	//	endif//	////	//	line1 = FindDataLineType(fileVar,"#B8 ",1)//	//	if (strlen(line1)>2)//	//		line1 = line1[4,inf]//	//		line2 = FindDataLineType(fileVar,"#B9 ",1)//	//		line2=line2[4,inf]//	//		SetBValues(line1,line2)//	//	endif//	////	//	line1 = FindDataLineType(fileVar,"#B10 ",1)//	//	if (strlen(line1)>2)//	//		line1 = line1[5,inf]//	//		line2 = FindDataLineType(fileVar,"#B11 ",1)//	//		line2=line2[5,inf]//	//		SetBValues(line1,line2)//	//	endif//	//		line1 = FindDataLineType(fileVar,"#R1 ",0)//		if (strlen(line1)>2)//			line1 = line1[4,inf]//			String r1Names="--  peakXmax  peakmax  peakFWHM  peakCWHM  peakCOM  peakSUM"//			SetBValues(r1Names,line1)//		endif//	//	//	line1 = FindDataLineType(fileVar,"#R2 ",0)//	//	if (strlen(line1)>2)//	//		line1 = line1[4,inf]//	//		String r2Names="--  osaX  osaY  zpX  zpY  zpZ  wireY"//	//		SetBValues(r2Names,line1)//	//	endif//	//		FSetPos fileVar, FilePos					// reset file position to start of scan//	EndFunction specMoreInit()	if (exists("root:Packages:spec:dark_Io_Name")!=2)		// name of value from specInfo with the dark current in Io		String /G root:Packages:spec:dark_Io_Name=""	endifEnd//Function/T RemoveOneListFromAnotherXX(mainList,toRemove)//	String mainList//	String toRemove//	String str//	Variable ii//	Variable i = 0//	do//		str = StringFromList(i, mainList )//		ii = WhichListItem(str , mainList )//		mainList = RemoveListItem(ii, mainList)//		i += 1//	while (strlen(str)>0)//	return mainList//End