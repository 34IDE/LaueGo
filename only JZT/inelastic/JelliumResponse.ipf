#pragma rtGlobals=1		// Use modern global access method.#pragma version = 0.01Menu "inelastic"	"Set Electron Density",  SetElectronDensity("",NaN)EndFunction SjelliumG(eV,qAngstrom,Gc)		//  gives S(q,w) in (1/eV) using G	Variable eV								// energy loss (eV), is normally positive (can be either)	Variable qAngstrom						// magnitude of q  (1/Å)	Variable/C Gc							// complex value of G (dimensionless)	NVAR aB=root:Packages:Constants:aB		// Bohr radius in Å	NVAR Rydberg=root:Packages:Constants:Rydberg	// Rydberg (eV)	Variable hartree=2*Rydberg			// unit of energy in au (eV)	NVAR Ve = root:Ve						// vol of one electron (Å^3)	Variable/C one = cmplx(1.,0.)	Variable/C Xo							// jellium Xo (au)	Variable vq = 4*PI/(qAngstrom*aB)^2	// in au	Variable X2								// -imag part of chi	Xo = (one-jellium_eps_rpa(qAngstrom,eV))/vq	X2 = -imag( Xo / ( one - vq*( one-Gc)*Xo) )	return X2 * Ve/(aB^3)/(hartree*PI)	// convert X to S in (1/eV)EndFunction/C jelliumXo(eV,qAngstrom)		// this gives X as a function of Xo, v, and G with q in 1/Å	Variable eV								// energy loss, is normally negative	Variable qAngstrom						// magnitude of q  (1/Å)	NVAR aB=root:Packages:Constants:aB		// Bohr radius in Å	Variable/C one = cmplx(1.,0.)	Variable vq = 4*PI/(qAngstrom*aB)^2	// in au	return (one-jellium_eps_rpa(qAngstrom,eV))/vqEndFunction/C jellium_eps_rpa(qAngstrom,w)	// computes Jellium Ki or Ki0, it needs some global variables	Variable qAngstrom						// q in (1/Å)	Variable w								// energy (in eV), immediately convert to au (Hartree)	NVAR aB=root:Packages:Constants:aB		// Bohr radius in Å	NVAR Rydberg=root:Packages:Constants:Rydberg	// Rydberg (eV)	Variable hartree=2*Rydberg			// unit of energy in au (eV)	NVAR kF_Ang = root:kF					// kF  (1/Å), set by SetElectronDensity	Variable kF = kF_Ang * aB				// kF (au)	Variable EF = kF^2 / 2					// Fermi energy (au)	Variable q = qAngstrom * aB				// q (au)	Variable e1,e2							// eps_rpa = cmplx(e1,e2)	Variable eq = (q^2)/2	Variable qvF = q*kF	Variable tkF = 2*kF						// convienent 2kF	w = abs(w/hartree)					// convert w into Hartree	if ( ((eq+w-qvF)==0) || ((eq-w-qvF)==0))	// fix the pole		w += 1.e-10	endif//	e1 = 1 + tkF/(PI*q^2) * ( 1	+ 1/(tkF*q^3) * (4*EF*eq - (eq+w)^2)*ln(abs((eq+w+qvF)/(eq+w-qvF)))//									+ 1/(tkF*q^3) * (4*EF*eq - (eq-w)^2)*ln(abs((eq-w+qvF)/(eq-w-qvF))) )//	e1 = 1 + tkF/(PI*q^2) * ( 1+ 1/(tkF*q^3) * (4*EF*eq-(eq+w)^2)*ln(abs((eq+w+qvF)/(eq+w-qvF)))  + 1/(tkF*q^3) * (4*EF*eq - (eq-w)^2)*ln(abs((eq-w+qvF)/(eq-w-qvF))) )	Variable del1,del2,arg1,arg2	del1 = eq+w	del2 = eq-w	arg1 = (del1+qvF)/(del1-qvF)	arg2 = (del2+qvF)/(del2-qvF)	Variable cons = 1/(tkF*q^3)	Variable EFeq4 = 4*EF*eq	e1 = 1 + tkF/(PI*q^2) * ( 1+ cons*(EFeq4-del1^2)*ln(abs(arg1))  + cons*(EFeq4 - (del2)^2)*ln(abs(arg2)) )	if ((abs(eq-qvF)<w) %& (w<(eq+qvF)))		e2 = 1/q^3 * (kF^2 - ((w-eq)/q)^2)		return cmplx(e1,e2)	endif	if (w>=(eq+qvF))		return cmplx(e1,0)	endif	if ((q<tkF) %& (w<=(qvF-eq)))		e2 = 2 * w / q^3		return cmplx(e1,e2)	endif	if (w<=0)		return cmplx(e1,0)	endif	if ((q>=tkF) %& (w<=(eq-qvF)))		return cmplx(e1,0)	endif	Abort "how did we get here in 'jellium_eps_rpa',   w = "+num2str(w*hartree)+" (eV)"EndFunction SetElectronDensity(type,value)		// This macro sets the global variables Ve, kF, r_sub_s, chiToS, kFaB, E_fermi	String type	Variable value	if (strlen(type)<1 || numtype(value))		if (strlen(type)<1)			type = "Ve"		endif		value = (numtype(value)||value<=0) ? 5.531 : value		// default to aluminum		Prompt type,"type of input", PopUp, "Ve (Å^3);r_s (au);kF (1/Å)"		Prompt value,"value for type"		DoPrompt "set electron density",type,value	endif	String fldrSav= GetDataFolder(1)	SetDataFolder root:	NVAR aB=root:Packages:Constants:aB		// Bohr radius in Å	NVAR Rydberg=root:Packages:Constants:Rydberg	// Rydberg (eV)	Variable hartree=2*Rydberg			// unit of energy in au (eV)	EnsureGlobalVariable("Ve",NaN)					// Volume of 1 electron (Å^3)	NVAR Ve=Ve	EnsureGlobalVariable("r_sub_s",NaN)				// radius of sphere with volume Ve (au)	NVAR r_sub_s=r_sub_s	EnsureGlobalVariable("kF",NaN)					// q of the Fermi wave vector (1/Å)	NVAR kF=kF	EnsureGlobalVariable("kFaB",NaN)					// kF in atomic units (au)	NVAR kFaB=kFaB	EnsureGlobalVariable("E_fermi",NaN)				// Fermi energy (eV)	NVAR E_fermi=E_fermi	EnsureGlobalVariable("chiToS",NaN)				// this time Xo (au) gives S (1/eV)	NVAR chiToS=chiToS	Variable wP											// plasma frequency (eV)	if (!cmpstr("Ve (Å^3)",type))		Ve = value										// Vol. of one electron (Å^3)		kF = (3.*PI^2/Ve) ^ (1./3.)		r_sub_s = (0.75 * Ve / PI)^(1./3.) / aB		// radius of sphere with volume Ve (au)		type="found"	endif	if (!cmpstr("r_s (au)",type))		r_sub_s = value								// radius of sphere with volume Ve in au		Ve = 4./3. *PI *(r_sub_s*aB)^3				// Vol. of one electron (Å^3)		kF = (3.*PI^2/Ve) ^ (1./3.)		type="found"	endif	if (!cmpstr("kF (1/Å)",type))		kF = value										// Fermi wavevector (1/Å)		Ve = (3.*PI^2) / (kF^3)						// Vol. of one electron (Å^3)		r_sub_s = (0.75 * Ve / PI)^(1./3.) / aB		// radius of sphere with volume Ve (au)		type="found"	endif	if (cmpstr(type,"found"))		SetDataFolder fldrSav		Abort("illegal type, use the popup menu")	endif	chiToS = Ve/(aB^3)/(hartree*PI)					// converts Xo (au) to S(q,w) (1/eV)	kFaB = kF * aB										// kF in atomic units (1 / Bohr radii)	E_fermi = (kFab^2)/2 * hartree	wP = sqrt(3/r_sub_s^3)*hartree					// plasma frequency (eV)	printf "Ve = %g (Å^3),  r_s = %g (au),  kF = %g (1/Å),  kF(ab) = %g (au),  E_fermi = %g (eV),  chiToS = %g,  wP = %g (eV)\r", Ve,r_sub_s,kF, kFaB, E_fermi, chiToS,wP	SetDataFolder fldrSavEndMacroProc SetElectronDensityOLD(type,value)		// This macro sets the global variables Ve, kF, r_sub_s, chiToS, kFaB, E_fermi	String type="Ve"	Prompt type,"type of input", PopUp, "Ve (Å^3);r_s (au);kF (1/Å)"	Variable value=5.531	Silent 1	String fldrSav= GetDataFolder(1)	SetDataFolder root:	NVAR aB=root:Packages:Constants:aB		// Bohr radius in Å	NVAR Rydberg=root:Packages:Constants:Rydberg	// Rydberg (eV)	Variable hartree=2*Rydberg			// unit of energy in au (eV)	EnsureGlobalVariable("Ve",NaN)					// Volume of 1 electron (Å^3)	EnsureGlobalVariable("r_sub_s",NaN)				// radius of sphere with volume Ve (au)	EnsureGlobalVariable("kF",NaN)					// q of the Fermi wave vector (1/Å)	EnsureGlobalVariable("kFaB",NaN)					// kF in atomic units (au)	EnsureGlobalVariable("E_fermi",NaN)				// Fermi energy (eV)	EnsureGlobalVariable("chiToS",NaN)				// this time Xo (au) gives S (1/eV)	Variable wP											// plasma frequency (eV)	if (!cmpstr("Ve (Å^3)",type))		Ve = value										// Vol. of one electron (Å^3)		kF = (3.*PI^2/Ve) ^ (1./3.)		r_sub_s = (0.75 * Ve / PI)^(1./3.) / aB		// radius of sphere with volume Ve (au)		type="found"	endif	if (!cmpstr("r_s (au)",type))		r_sub_s = value								// radius of sphere with volume Ve in au		Ve = 4./3. *PI *(r_sub_s*aB)^3				// Vol. of one electron (Å^3)		kF = (3.*PI^2/Ve) ^ (1./3.)		type="found"	endif	if (!cmpstr("kF (1/Å)",type))		kF = value										// Fermi wavevector (1/Å)		Ve = (3.*PI^2) / (kF^3)						// Vol. of one electron (Å^3)		r_sub_s = (0.75 * Ve / PI)^(1./3.) / aB		// radius of sphere with volume Ve (au)		type="found"	endif	if (cmpstr(type,"found"))		SetDataFolder fldrSav		Abort("illegal type, use the popup menu")	endif	chiToS = Ve/(aB^3)/(hartree*PI)					// converts Xo (au) to S(q,w) (1/eV)	kFaB = kF * aB										// kF in atomic units (1 / Bohr radii)	E_fermi = (kFab^2)/2 * hartree	wP = sqrt(3/r_sub_s^3)*hartree					// plasma frequency (eV)	printf "Ve = %g (Å^3),  r_s = %g (au),  kF = %g (1/Å),  kF(ab) = %g (au),  E_fermi = %g (eV),  chiToS = %g,  wP = %g (eV)\r", Ve,r_sub_s,kF, kFaB, E_fermi, chiToS,wP	SetDataFolder fldrSavEndMacroFunction EnsureGlobalVariable(str,value)	String str	Variable value=0	if (  (exists(str)!=2) %& (strlen(str)>0)  )		// create global variable if it does not exist		Variable/G $str	endif	if(!numtype(value))								// assign a value if a valid one is passed		NVAR var=$str		var = value	endifEnd