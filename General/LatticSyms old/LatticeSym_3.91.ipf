#pragma rtGlobals=1		// Use modern global access method.#pragma ModuleName=LatticeSym#pragma version = 3.91#include "Utility_JZT" version>=3.03#include "MaterialsLocate"								// used to find the path to the materials files////	remember to execute    InitLatticeSymPackage()////	with version 2.0, added a text description to the crystalStructure structure////	with version 3.0, fixed up and changed the symmetry operators, I now think that they are right//	with version 3.1, only compute symmetry operations as needed//	with version 3.2, fixed Trigonal, now can use rhombohedral axes//	with version 3.3, fixed lowestAllowedHKL() made alpha, beta & gamma non-zero //	with version 3.41, fixed Fstruct(), removed multiplicity since it is taken care of with by calculating all atom positions//	with version 3.44, added PrimitiveCellFactor()//	with version 3.45, fixed PrimitiveCellFactor(), to deal proplerly with other systems//	with version 3.46, made Fstruct() not forbidden for non-integral h,k,or l//	with version 3.47, restrict Rhombohedral to only SG={146,148,155,160,161,166,167} symmetry symbols starting with an "R"//	with version 3.48, UpdateCrystalStructureDefaults() changed to remove hashID when structure changes//	with version 3.50, setDirectRecip() changed to handle Unconventional correctly & have at least 1 dummy atom, reMakeAtomXYZs() changed to make one atom when none are given//	with version 3.51, changed allowed reflection limit from 0.1 electron/atom to 0.01//	with version 3.52, added MakeSymmetryOps() to LatticeSym.ipf//	with version 3.53, problem setting lattice parameters for Trigonal (using Hex axes) in LatticePanelParamProc()//	with version 3.54, changed UpdateCrystalStructureDefaults() to first write structstr to Packages//	with version 3.55, more changing how crystalStructStr is saved.//	with version 3.56, changed again how crystalStructStr is saved.  Changed FillCrystalStructDefault() & UpdateCrystalStructureDefaults()//	with version 3.57, added ability to read xml files.  Modified readCrystalStructure(), and added: readFileXML(), RemoveCommentsXML(), TagAttributesXML(), TagContentsXML(), ConvertUnits2meters()//	with version 3.58, moved all interpretation of xml to Utilit_JZT.ipf, deleted:  RemoveCommentsXML(), TagAttributesXML(), TagContentsXML()//	with version 3.59, improved ConvertUnits2meters()//	with version 3.61, Added ability to write current xtal structure to a file.//	with version 3.62, Added #include "Utility_JZT", previously it was not explicitly stated.//	with version 3.63, Included ability of Fstruct() to use Cromer-Liberman values for atomic structure factors (if CromerLiberman.ipf is loaded).//	with version 3.64, added FindMaterialsFile(), so now will automatically search for local copies of materials files.//	with version 3.65, made the following functions ThreadSafe.://		dSpacing(), ZfromLabel(), Z2symbol(), num2StrFull(), SingleWhiteSpace(), MakeSymmetryOps(), isMatInMats(), getHMsym()//		latticeSystem(), ALLOW_FC(), ALLOW_BC(), ALLOW_CC(), ALLOW_AC(), ALLOW_RHOM_HEX(), ALLOW_HEXAGONAL()//		isRhombohedral(), PrimitiveCellFactor(), lowestOrderHKL(), hkl2str(), placesOfPrecision()//	with version 3.67, fixed up minus2bar() and added hkl2IgorBarStr()//	with version 3.68, fixed up Rhombohedral/Hex issue in LatticePanelParamProc(), and prints Rhombohedral constants in print_crystalStructure()//	with version 3.69, changed getSymString() to getHMsym(), added getFullHMSym(), getHMboth(), and getHallSymbol().  DO NOT use getSymString any more.//	with version 3.73, moved str2recip() to here from microGeometryN and other places//	with version 3.74, changed setDirectRecip(), added a default name when no atoms are defined//	with version 3.75, added:  Hex2Rhom(aH,cH)  &  Rhom2Hex(aR,alpha)//	with version 3.76, changed: FillCrystalStructDefault() so to save the lattice in Pacakges whenever it has to load from preferences//	with version 3.77, aded: findClosestHKL(), finds the hkl that is closest to the given d-spacing//	with version 3.78, fixed SERIOUS BUG in readCrystalStructureXML()//	with version 3.79, allowed xml input files to contain <fract_xyz>0 0 0</fract_xyz> instead of separate fract_x, fract_y, fract_z//		added a list of bond types & Temperature, this changes crystalStructure, bondTypeStructure, print_crystalStructure(), readFileXML()//	with version 3.80, added full support for Temperature, including proper handling of Temperature units (supports C, K, R, & F, default is C)//	with version 3.81, changed "bond_type" to "bond_chemical", also changed bonds to use label0 & label1 (not name0, name1)//	with version 3.82, added menus for AtomView.ipf and PowderPatterns.ipf//		also moved menus for AtomView.ipf and PowderPatterns.ipf to the Analysis->Lattice sub menu//	with version 3.83, modified symmtry2SG() and added SymString2SG(), this makes it easy to find Space Group number when you know the symbol//	with version 3.90, modified the panel so that user can use wild cards to find the correct space group. LOTS of changes// Rhombohedral Transformation://// for Rhombohedral (hkl), and Hexagonal (HKL)//		h = (2H+K+L)/3//		k = (-H+K+L)/3//		l = (-H-2K+L)/3//		and the condition (-H+K+L) = 3n (where n is an integer) for allowed reflections, three Rhombohedral cells per Hexagonal cell////		H = h=k//		K = k-l//		L = h+k+l////	for Hexagonal lattice constants aH,cH (alpha=beta=90, gamma=120)//	a(Rhom) = sqrt(3*aH^2 + cH^2)/3//	sin(alpha(Rhom)/2) = 1.5/sqrt(3+(cH/aH)^2)//	These equations are implented in the routines:  Hex2Rhom(aH,cH)  &  Rhom2Hex(aR,alpha)Menu "Analysis"	SubMenu "Lattice"		"Show Crystal Structure",showCrystalStructure()		help={"Shows the crystal structure and lattice that is currently defined"}		"Set Crystal Structure...",MakeLatticeParametersPanel("")		help={"Define the crystal structure and lattice to be used"}		"Load a new Crystal Structure...",LoadCrystal("")		help={"load a rystal structure from a fie"}		"Write Current Crystal to XML File...",writeCrystalStructure2xmlFile("","")		help={"takes the current crystal structure and writes it to an xml file"}		"d[hkl]",/Q,get_dhkl(NaN,NaN,NaN,T=NaN)		help={"show d-spacing for the hkl reflection"}		"Fstructure [hkl]",getFstruct(NaN,NaN,NaN)		help={"Crude Structure Factor using current lattice"}		"Find Closest hkl from d-spacing or Q",findClosestHKL(NaN)		help={"Knowing either the d-spacing or the Q, find closest hkl's"}		"\\M0Space Group number <ÐÐ> symmetry",symmtry2SG("")		help={"find the Space Group number from symmetry string,  e.g. Pmma, or sym from number"}		"angle between two hkl's",angleBetweenHKLs(NaN,NaN,NaN,  NaN,NaN,NaN)		"  Convert old xtl files to new xml files",ConverXTLfile2XMLfile("")		"-"		MenuItemIfWindowAbsent("Include Powder Patterns Support","PowderPatterns.ipf"), Execute/P "INSERTINCLUDE  \"PowderPatterns\", version>=0.07";Execute/P "COMPILEPROCEDURES ";Execute/P "Init_Powder()"		help = {"Load Function used to compute Powder Patterns from Loaded Lattice"}		MenuItemIfWindowAbsent("Include Atom View Support","AtomView.ipf"), Execute/P "INSERTINCLUDE  \"AtomView\", version>=0.10";Execute/P "COMPILEPROCEDURES ";Execute/P "Init_AtomView()"		help = {"Load Function used to Display Atoms from the Loaded Lattice in a Gizmo"}	EndEndStatic Constant STRUCTURE_ATOMS_MAX=20	// max number of atom types in a material structure (for Si only need 1)//Strconstant CommonPredefinedStructures = "FCC:255;BCC:229;Diamond:227;Perovskite:221;Cubic:195;Hexagonal:194;Wurtzite (B4):186;Sapphire:167;"Strconstant CommonPredefinedStructures = "FCC:255;BCC:229;Diamond:227;Perovskite:221;Cubic:195;Wurtzite (B4):186;Sapphire:167;"// =========================================================================// =========================================================================//	Start of setting particular lattice constantsFunction MakeLatticeParametersPanel(strStruct)	String strStruct									// optional passed value of geo structure, this is used if passed	if (strlen(WinList("LatticeSet",";","WIN:64")))	// window alreay exits, bring it to front		DoWindow/F LatticeSet		return 0	endif	NewPanel /K=1 /W=(675,60,675+220,60+433)	DoWindow/C LatticeSet	FillLatticeParametersPanel(strStruct,"LatticeSet",0,0)EndFunction showCrystalStructure()						// prints the structure that is currently being used	STRUCT crystalStructure xtal	if (FillCrystalStructDefault(xtal))					//fill the lattice structure with test values		DoAlert 0, "no crystal structure found"		return 1	endif	String str, sym = getHMboth(xtal.SpaceGroup)	sprintf str, "'%s'  %d atoms,  #%d   %s\r%.9g, %.9g, %.9gnm,\r%g¡, %g¡, %g¡",xtal.desc,xtal.N,xtal.SpaceGroup,sym,xtal.a,xtal.b,xtal.c,xtal.alpha,xtal.beta,xtal.gam	DoAlert 1,str+"\r\tprint all details to history too?"	if (V_flag==1)		print_crystalStructure(xtal)					// prints out the value in a crystalStructure structure	else		printf "currently using  '%s'  lattice is  #%d   %s     %.9gnm, %.9gnm, %.9gnm,   %g¡, %g¡, %g¡\r",xtal.desc,xtal.SpaceGroup,sym,xtal.a,xtal.b,xtal.c,xtal.alpha,xtal.beta,xtal.gam		if (xtal.alphaT>0)			printf "coefficient of thermal expansion is %g\r",xtal.alphaT		endif	endif	return 0EndStructure crystalStructure		// structure definition for a crystal lattice	char desc[100]				// name or decription of this crystal	double a,b,c					// latticde constants, length (nm)	double alpha,beta,gam		// angles (degree)	int16 SpaceGroup			// Space Group number from international tables, allowed range is [1, 230]	double  a0,  b0,  c0			// direct lattice from constants { a[], b[], c[] }	double  a1,  b1,  c1	double  a2,  b2,  c2	double  as0,  bs0,  cs0		// reciprocal lattice { a*[], b*[], c*[] }	double  as1,  bs1,  cs1		// a*,b*,c* already have the 2PI in them	double  as2,  bs2,  cs2	double Vc					// volume of cell, triple product of (a[]xb[]).c	double density				// calculated density (g/cm^3)	double Temperature			// Temperature (C)	double	alphaT				// coef of thermal expansion, a = ao*(1+alphaT*(TempC-22.5))	int16 N						// number of atoms described here	Struct atomTypeStructure atom[STRUCTURE_ATOMS_MAX]	int16 Nbonds				// number of bonds described here	Struct bondTypeStructure bond[2*STRUCTURE_ATOMS_MAX]	double Unconventional00,Unconventional01,Unconventional02	// transform matrix for an unconventional unit cel	double Unconventional10,Unconventional11,Unconventional12	double Unconventional20,Unconventional21,Unconventional22	char hashID[66]			// hash function for this strucutre (needs to hold at least 64 chars)EndStructure//Structure atomTypeStructure	// defines one type of atom in a crystal structure	char name[60]				// label for this atom, usually starts with atomic symbol	int16 Zatom				// Z of the atom	double x					// fractional coord along x lattice vector	double y	double z	double occ					// occupancy	double Debye				// Debye-Waller factorEndStructure//Structure bondTypeStructure	// defines the type of bond between two atom types	char label0[60]			// label for first atom, usually starts with atomic symbol	char label1[60]			// label for second atom, usually starts with atomic symbol	int16 N						// number of bonds in len (often just 1)	double len[5]				// length of bond (possibly multiple values) (nm)EndStructureFunction print_crystalStructure(xtal)			// prints out the value in a crystalStructure	STRUCT crystalStructure &xtal				// this sruct is printed in this routine	Variable i,N=xtal.N	if (WhichListItem("LatticePanelButtonProc",GetRTStackInfo(0))>=0)		printf "¥showCrystalStructure()\r"	endif	if (strlen(xtal.desc))		printf "'%s'   \t",xtal.desc	else		printf "\t\t\t"	endif	Variable SG = xtal.SpaceGroup	printf "Space Group=%d   %s   %s       Vc = %g (nm^3)",SG,StringFromList(latticeSystem(SG),LatticeSystemNames), getHMboth(SG),xtal.Vc	if (xtal.density>0)		printf "       density = %g (g/cm^3)",xtal.density	endif	if (xtal.alphaT>0)		printf "     coefficient of thermal expansion is %g\r",xtal.alphaT	else		printf "\r"	endif	printf "lattice constants  { %.15gnm, %.15gnm, %.15gnm,   %.15g¡, %.15g¡, %.15g¡ }\r",xtal.a,xtal.b,xtal.c,xtal.alpha,xtal.beta,xtal.gam	if (SG<=167 && SG>=143 && (abs(90-xtal.alpha)+abs(90-xtal.beta)+abs(120-xtal.gam))<1e-6)	// also show rhombohedral lattice constants		Variable aRhom = sqrt(3*(xtal.a)^2 + (xtal.c)^2)/3		Variable alphaRhom = 2*asin(1.5/sqrt(3+(xtal.c/xtal.a)^2)) * 180/PI		printf "   Rhombohedral constants, aRhom = %.8g nm,   alpha(Rhom) = %.8g¡\r",aRhom,alphaRhom	endif	if (numtype(xtal.Temperature)==0)		Variable Temperature = xtal.Temperature		String unit = "C"		if (Temperature < -100)					// display in Kelvin			unit = "K"			Temperature = ConvertTemperatureUnits(Temperature,"C",unit)		// xtal.Temperature is always C		endif		printf "   Temperature = %g ¡%s\r",Temperature,unit	endif	if (N<1)		print "No Atoms Defined"	else		Variable mult		reMakeAtomXYZs(xtal)		printf "atom type locations:\r"		for (i=0;i<xtal.N;i+=1)			printf "     %s (Z=%g)\t\t{%g,  %g,  %g}",xtal.atom[i].name,xtal.atom[i].Zatom,xtal.atom[i].x,xtal.atom[i].y,xtal.atom[i].z			if (xtal.atom[i].occ != 1)				printf "    occ = %g",xtal.atom[i].occ			endif			if (xtal.atom[i].Debye > 0)				printf "    Debye-Waller = %g",xtal.atom[i].Debye			endif			mult = DimSize($("root:Packages:Lattices:atom"+num2istr(i)),0)			if (mult>1)				printf "\t\tmultiplicity = %d",mult			endif			printf "\r"		endfor		if (xtal.Nbonds > 0)			printf "defined bonds types (nm):\r"			for (i=0;i<xtal.Nbonds;i+=1)				Make/N=(xtal.bond[i].N)/FREE/D lens				lens = xtal.bond[i].len[p]				printf "     %s  <-->  %s:  %s\r",xtal.bond[i].label0,xtal.bond[i].label1,vec2str(lens,bare=1)			endfor		endif		printf "\rindividual atom positions:\rtype	frac xyz\r"		Variable j		for (i=0;i<xtal.N;i+=1)			Wave wa = $("root:Packages:Lattices:atom"+num2istr(i))			if (!WaveExists(wa))				break			endif			for (j=0;j<DimSize(wa,0);j+=1)				printf "%d\t\t{%g,  %g,  %g}\r"i,wa[j][0],wa[j][1],wa[j][2]			endfor		endfor	endif	if (numtype(xtal.Unconventional00)==0)					// Unconventional exists, transform the lattice by it		printf "\rusing an Uncoventional Cell, the transform is:\r"		printf "\t\t%+6.3f\t\t%+6.3f\t\t%+6.3f\r",xtal.Unconventional00,xtal.Unconventional01,xtal.Unconventional02		printf "\tT =\t%+6.3f\t\t%+6.3f\t\t%+6.3f\r",xtal.Unconventional10,xtal.Unconventional11,xtal.Unconventional12		printf "\t\t%+6.3f\t\t%+6.3f\t\t%+6.3f\r",xtal.Unconventional20,xtal.Unconventional21,xtal.Unconventional22	endif	printf "\r"	printf "				a				b				c   (nm)\r"	printf "direct		%+10.7f\t%+10.7f\t%+10.7f\r",xtal.a0,xtal.b0,xtal.c0	printf "lattice		%+10.7f\t%+10.7f\t%+10.7f\r",xtal.a1,xtal.b1,xtal.c1	printf "			%+10.7f\t%+10.7f\t%+10.7f\r",xtal.a2,xtal.b2,xtal.c2	printf "\r				a*				b*				c*  (1/nm)\r"	printf "recip	\t%+10.6f\t%+10.6f\t%+10.6f\r",xtal.as0,xtal.bs0,xtal.cs0	printf "lattice	\t%+10.6f\t%+10.6f\t%+10.6f\r",xtal.as1,xtal.bs1,xtal.cs1	printf "		\t%+10.6f\t%+10.6f\t%+10.6f\r",xtal.as2,xtal.bs2,xtal.cs2	if (strlen(xtal.hashID)<2)		printf "hash id = '%s'\r",xtal.hashID	endifEndStatic Function LatticeBad(xtal)	STRUCT crystalStructure &xtal	Variable bad=0	bad += numtype(xtal.a + xtal.b + xtal.c)	bad += !(xtal.a > 0) || !(xtal.b > 0) || !(xtal.c > 0)	bad += numtype(xtal.alpha + xtal.beta + xtal.gam)	bad += !(xtal.alpha > 0) || !(xtal.beta > 0) || !(xtal.gam > 0)	bad += xtal.alpha >=180 || xtal.beta >= 180 || xtal.gam >= 180	bad += numtype(xtal.SpaceGroup) || xtal.SpaceGroup < 1 || xtal.SpaceGroup > 230	return (bad>0)End// forces lattice constants to match the Space Group number (e.g. for cubic, forces b and c to be a, and all angles 90)Static Function ForceLatticeToStructure(xtal)	STRUCT crystalStructure &xtal					// this sruct is set in this routine	Variable SpaceGroup=xtal.SpaceGroup			// local value for convienence	if (SpaceGroup!=limit(SpaceGroup,1,230))		// invalid SpaceGroup, it must be in range [1,230]		DoAlert 0, "invalid Space Group number "+num2str(SpaceGroup)		return 1	endif	//	Cubic			[195,230]	//	a	//	Hexagonal		[168,194]	//	a,c	//	Trigonal		[143,167]	//	a,alpha	//	Tetragonal		[75,142]		//	a,c	//	Orthorhombic	[16,74]		//	a,b,c	//	Monoclinic		[3,15]			//	a,b,c,gamma	//	Triclinic		[1,2]			//	a,b,c,alpha,beta,gamma	if (SpaceGroup>=195)				// Cubic		xtal.b = xtal.a		xtal.c = xtal.a		xtal.alpha=90;  xtal.beta=90;  xtal.gam=90	elseif(SpaceGroup>=168)			// Hexagonal		xtal.b = xtal.a		xtal.alpha=90;  xtal.beta=90;  xtal.gam=120	elseif(SpaceGroup>=143)			// Trigonal (generally hexagonal cell), for rhomohedral use rhomohedral cell, unless obviously the hexagonal		if (isRhombohedral(SpaceGroup))	// rhombohedral structure			if ((abs(90-xtal.alpha)+abs(90-xtal.beta)+abs(120-xtal.gam))<1e-6)	// obviously hexagonal				xtal.b = xtal.a				xtal.alpha=90  ;  xtal.beta=90  ;  xtal.gam=120			else							// rhombohedral with rhombohedral cell				xtal.b = xtal.a				xtal.c = xtal.a				xtal.beta = xtal.alpha				xtal.gam = xtal.alpha			endif		else								// "P" trigonal, use hexagonal cell			xtal.b = xtal.a			xtal.alpha=90  ;  xtal.beta=90  ;  xtal.gam=120		endif	elseif(SpaceGroup>=75)				// Tetragonal		xtal.b = xtal.a		xtal.alpha=90;  xtal.beta=90;  xtal.gam=90	elseif(SpaceGroup>=16)				// Orthorhombic		xtal.alpha=90;  xtal.beta=90;  xtal.gam=90	elseif(SpaceGroup>=3)				// Monoclinic//		xtal.alpha=90;  xtal.beta=90		xtal.alpha=90;  xtal.gam=90//	else									// Triclinic	endif	String str	if (xtal.a<=0 || xtal.b<=0 || xtal.c<=0 || numtype(xtal.a+xtal.b+xtal.c))	// check for valid a,b,c		sprintf str,"invalid, (a,b,c) = (%g,%g,%g)",xtal.a,xtal.b,xtal.c		DoAlert 0, str		return 1	endif	Variable alpha=xtal.alpha,bet=xtal.beta,gam=xtal.gam	if (alpha<=0 || bet<=0 || gam<=0 || alpha>=180 || bet>=180 || gam>=180 || numtype(alpha+bet+gam))	// check for valid angles		sprintf str,"invalid, (alpha,beta,gam) = (%g,%g,%g)",alpha,bet,gam		DoAlert 0, str		return 1	endif	setDirectRecip(xtal)								// update Vc, direct and recip, density, and also calculates atom positions	return 0End//Static Function setDirectRecip(xtal)					// set direct and recip lattice vectors from a,b,c,..., also calculates Vc & density	STRUCT crystalStructure &xtal	Variable a=xtal.a, b=xtal.b, c=xtal.c	Variable sa = sin((xtal.alpha)*PI/180), ca = cos((xtal.alpha)*PI/180)	Variable cb = cos((xtal.beta)*PI/180), cg = cos((xtal.gam)*PI/180)	Variable phi = sqrt(1.0 - ca*ca - cb*cb - cg*cg + 2*ca*cb*cg)	// = Vc/(a*b*c)	xtal.Vc = a*b*c * phi								// volume of unit cell	Variable pv = (2*PI) / (xtal.Vc)				// used for scaling	Variable a0,a1,a2,  b0,b1,b2,  c0,c1,c2		//components of the direct lattice vectors	a0=a*phi/sa	; a1=a*(cg-ca*cb)/sa	; a2=a*cb	b0=0			; b1=b*sa				; b2=b*ca	c0=0			; c1=0					; c2=c	xtal.a0=a0		; xtal.a1=a1	; xtal.a2=a2	xtal.b0=b0		; xtal.b1=b1	; xtal.b2=b2	xtal.c0=c0		; xtal.c1=c1	; xtal.c2=c2	xtal.as0=(b1*c2-b2*c1)*pv	; xtal.as1=(b2*c0-b0*c2)*pv	; xtal.as2=(b0*c1-b1*c0)*pv	// (b x c)*2¹/Vc	xtal.bs0=(c1*a2-c2*a1)*pv	; xtal.bs1=(c2*a0-c0*a2)*pv	; xtal.bs2=(c0*a1-c1*a0)*pv	// (c x a)*2¹/Vc	xtal.cs0=(a1*b2-a2*b1)*pv	; xtal.cs1=(a2*b0-a0*b2)*pv	; xtal.cs2=(a0*b1-a1*b0)*pv	// (a x b)*2¹/Vc	Variable allZero = abs(xtal.Unconventional00)+abs(xtal.Unconventional01)+abs(xtal.Unconventional02)	allZero += abs(xtal.Unconventional10)+abs(xtal.Unconventional11)+abs(xtal.Unconventional12)	allZero += abs(xtal.Unconventional20)+abs(xtal.Unconventional21)+abs(xtal.Unconventional22)	xtal.Unconventional00 = allZero==0 ? NaN : xtal.Unconventional00	if (numtype(xtal.Unconventional00)==0 && xtal.Unconventional00>-100 && xtal.Unconventional00<100)		Make/N=(3,3)/O/D root:Packages:Lattices:Unconventional		Wave Unconventional=root:Packages:Lattices:Unconventional		Unconventional[0][0]=xtal.Unconventional00;	Unconventional[0][1]=xtal.Unconventional01;	Unconventional[0][2]=xtal.Unconventional02		Unconventional[1][0]=xtal.Unconventional10;	Unconventional[1][1]=xtal.Unconventional11;	Unconventional[1][2]=xtal.Unconventional12		Unconventional[2][0]=xtal.Unconventional20;	Unconventional[2][1]=xtal.Unconventional21;	Unconventional[2][2]=xtal.Unconventional22	else		KillWaves/Z root:Packages:Lattices:Unconventional	endif	xtal.density = densityOfCrystalStructure(xtal)	if (xtal.N==0)								// no atom defined, make one dummy atom		xtal.N = 1		xtal.atom[0].x = 0		xtal.atom[0].y = 0		xtal.atom[0].z = 0		xtal.atom[0].Zatom = 1					// Z of the atom		xtal.atom[0].name = "H1"		xtal.atom[0].occ = 1	endif	return 0EndFunction densityOfCrystalStructure(xtal)				// returns the density (g/cm^3)	STRUCT crystalStructure &xtal						// this sruct is filled  by this routine	Variable NA=6.02214199e23						// Avagadro's number	String amuList										// atomic mass of all of the elements	amuList   = "1.00794;4.002602;6.941;9.012182;10.811;12.0107;14.0067;15.9994;18.9984032;20.1797;22.98977;24.305;"	amuList += "26.981538;28.0855;30.973761;32.065;35.453;39.948;39.0983;40.078;44.95591;47.867;50.9415;51.9961;"	amuList += "54.938049;55.845;58.9332;58.6934;63.546;65.409;69.723;72.64;74.9216;78.96;79.904;83.798;85.4678;87.62;"	amuList += "88.90585;91.224;92.90638;95.94;98;101.07;102.9055;106.42;107.8682;112.411;114.818;118.71;121.76;"	amuList += "127.6;126.90447;131.293;132.90545;137.327;138.9055;140.116;140.90765;144.24;145;150.36;151.964;157.25;"	amuList += "158.92534;162.5;164.93032;167.259;168.93421;173.04;174.967;178.49;180.9479;183.84;186.207;190.23;"	amuList += "192.217;195.078;196.96655;200.59;204.3833;207.2;208.98038;209;210;222;223;226;227;232.0381;231.03588;"	amuList += "238.02891;237;244;243;247;247;251;252;257;258;259;262;261;262;266;264;277;268" 	String name	Variable amu											// atomic mass of all atoms in cell	reMakeAtomXYZs(xtal)	Variable m, N=xtal.N	for (m=0,amu=0; m<N; m+=1)						// for each atom type		name="root:Packages:Lattices:atom"+num2istr(m)		Wave ww = $name		amu += str2num(StringFromList(xtal.atom[m].Zatom-1,amuList))*DimSize(ww,0) * xtal.atom[m].occ	endfor	return (amu/NA)/(xtal.Vc * 1e-21)				// grams / cm^3EndFunction get_dhkl(h,k,l,[T])	Variable h,k,l	Variable T										// Temperature, only used if 	STRUCT crystalStructure xtal	if (FillCrystalStructDefault(xtal))				//fill the lattice structure with test values		DoAlert 0, "no lattice structure found"		return NaN	endif	Variable alphaTbad = !(abs(xtal.alphaT)<0.1)	// if  |alphaT| > 0.1 then it must be wrong	if (numtype(h+k+l))		h = numtype(h) ? 0 : h		k = numtype(k) ? 0 : k		l = numtype(l) ? 2 : l		Prompt h,"H"		Prompt k,"K"		Prompt l,"L"		Prompt T,"Temperature, standard is 22.5, (C)"		Variable askForT = (!ParamIsDefault(T) && !alphaTbad)		if (askForT)			DoPrompt "(hkl)",h,k,l,T		else			DoPrompt "(hkl)",h,k,l		endif		if (V_flag)			return NaN		endif	endif	if (numtype(h+k+l))		return NaN	endif	Variable d, usingT = !alphaTbad && numtype(T)==0	if (usingT)											// both alphaT and T are valid		d = dSpacing(xtal,h,k,l,T=T)	else		d = dSpacing(xtal,h,k,l)	endif	if (ItemsInList(GetRTStackInfo(0))<2)		Variable places = placesOfPrecision(xtal.a)		if (usingT)										// both alphaT and T are valid			printf "d['%s' (T=%g),  (%s)] = %.9g nm\r",xtal.desc,T,hkl2str(h,k,l),roundSignificant(d,places)		else			printf "d['%s',  (%s)] = %.9g nm\r",xtal.desc,hkl2str(h,k,l),roundSignificant(d,places)		endif	endif	return dEnd//ThreadSafe Function dSpacing(xtal,h,k,l,[T])		// returns d-spacing for the hkl (nm)	STRUCT crystalStructure &xtal		// this sruct is set in this routine	Variable h,k,l	Variable T	Variable xx,yy,zz	xx = h*xtal.as0 + k*xtal.bs0 + l*xtal.cs0	yy = h*xtal.as1 + k*xtal.bs1 + l*xtal.cs1	zz = h*xtal.as2 + k*xtal.bs2 + l*xtal.cs2	Variable d = 2*PI/sqrt(xx*xx + yy*yy + zz*zz)	if (abs(xtal.alphaT)<0.1 && !ParamIsDefault(T))	// do if T passed, and valid alphaT		T = limit(T,-273.15,Inf)				// limit T to > absolute zero		d = d*(1+xtal.alphaT*(T-22.5))		// apply temperature correction	endif	return dEnd// returns d-spacing (nm) given (hkl) and lattice constants, just a local utilityFunction dSpacingFromLatticeConstants(h,k,l,a,b,c,alpha,bet,gam)	Variable h,k,l	Variable a,b,c,alpha,bet,gam							// lattice constants, lengths in nm angles in degrees	STRUCT crystalStructure xtal						// this sruct is only used locally	xtal.a = a			;	xtal.b = b		;	xtal.c = c	// put values into structure	xtal.alpha = alpha	;	xtal.beta = bet	;	xtal.gam = gam	xtal.SpaceGroup=1	ForceLatticeToStructure(xtal)	Variable k0,k1,k2, d					// 	k =  {k0,k1,k2} = h*as + k*bs + l*cs	k0 = h*xtal.as0 + k*xtal.bs0 + l*xtal.cs0	k1 = h*xtal.as1 + k*xtal.bs1 + l*xtal.cs1	k2 = h*xtal.as2 + k*xtal.bs2 + l*xtal.cs2	d = 2*PI/sqrt(k0*k0 + k1*k1 + k2*k2)	// d = 2*pi/|k|	return dEndFunction hkl2Q(h,k,l, qvec,[normal])				// compute qvector for (h,k,l), returns |Q|	Variable h,k,l	Wave qvec	Variable normal									// TRUE -> normalize Q, but always return full length	normal = ParamIsDefault(normal) ? 0 : normal	if (numtype(h+k+l) || !WaveExists(qvec))		if (WaveExists(qvec))			qvec = NaN		endif		return NaN	endif	STRUCT crystalStructure xtal	if (FillCrystalStructDefault(xtal))				//fill the lattice structure with current values		DoAlert 0, "No Lattice, please set one"		return 1	endif	qvec[0] = h*xtal.as0+k*xtal.bs0+l*xtal.cs0	// qvec =  recip x hkl	qvec[1] = h*xtal.as1+k*xtal.bs1+l*xtal.cs1	qvec[2] = h*xtal.as2+k*xtal.bs2+l*xtal.cs2	Variable Qlen = norm(qvec)	if (normal)		qvec /= Qlen	endif	return QlenEndFunction angleBetweenHKLs(h1,k1,l1,  h2,k2,l2)		// find angle between (h1,k1,l1) and (h2,k2,l2)	Variable h1,k1,l1,h2,k2,l2	if (numtype(h1+k1+l1+h2+k2+l2) && ItemsInList(GetRTStackInfo(0))<2 )		h1 = numtype(h1) ? 0 : h1		k1 = numtype(k1) ? 0 : k1		l1 = numtype(l1) ? 2 : l1		h2 = numtype(h2) ? 1 : h2		k2 = numtype(k2) ? 1 : k2		l2= numtype(l2) ? 1 : l2		String hklStr1, hklStr2		sprintf hklStr1,"%g %g %g",h1,k1,l1		sprintf hklStr2,"%g %g %g",h2,k2,l2		Prompt hklStr1,"(hkl) of the first Q"		Prompt hklStr2,"(hkl) of the second Q"		DoPrompt "hkl max & font size",hklStr1,hklStr2		if (V_flag)			return 1		endif		sscanf hklStr1, "%g %g %g",h1,k1,l1		sscanf hklStr2, "%g %g %g",h2,k2,l2	endif	STRUCT crystalStructure xtal	if (FillCrystalStructDefault(xtal))					//fill the lattice structure with current values		DoAlert 0, "No Lattice, please set one"		return 1	endif	Make/N=3/O/D hkl_angleBetweenHKLs1, hkl_angleBetweenHKLs2	Wave q1=hkl_angleBetweenHKLs1, q2=hkl_angleBetweenHKLs2	q1[0] = h1*xtal.as0+k1*xtal.bs0+l1*xtal.cs0		// q1 =  recip x hkl1	q1[1] = h1*xtal.as1+k1*xtal.bs1+l1*xtal.cs1	q1[2] = h1*xtal.as2+k1*xtal.bs2+l1*xtal.cs2	q2[0] = h2*xtal.as0+k2*xtal.bs0+l2*xtal.cs0		// q2 =  recip x hkl2	q2[1] = h2*xtal.as1+k2*xtal.bs1+l2*xtal.cs1	q2[2] = h2*xtal.as2+k2*xtal.bs2+l2*xtal.cs2	normalize(q1)	normalize(q2)	Variable angle = acos(limit(MatrixDot(q1,q2),-1,1))	angle *= 180/PI	KillWaves hkl_angleBetweenHKLs1, hkl_angleBetweenHKLs2	if (ItemsInList(GetRTStackInfo(0))<2)		printf "angle between (%s) and (%s) is %g¡\r",hkl2str(h1,k1,l1),hkl2str(h2,k2,l2),angle	endif	return angleEndFunction/T findClosestHKL(dIN,[tolerance,usingQ])	Variable dIN									// desired d(nm),   or perhaps Q(1/nm),  see usingQ	Variable usingQ									// if true, then dIN is actually Q (1/nm)	Variable tolerance								// optional tolerance used for more output	dIN = numtype(dIN) ? NaN : dIN	usingQ = ParamIsDefault(usingQ) ? 0 : usingQ	usingQ = numtype(usingQ) ? 0 : usingQ	tolerance = ParamIsDefault(tolerance) ? 0.0002 : tolerance	tolerance = (numtype(tolerance) || tolerance<=0) ? 0.0002 : tolerance	STRUCT crystalStructure xtal	if (FillCrystalStructDefault(xtal))				//fill the lattice structure with test values		DoAlert 0, "ERROR findClosestHKL()\rno lattice structure found"		return ""	endif	Variable printIt = strlen(GetRTStackInfo(2))<1 || !ParamIsDefault(tolerance)	if (!(dIN>0))									// ask if not enough info or too much		Prompt usingQ,"d-spacing or Q",popup,"d (nm);Q (1/nm)"		Prompt dIN,"known d-spacing (nm)  or Q (1/nm)"		Prompt tolerance,"tolerance for checking d-spacings"		usingQ += 1		DoPrompt "d-spacing",dIN, usingQ,tolerance		if (V_flag)			return ""		endif		usingQ -= 1		dIN = usingQ ? 2*PI/dIN : dIN				// if user supplied Q, then convert to d		printIt = 1	elseif (usingQ)		dIN = 2*PI/dIN								// if user supplied Q, then convert to d	endif	if (!(dIN>0) || !(tolerance>0))		DoAlert 0, "ERROR findClosestHKL()\rinvalid d-spacing"		return ""									// invalid d-spacing	endif	Variable hmax = ceil(dSpacing(xtal,1,0,0)/dIN) + 1	Variable kmax = ceil(dSpacing(xtal,0,1,0)/dIN) + 1	Variable lmax = ceil(dSpacing(xtal,0,0,1)/dIN) + 1	Variable Nalloc=100, Nsaved=0	Make/N=(Nalloc,6)/FREE/D saved=NaN	Variable/C Fhkl	Variable h,k,l, dhkl, derr, err0=Inf	for (l=0;l<=lmax;l=incrementIndex(l))		for (k=0;k<=kmax;k=incrementIndex(k))			for (h=0;h<=hmax;h=incrementIndex(h))				Fhkl = Fstruct(xtal,h,k,l)				if (magsqr(Fhkl)<1 && numtype(real(Fhkl))==0)	// only consider allowed hkl (if invalid, use it)					continue				endif				dhkl = dSpacing(xtal,h,k,l)				derr = abs(dhkl-dIN)				if (printIt && derr<tolerance)					printf "d(%s) = %g nm,  Q = %g (1/nm),  F = %g + i %g,  |F| = %g\r",hkl2str(h,k,l),dhkl,2*PI/dhkl,real(Fhkl),imag(Fhkl),cabs(Fhkl)				endif				if (derr<err0)							// found a new best one					err0 = derr					saved = NaN					Nsaved = 0				endif				if (derr<=err0)						// a duplicate best one					if (Nsaved>=Nalloc)						Nalloc += 100						Redimension/N=(Nalloc,-1) saved					endif					saved[Nsaved][0] = h	;	saved[Nsaved][1] = k	;	saved[Nsaved][2] = l					saved[Nsaved][3] = dhkl					saved[Nsaved][4] = real(Fhkl)	;	saved[Nsaved][5] = imag(Fhkl)					Nsaved += 1				endif			endfor		endfor	endfor	if (Nsaved<1)		DoAlert 0, "ERROR findClosestHKL()\rNothing found?"		return ""	endif	Redimension/N=(Nsaved,-1) saved	Make/N=3/D/FREE hklj,hkli	String str,list=""	Variable i,j	for (j=0;j<(Nsaved-1);j+=1)		hklj = saved[j][p]		sprintf str, "%g,%g,%g,%g,%g,%g;",saved[j][0],saved[j][1],saved[j][2],saved[j][3],saved[j][4],saved[j][5]		list += str		for (i=j+1;i<Nsaved;i+=1)			hkli = -saved[i][p]			MatrixOp/FREE/O dij = sum(abs(hklj-hkli))			if (dij[0] < 0.1)				DeletePoints/M=0 i, 1, saved				i -= 1				Nsaved -= 1			endif		endfor	endfor	if (printIt)		Variable d0=saved[0][3], Fmag=sqrt(saved[0][4]^2+saved[0][5]^2)		print " "		printf "Closest reflection to  %g nm  is (1 of %d):\r",dIN,Nsaved		printf "d(%s) = %g nm,  Q = %g (1/nm),  F = %g + i %g,  |F| = %g\r",hkl2str(saved[0][0],saved[0][1],saved[0][2]),d0,2*PI/d0,saved[0][4],saved[0][5],Fmag	endif	return listEnd//Static Function incrementIndex(i)						// this is used for looping symmetrically over + and - indicies (see findClosestHKL for example)	Variable i	if (i==0)			// for i==0, increment		return 1	elseif (i>0)		return -i		// for i>0, make negative	else		return 1-i		// for i<0, increment and make positive	endifEndFunction FillCrystalStructDefault(xtal)					//fill the crystal structure with 'current' values	STRUCT crystalStructure &xtal						// returns 0 if something set, 1 is nothing done	String strStruct=StrVarOrDefault(":crystalStructStr","")// set to values in current directory	if (strlen(strStruct)<1)		strStruct=StrVarOrDefault("root:Packages:Lattices:crystalStructStr","")	// try the values in Packages	endif	if (strlen(strStruct)>1)							// found structure information, load into xtal		StructGet/S/B=2 xtal, strStruct	else													// last chance, load from generic defaults		LoadPackagePreferences/MIS=1 "LatticeSym","LatticeSymPrefs",1,xtal		if (V_flag)			return 1									// did nothing, nothing found, give up		endif		StructPut/S/B=2 xtal, strStruct				// keep a local copy after loading from PackagePreferences		String/G root:Packages:Lattices:crystalStructStr = strStruct	endif	setDirectRecip(xtal)								// ensure that these are set	return 0EndFunction UpdateCrystalStructureDefaults(xtal)	STRUCT crystalStructure &xtal						// returns 0 if something set, 1 is nothing done	String strStruct	xtal.hashID = ""										// re-set hash function to identify associated waves	StructPut/S xtal, strStruct	xtal.hashID = hash(strStruct,1)	Wave atom0 = root:Packages:Lattices:atom0	if (WaveExists(atom0))//		String wnote=StringByKey("ID",note(atom0),"=")		String wnote=note(atom0)		if (!stringmatch(StringByKey("ID",wnote,"="),xtal.hashID))			Note/K atom0, ReplaceStringByKey("ID",wnote,"","=")		endif	endif	// save as defaults for future use	StructPut/S/B=2 xtal, strStruct					// string to write to globals	String/G root:Packages:Lattices:crystalStructStr=strStruct	// always save in the Packages	if (!stringmatch(GetDataFolder(1),"root:"))		// don't save in root dataFolder		String/G :crystalStructStr=strStruct			// usually save in local data folder too	endif	SavePackagePreferences/FLSH=1 "LatticeSym","LatticeSymPrefs",1,xtal	return 0//	if (exists(":crystalStructStr")==2)				// use the global in this data folder//		SVAR crystalStructStr=:crystalStructStr//		crystalStructStr = strStruct//	elseif (exists("root:crystalStructStr")==2)			// global exists in root//		SVAR crystalStructStr=root:crystalStructStr	// update global in root//		crystalStructStr = strStruct//	else	//		String/G root:Packages:Lattices:crystalStructStr=strStruct	// neither exist, make global in Packages//	endifEnd//	DEPRECATED	DEPRECATED	DEPRECATED	DEPRECATED// The following TWO routines are DEPRECATED, USE THE SET LATTICE PANEL.  It is ONLY called by setLattice()//// THIS ROUTINE IS DEPRECATED, use the set lattice panel instead//		available from MakeLatticeParametersPanel(""),  or from the "Set Crystal Structure..." menu item//// prompts the user for lattice info, and set local structure.  Store the information in a structure string in current datafolderFunction setLattice()	String strName=""	Variable SpaceGroup									//Space Group number, from International Tables	Variable a,b,c,alpha,bet,gam	String desc	STRUCT crystalStructure xtal	xtal.a = 0	FillCrystalStructDefault(xtal)						//fill the lattice structure with default values	a = xtal.a			;	b = xtal.b		;	c = xtal.c	alpha = xtal.alpha	;	bet = xtal.beta	;	gam = xtal.gam	SpaceGroup = xtal.SpaceGroup	desc = xtal.desc	if (GetLatticeConstants(xtal,SpaceGroup,strName,a,b,c,alpha,bet,gam,desc))		return 1	endif	xtal.Unconventional00 = NaN	UpdateCrystalStructureDefaults(xtal)	return 0End// gets lattice constants for known structures via dialogs,  it uses Space Group numbers from the International Tables// known structures are://	FCC			225//	BCC			229//	Diamond		227//	Perovskite		221//	Simple Cubic	195//	Hexagonal		194//	Sapphire		167//	Triclinic		1////	DEPRECATED	DEPRECATED	DEPRECATED	DEPRECATED// THIS ROUTINE IS DEPRECATED, use the set lattice panel instead.  This is ONLY called by setLattice()Static Function GetLatticeConstants(xtal,SpaceGroup,structureName,a,b,c,alpha,bet,gam,desc)	STRUCT crystalStructure &xtal						// this sruct is set in this routine	Variable SpaceGroup								// same as for Internationl tables	String structureName								// see structures below for list of valid names	Variable a,b,c,alpha,bet,gam						// lattice constants, lengths in nm angles in degrees	String desc											// description of lattice (i.e. the name)	a = numtype(a)||a<=0 ? 0.405 : a					// default is aluminum	b = numtype(b)||b<=0 ? a : b	c = numtype(c)||c<=0 ? a : c	alpha = numtype(alpha)||alpha<=0 ? 90 : alpha	// for invalid angles, use 90¡	bet = numtype(bet)||bet<=0 ? 90 : bet	gam = numtype(gam)||gam<=0 ? 90 : gam	//	Cubic			[195,230]	//	a	//	Hexagonal		[168,194]	//	a,c	//	Trigonal		[143,167]	//	a,alpha	//	Tetragonal		[75,142]		//	a,c	//	Orthorhombic	[16,74]		//	a,b,c	//	Monoclinic		[3,15]			//	a,b,c,gamma	//	Triclinic		[1,2]			//	a,b,c,alpha,beta,gamma//	String item="",structures="FCC:225;BCC:229;Diamond:227;Perovskite:221;Simple Cubic:195;Hexagonal:194;Wurtzite (B4):186;Sapphire:167;Triclinic:1;Space Group #..."	String item="",structures="FCC:225;BCC:229;Diamond:227;Perovskite:221;Simple Cubic:195;Hexagonal:194;Wurtzite (B4):186;Sapphire:167;Triclinic:1;Space Group #..."	if (strlen(xtal.desc)>0 && xtal.SpaceGroup==SpaceGroup)		structures = xtal.desc+":"+num2istr(SpaceGroup)+";"+structures	endif	Variable i,N=ItemsInList(structures)	if (SpaceGroup>=1 && SpaceGroup<=230)			// valid SpaceGroup number		structureName = ""		for(i=0;i<N;i+=1)			item = StringFromList(i,structures)			if (SpaceGroup==str2num(StringFromList(1,item,":")))				structureName = StringFromList(0,item,":")			endif		endfor		if (strlen(structureName)<1)			DoAlert 0, "unknown structure number "+num2str(SpaceGroup)		endif	endif	if (strlen(structureName)>1)						// a structureName passed		SpaceGroup = -1		for(i=0;i<N;i+=1)			item = StringFromList(i,structures)			if (stringmatch(structureName,StringFromList(0,item,":")))				SpaceGroup = str2num(StringFromList(1,item,":"))			endif		endfor		if (SpaceGroup<1)			DoAlert 0, "unknown structure name '"+structureName+"'"		endif	endif	item = structureName+":"+num2istr(SpaceGroup)	Prompt item, "lattice structure", popup, structures	DoPrompt/HELP="" "lattice structure",item	if (V_flag)		return 1	endif	if (stringmatch(item,"Space Group*"))		Prompt SpaceGroup,"Space Group number from International Tables [1,230]"		DoPrompt "Space Group",SpaceGroup		if (V_flag)			return 1		endif	else		SpaceGroup=str2num(StringFromList(1,item,":"))		structureName = StringFromList(0,item,":")	endif	if (!(1<=SpaceGroup && SpaceGroup<=230))		return 1	endif	Prompt a, "a (nm)"	Prompt b, "b (nm)"	Prompt c, "c (nm)"	Prompt alpha, "alpha (¡)"	Prompt bet, "beta (¡)"	Prompt gam, "gamma (¡)"	if (SpaceGroup>=195)			// Cubic		DoPrompt/HELP="" "Cubic lattice constants",a		b=a;  c=a		alpha=90;  bet=90;  gam=90	elseif(SpaceGroup>=168)		// Hexagonal		c = (a==c) ? 3*a : c		DoPrompt/HELP="" "Hexagonal lattice constants",a,c		b = a		alpha=90;  bet=90;  gam=120	elseif(SpaceGroup>=143)		// Trigonal		if (isRhombohedral(SpaceGroup))	// rhombohedral structure			DoPrompt/HELP="" "Rhombohedral lattice constants (rhombohedral cell)",a,alpha			b=a  ;  c=a			bet=alpha;  gam=alpha		else			c = (a==c) ? 3*a : c			DoPrompt/HELP="" "Trigonal lattice constants (hexagoanl cell)",a,c			b = a			alpha=90;  bet=90;  gam=120		endif//	elseif(SpaceGroup>=143)		// Trigonal, use the hexagonal cell//		c = (a==c) ? 3*a : c//		DoPrompt/HELP="" "Trigonal lattice constants",a,c//		b = a//		alpha=90;  bet=90;  gam=120	elseif(SpaceGroup>=75)			// Tetragonal		DoPrompt/HELP="" "Tetragonal lattice constants",a,c		b = a		alpha=90;  bet=90;  gam=90	elseif(SpaceGroup>=16)			// Orthorhombic		DoPrompt/HELP="" "Orthorhombic lattice constants",a,b,c		alpha=90;  bet=90;  gam=90	elseif(SpaceGroup>=3)			// Monoclinic		DoPrompt/HELP="" "Monoclinic lattice constants",a,b,c,gam//		alpha=90;  bet=90		alpha=90;  gam=90	else								// Triclinic		DoPrompt/HELP="" "Triclinic lattice constants",a,b,c,alpha,bet,gam	endif	xtal.a = a			;	xtal.b = b		;	xtal.c = c	// put values into structure	xtal.alpha = alpha	;	xtal.beta = bet	;	xtal.gam = gam	xtal.SpaceGroup=SpaceGroup	xtal.Unconventional00=NaN	ForceLatticeToStructure(xtal)	return 0End//	End of setting particular lattice constants// =========================================================================// =========================================================================// =========================================================================// =========================================================================//	Start of lattice set panelFunction/T FillLatticeParametersPanel(strStruct,hostWin,left,top)	String strStruct									// optional passed value of xtal structure, this is used if passed	String hostWin										// name of home window	Variable left, top									// offsets from the left and top	NewDataFolder/O root:Packages:Lattices:PanelValues	// ensure that the needed data folders exist	Variable new = !(NumVarOrDefault("root:Packages:Lattices:PanelValues:SpaceGroup",-1)>0)	String/G root:Packages:Lattices:PanelValues:desc		// create, but don't fill in the values for the panel	Variable/G root:Packages:Lattices:PanelValues:SpaceGroup	Variable/G root:Packages:Lattices:PanelValues:a	Variable/G root:Packages:Lattices:PanelValues:b	Variable/G root:Packages:Lattices:PanelValues:c	Variable/G root:Packages:Lattices:PanelValues:alpha	Variable/G root:Packages:Lattices:PanelValues:bet	Variable/G root:Packages:Lattices:PanelValues:gam	Variable/G root:Packages:Lattices:PanelValues:alphaT	Variable/G root:Packages:Lattices:PanelValues:dirty	NVAR SpaceGroup=root:Packages:Lattices:PanelValues:SpaceGroup	SVAR desc=root:Packages:Lattices:PanelValues:desc	NVAR a=root:Packages:Lattices:PanelValues:a	NVAR b=root:Packages:Lattices:PanelValues:b	NVAR c=root:Packages:Lattices:PanelValues:c	NVAR alpha=root:Packages:Lattices:PanelValues:alpha	NVAR bet=root:Packages:Lattices:PanelValues:bet	NVAR gam=root:Packages:Lattices:PanelValues:gam	NVAR alphaT=root:Packages:Lattices:PanelValues:alphaT	NVAR dirty=root:Packages:Lattices:PanelValues:dirty	Variable/G root:Packages:Lattices:PanelValues:h	Variable/G root:Packages:Lattices:PanelValues:k	Variable/G root:Packages:Lattices:PanelValues:l	Variable/G root:Packages:Lattices:PanelValues:dspace_nm	Variable/G root:Packages:Lattices:PanelValues:Fr	Variable/G root:Packages:Lattices:PanelValues:Fi	String/G root:Packages:Lattices:PanelValues:crystalStructStr	SVAR crystalStructStr = root:Packages:Lattices:PanelValues:crystalStructStr	STRUCT crystalStructure xtal	if (strlen(strStruct))								// start using the passed values		StructGet/S/B=2 xtal, strStruct				// found passed structure information, load into xtal		dirty = 1		crystalStructStr = strStruct	elseif(new)											// no old values present, use usual defaults		FillCrystalStructDefault(xtal)		a=xtal.a  ;  b=xtal.b  ;  c=xtal.c		alpha=xtal.alpha  ;  bet=xtal.beta  ;  gam=xtal.gam		SpaceGroup=xtal.SpaceGroup		alphaT=xtal.alphaT		desc=xtal.desc		dirty = 0		StructPut/S xtal, strStruct	endif	SetWindow kwTopWin,userdata(LatticePanelName)=hostWin+"#LatticePanel"	NewPanel/K=1/W=(left,top,left+221,top+433)/HOST=$hostWin	ModifyPanel frameStyle=0, frameInset=0	RenameWindow #,LatticePanel	SetVariable setDesc,pos={4,13},size={211,18},title="name"	SetVariable setDesc,help={"description of this lattice"},fSize=12,proc=LatticePanelParamProc	SetVariable setDesc,limits={-inf,inf,0},value= root:Packages:Lattices:PanelValues:desc	Button buttonFindSpaceGroup,pos={35,36},size={150,20},title="New Space Group...", proc=LatticePanelButtonProc	TitleBox structureTitle,pos={24,63},size={82,15},title="\\JC"	TitleBox structureTitle,fSize=14,frame=0,anchor= LC	SetVariable set_a_nm,pos={45,93},size={128,18},proc=LatticePanelParamProc,title="a (nm)"	SetVariable set_a_nm,fSize=12,format="%.7f"	SetVariable set_a_nm,limits={0,inf,0},value= root:Packages:Lattices:PanelValues:a	SetVariable set_b_nm,pos={45,113},size={128,18},proc=LatticePanelParamProc,title="b (nm)"	SetVariable set_b_nm,fSize=12,format="%.7f"	SetVariable set_b_nm,limits={0,inf,0},value= root:Packages:Lattices:PanelValues:b	SetVariable set_c_nm,pos={45,133},size={128,18},proc=LatticePanelParamProc,title="c (nm)"	SetVariable set_c_nm,fSize=12,format="%.7f"	SetVariable set_c_nm,limits={0,inf,0},value= root:Packages:Lattices:PanelValues:c	SetVariable set_alpha,pos={45,163},size={100,17},proc=LatticePanelParamProc,title="a°"	SetVariable set_alpha,font="Symbol",fSize=14,format="%.5f"	SetVariable set_alpha,limits={0,180,0},value= root:Packages:Lattices:PanelValues:alpha	SetVariable set_beta,pos={45,183},size={100,17},proc=LatticePanelParamProc,title="b°"	SetVariable set_beta,font="Symbol",fSize=14,format="%.5f"	SetVariable set_beta,limits={0,180,0},value= root:Packages:Lattices:PanelValues:bet	SetVariable set_gamma,pos={45,203},size={100,17},proc=LatticePanelParamProc,title="g°"	SetVariable set_gamma,font="Symbol",fSize=14,format="%.5f"	SetVariable set_gamma,limits={0,180,0},value= root:Packages:Lattices:PanelValues:gam	Button buttonLatticeSave,pos={35,233},size={150,20},proc=LatticePanelButtonProc,title="Save"	Button buttonLatticeSave,help={"Save these values as the current values"}	Button buttonLatticeRevert,pos={35,258},size={150,20},proc=LatticePanelButtonProc,title="Revert"	Button buttonLatticeRevert,help={"revert to the current default"}	Button buttonLatticeFromFile,pos={35,283},size={150,20},proc=LatticePanelButtonProc,title="Load from a file"	Button buttonLatticeFromFile,help={"Fill the values in this panel from a file"}	Button buttonPrintLattice,pos={35,308},size={150,20},proc=LatticePanelButtonProc,title="Print Lattice to History"	Button buttonPrintLattice,help={"print lattice values to the history"}	Button buttonWriteLattice,pos={35,333},size={150,20},proc=LatticePanelButtonProc,title="Write Lattice to File"	Button buttonWriteLattice,help={"write current lattice values to an xml file"}	SetVariable h_LatticeVar,pos={12,364},size={60,15},proc=LatticePanelParamProc,title="H",font="Lucida Grande",fSize=12	SetVariable h_LatticeVar,value= root:Packages:Lattices:PanelValues:h	SetVariable k_LatticeVar,pos={84,364},size={60,15},proc=LatticePanelParamProc,title="K",font="Lucida Grande",fSize=12	SetVariable k_LatticeVar,value= root:Packages:Lattices:PanelValues:k	SetVariable L_LatticeVar,pos={156,364},size={60,15},proc=LatticePanelParamProc,title="L",font="Lucida Grande",fSize=12	SetVariable L_LatticeVar,value= root:Packages:Lattices:PanelValues:l	ValDisplay d_LatticeDisp,pos={57,385},size={123,17},title="d (nm)=",font="Lucida Grande",fSize=12,format="%.7f"	ValDisplay d_LatticeDisp,limits={0,0,0},barmisc={0,1000},value=#"root:Packages:Lattices:PanelValues:dspace_nm"	ValDisplay d_LatticeDisp,help={"d-spacing (nm) calculated using the lattice"},frame=0	ValDisplay Fr_3atticeDisp,pos={20,408},size={80,17},title="F =",value= #"root:Packages:Lattices:PanelValues:Fr"	ValDisplay Fr_3atticeDisp,font="Lucida Grande",fSize=12,format="%.3f",limits={0,0,0},barmisc={0,1000}	ValDisplay Fr_3atticeDisp,help={"d-spacing (nm) calculated using the lattice"},frame=0	ValDisplay Fi_3atticeDisp,pos={104,408},size={80,17},title="+i",value= #"root:Packages:Lattices:PanelValues:Fi"	ValDisplay Fi_3atticeDisp,font="Lucida Grande",fSize=12,format="%.3f",limits={0,0,0},barmisc={0,1000}	ValDisplay Fi_3atticeDisp,help={"d-spacing (nm) calculated using the lattice"},frame=0	String subWin = GetUserData("","","LatticePanelName")	UpdatePanelLatticeConstControls(subWin,SpaceGroup)	STRUCT WMSetVariableAction sva	sva.win = subWin	sva.eventCode = 2	LatticePanelParamProc(sva)	return "#LatticePanel"End//Static Function UpdatePanelLatticeConstControls(subWin,SpaceGroup)	// update a,b,c, alpha,beta,gamm in LatticeSet Panel	String subWin	Variable SpaceGroup	SpaceGroup = round(SpaceGroup)	if (!(SpaceGroup>=1 && SpaceGroup<=230))		return 1	endif	NVAR a=root:Packages:Lattices:PanelValues:a	NVAR b=root:Packages:Lattices:PanelValues:b	NVAR c=root:Packages:Lattices:PanelValues:c	NVAR alpha=root:Packages:Lattices:PanelValues:alpha	NVAR bet=root:Packages:Lattices:PanelValues:bet	NVAR gam=root:Packages:Lattices:PanelValues:gam	String titleStr="\\JC#"+num2istr(SpaceGroup)+" "	if (SpaceGroup>=195)												// Cubic, a		SetVariable set_a_nm,noedit=0,frame=1,win=$subWin	// enable		SetVariable set_b_nm,noedit=1,frame=0,win=$subWin	// disable		SetVariable set_c_nm,noedit=1,frame=0,win=$subWin		SetVariable set_alpha,noedit=1,frame=0,win=$subWin		SetVariable set_beta,noedit=1,frame=0,win=$subWin		SetVariable set_gamma,noedit=1,frame=0,win=$subWin		b=a  ;  c=a  ;  alpha=90 ; bet=90 ; gam=90		titleStr += "Cubic"	elseif (SpaceGroup>=168)											// Hexagonal, a, c		SetVariable set_a_nm,noedit=0,frame=1,win=$subWin	// enable		SetVariable set_c_nm,noedit=0,frame=1,win=$subWin		SetVariable set_b_nm,noedit=1,frame=0,win=$subWin	// disable		SetVariable set_alpha,noedit=1,frame=0,win=$subWin		SetVariable set_beta,noedit=1,frame=0,win=$subWin		SetVariable set_gamma,noedit=1,frame=0,win=$subWin		b=a ; alpha=90 ; bet=90 ; gam=120		titleStr += "Hexagonal"	elseif (isRhombohedral(SpaceGroup) && !((abs(90-alpha)+abs(90-bet)+abs(120-gam))<1e-6))	// Rhombohedral, with rhombohedral cell		SetVariable set_a_nm,noedit=0,frame=1,win=$subWin	// enable		SetVariable set_alpha,noedit=0,frame=1,win=$subWin		SetVariable set_b_nm,noedit=1,frame=0,win=$subWin	// disable		SetVariable set_c_nm,noedit=1,frame=0,win=$subWin		SetVariable set_beta,noedit=1,frame=0,win=$subWin		SetVariable set_gamma,noedit=1,frame=0,win=$subWin		b=a  ;  c=a		bet=alpha  ;  gam=alpha		titleStr += "Rhombohedral"	elseif (SpaceGroup>=143)											// Trigonal, with hexagonal cell		SetVariable set_a_nm,noedit=0,frame=1,win=$subWin	// enable		SetVariable set_c_nm,noedit=0,frame=1,win=$subWin		SetVariable set_b_nm,noedit=1,frame=0,win=$subWin	// disable		SetVariable set_alpha,noedit=1,frame=0,win=$subWin		SetVariable set_beta,noedit=1,frame=0,win=$subWin		SetVariable set_gamma,noedit=1,frame=0,win=$subWin		b=a		alpha=90  ;  bet=90  ;  gam=120		titleStr += "Trigonal"	elseif (SpaceGroup>=75)												// Tetragonal, a, c		SetVariable set_a_nm,noedit=0,frame=1,win=$subWin	// enable		SetVariable set_c_nm,noedit=0,frame=1,win=$subWin		SetVariable set_b_nm,noedit=1,frame=0,win=$subWin	// disable		SetVariable set_alpha,noedit=1,frame=0,win=$subWin		SetVariable set_beta,noedit=1,frame=0,win=$subWin		SetVariable set_gamma,noedit=1,frame=0,win=$subWin		b=a ; alpha=90 ; bet=90 ; gam=90		titleStr += "Tetragonal"	elseif (SpaceGroup>=16)												// Orthorhombic, a, b, c		SetVariable set_a_nm,noedit=0,frame=1,win=$subWin	// enable		SetVariable set_b_nm,noedit=0,frame=1,win=$subWin		SetVariable set_c_nm,noedit=0,frame=1,win=$subWin		SetVariable set_alpha,noedit=1,frame=0,win=$subWin	// disable		SetVariable set_beta,noedit=1,frame=0,win=$subWin		SetVariable set_gamma,noedit=1,frame=0,win=$subWin		alpha=90 ; bet=90 ; gam=90		titleStr += "Orthorhombic"	elseif (SpaceGroup>=3)												// Monoclinic, a, b, c, gamma		SetVariable set_a_nm,noedit=0,frame=1,win=$subWin	// enable		SetVariable set_b_nm,noedit=0,frame=1,win=$subWin		SetVariable set_c_nm,noedit=0,frame=1,win=$subWin		SetVariable set_beta,noedit=0,frame=1,win=$subWin		SetVariable set_alpha,noedit=1,frame=0,win=$subWin	// disable		SetVariable set_gamma,noedit=1,frame=0,win=$subWin		alpha=90 ; gam=90					//	alpha=90 ; bet=90		titleStr += "Monoclinic"	else																// Triclinic, a, b, c, alpha, beta, gamma		SetVariable set_a_nm,noedit=0,frame=1,win=$subWin	// enable all		SetVariable set_b_nm,noedit=0,frame=1,win=$subWin		SetVariable set_c_nm,noedit=0,frame=1,win=$subWin		SetVariable set_alpha,noedit=0,frame=1,win=$subWin		SetVariable set_beta,noedit=0,frame=1,win=$subWin		SetVariable set_gamma,noedit=0,frame=1,win=$subWin		titleStr += "Triclinic"	endif	titleStr += "   \\F'Courier'"+getHMboth(SpaceGroup)	titleStr = minus2bar(titleStr)									// change all minuses to a bar over following character	TitleBox structureTitle,title=titleStr,win=$subWin	return 0End//Function LatticePanelParamProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	if (sva.eventCode != 2 && sva.eventCode!=1)		// NOT Enter key or mouse up		return 0	endif	NVAR dirty=root:Packages:Lattices:PanelValues:dirty	strswitch(sva.ctrlName)		case "set_a_nm":		case "set_b_nm":		case "set_c_nm":		case "set_alpha":		case "set_beta":		case "set_gamma":		case "setDesc":			dirty = 1			break	endswitch	if (!dirty)		NVAR h=root:Packages:Lattices:PanelValues:h, k=root:Packages:Lattices:PanelValues:k, l=root:Packages:Lattices:PanelValues:l		NVAR dspace_nm=root:Packages:Lattices:PanelValues:dspace_nm		NVAR Fr=root:Packages:Lattices:PanelValues:Fr, Fi=root:Packages:Lattices:PanelValues:Fi		STRUCT crystalStructure xtal		// returns 0 if something set, 1 is nothing done		FillCrystalStructDefault(xtal)		//fill the crystal structure with 'current' values		dspace_nm = dSpacing(xtal,h,k,l)		Variable/C Fc = Fstruct(xtal,h,k,l)		Fr = real(Fc)		Fi = imag(Fc)	endif	// set buttons to enable/disable, based upon 'dirty'	String subWin=sva.win	if (dirty)		Button buttonLatticeSave disable=0,fColor=(57346,65535,49151),title="Save  (Needed)",win=$subWin		Button buttonLatticeRevert disable=0,fColor=(65535,65534,49151),win=$subWin	else		Button buttonLatticeSave disable=2,fColor=(0,0,0),title="Saved",win=$subWin		Button buttonLatticeRevert disable=2,fColor=(0,0,0),win=$subWin	endif	return 0End////Static Function/S MakePopStr(sym)//	String sym//	String listN=symmtry2SG(sym,type=0,printIt=0),  str//	String popList = MoreMakePopStr(sym)//	Variable i,Nlist=ItemsINList(listN), SG////	String system, systemNames="Triclinic ;Monoclinic ;Orthorhombic;Tetragonal ;Trigonal ;Hexagonal ;Cubic  "//	String system, systemNames="Tric;Monoc;Ortho;Tetrag;Trig;Hex;C"//	for (SG=NaN,i=0; i<Nlist; i+=1)//		SG = str2num(StringFromList(i,listN))//		SG = (SG>=1 && SG<=230) ? SG : NaN//		if (numtype(SG)==0)//			system = StringFromList(latticeSystem(SG),systemNames)////			sprintf str,"%d  %s  %s  [%s];", SG,system,getFullHMSym(SG),getHallSymbol(SG)//			sprintf str,"%d  %s  %s;", SG,system,getFullHMSym(SG)//			popList += str//		endif//	endfor//	return popList//End//////Static Function/S MoreMakePopStr(sym)//	String sym//	if (strsearch(sym, "*",0)<0)//		sym += "*"//	endif////	String str,list0="", list=""//	Variable i//	for (i=0;i<ItemsInList(CommonPredefinedStructures);i+=1)//		str = StringFromList(i, CommonPredefinedStructures)//		list0 += StringFromList(0,str,":")+";"//	endfor//	list0 = ListMatch(list0, sym)////	for (i=0;i<ItemsinList(list0);i+=1)//		str = StringFromList(i,list0)//		sprintf str, "%d  %s;",NumberByKey(str,CommonPredefinedStructures),str//		list += str//	endfor	//	return list//End//Static Function SelectNewSG(find)	String find	if (strlen(find)<1)		find = StrVarOrDefault("root:Packages:Lattices:PanelValues:SpaceGroupSearch","")		Prompt find, "Space Group Search, use * for wild card"		DoPrompt "Search String", find		if (V_flag)			return NaN		endif	endif	String/G root:Packages:Lattices:PanelValues:SpaceGroupSearch=find	String str,list0="", symList=""	Variable i	for (i=0;i<ItemsInList(CommonPredefinedStructures);i+=1)		str = StringFromList(i,CommonPredefinedStructures)		list0 += StringFromList(0,str,":")+";"	endfor	list0 = ListMatch(list0, find)	for (i=0;i<ItemsinList(list0);i+=1)		str = StringFromList(i,list0)		sprintf str, "%d  %s;",NumberByKey(str,CommonPredefinedStructures),str		symList += str	endfor		String list = symmtry2SG(find,type=0,printIt=0)	String system, systemNames="Triclinic\t;Monoclinic\t;Orthorhombic;Tetragonal\t;Trigonal\t;Hexagonal\t;Cubic\t\t"	Variable SG, Nlist=ItemsInList(list)	for (SG=NaN,i=0; i<Nlist; i+=1)		SG = str2num(StringFromList(i,list))		SG = (SG>=1 && SG<=230) ? SG : NaN		if (numtype(SG)==0)			system = StringFromList(LatticeSym#latticeSystem(SG),systemNames)			//	sprintf str,"%d  %s  %s;", SG,system,getFullHMSym(SG)			sprintf str, "%d  %s  %s  [%s];", SG,system,getFullHMSym(SG),getHallSymbol(SG)			symList += str		endif	endfor	Variable N=ItemsInList(symList)	if (N<1)		return NaN	elseif (N==1)		return str2num(symList)	endif	String sym	Prompt sym,"Space Group",popup,symList	DoPrompt "Space Group",sym	if (V_flag)		return NaN	endif	return str2num(sym)EndFunction LatticePanelButtonProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	if (ba.eventCode != 2)			// not mouse up		return 0	endif	String ctrlName=ba.ctrlName	SVAR desc=root:Packages:Lattices:PanelValues:desc	NVAR SpaceGroup=root:Packages:Lattices:PanelValues:SpaceGroup	NVAR a=root:Packages:Lattices:PanelValues:a	NVAR b=root:Packages:Lattices:PanelValues:b	NVAR c=root:Packages:Lattices:PanelValues:c	NVAR alpha=root:Packages:Lattices:PanelValues:alpha	NVAR bet=root:Packages:Lattices:PanelValues:bet	NVAR gam=root:Packages:Lattices:PanelValues:gam	NVAR alphaT=root:Packages:Lattices:PanelValues:alphaT	NVAR dirty = root:Packages:Lattices:PanelValues:dirty	SVAR crystalStructStr = root:Packages:Lattices:PanelValues:crystalStructStr	STRUCT crystalStructure xtal	StructGet/S/B=2 xtal, crystalStructStr				// pre-load with current information	STRUCT WMSetVariableAction sva	sva.win = ba.win	sva.eventCode = 2	if (stringmatch(ctrlName,"buttonLatticeRevert"))		// close window, do not save numbers		FillCrystalStructDefault(xtal)						//fill the lattice structure with default values		a=xtal.a  ;  b=xtal.b  ;  c=xtal.c		alpha=xtal.alpha  ;  bet=xtal.beta  ;  gam=xtal.gam		SpaceGroup=xtal.SpaceGroup		alphaT = xtal.alphaT		desc = xtal.desc		dirty = 0//		SetVariable set_SpaceGroupSearch, userdata(oldValue)=num2istr(SpaceGroup),win=$ GetUserData("","","LatticePanelName")		UpdatePanelLatticeConstControls(ba.win,SpaceGroup)		LatticePanelParamProc(sva)		StructPut/S xtal, crystalStructStr	elseif (stringmatch(ctrlName,"buttonLatticeSave") && dirty)		xtal.a = a  ;  xtal.b = b  ;  xtal.c = c		xtal.alpha = alpha  ;  xtal.beta = bet  ;  xtal.gam = gam		xtal.SpaceGroup = SpaceGroup		xtal.alphaT = alphaT		xtal.desc = desc		ForceLatticeToStructure(xtal)		UpdateCrystalStructureDefaults(xtal)		dirty = 0		UpdatePanelLatticeConstControls(ba.win,SpaceGroup)		LatticePanelParamProc(sva)	elseif (stringmatch(ctrlName,"buttonFindSpaceGroup"))		Variable SG = SelectNewSG("")		if (numtype(SG))			return 0		endif		SpaceGroup = SG		dirty = 1		UpdatePanelLatticeConstControls(ba.win,SpaceGroup)		LatticePanelParamProc(sva)	elseif (stringmatch(ctrlName,"buttonLatticeFromFile"))		if (readCrystalStructure(xtal,"",printIt=1))			DoAlert 0,"nothing read"		endif		a=xtal.a  ;  b=xtal.b  ;  c=xtal.c		alpha=xtal.alpha  ;  bet=xtal.beta  ;  gam=xtal.gam		SpaceGroup=xtal.SpaceGroup		desc=xtal.desc		alphaT=xtal.alphaT		dirty = 1		StructPut/S xtal, crystalStructStr		UpdatePanelLatticeConstControls(ba.win,SpaceGroup)		LatticePanelParamProc(sva)	elseif (stringmatch(ctrlName,"buttonPrintLattice"))	// print shown lattice parameters to the history		xtal.a = a  ;  xtal.b = b  ;  xtal.c = c		xtal.alpha = alpha  ;  xtal.beta = bet  ;  xtal.gam = gam		xtal.SpaceGroup = SpaceGroup		xtal.desc = desc		xtal.alphaT = alphaT		ForceLatticeToStructure(xtal)		print " "		print_crystalStructure(xtal)	elseif (stringmatch(ctrlName,"buttonWriteLattice"))	// write current lattice parameters to an xml file		writeCrystalStructure2xmlFile("","")	endif	return 0End//	End of lattice set panel// =========================================================================// =========================================================================// =========================================================================// =========================================================================//	Start of reading/writing lattice paremeters to a fileFunction LoadCrystal(fname)	String fname	STRUCT crystalStructure xtal					// this sruct is filled  by this routine	readCrystalStructure(xtal,fname,printIt=1)End//Function testReadCrystal()//	STRUCT crystalStructure xtal					// this sruct is filled  by this routine//	readCrystalStructure(xtal,"")//	print_crystalStructure(xtal)//EndStatic Function readCrystalStructure_xtl(xtal,fname)	STRUCT crystalStructure &xtal					// this sruct is filled  by this routine	String fname	PathInfo materials	if (strlen(S_path)<1)							// make it if it does not exist		NewPath/Z materials, ParseFilePath(1,FunctionPath("MaterialsAreHere"),":",1,0)	endif	PathInfo materials	if (strlen(S_path)<1)							// make it if it does not exist		PathInfo Igor		NewPath/Z materials, S_path+"User Procedures:materials"	endif	String list = keyStrFromFile(fname,"CrystalStructure","materials")	if (strlen(list)<1)									// try old style		return read_cri_fileOLD(xtal,fname)	endif	Variable a,b,c,alpha,bet,gam, SpaceGroup, alphaT	sscanf StringByKey("latticeParameters",list,"="), "{ %g, %g, %g, %g, %g, %g }"  , a,b,c,alpha,bet,gam	if (V_flag!=6)		return 1	endif	SpaceGroup = str2num(StringByKey("SpaceGroup",list,"="))	if (numtype(SpaceGroup))		return 1	endif	String unit = StringByKey("lengthUnit",list,"=")	if (stringmatch(unit,"Ang*") || stringmatch(unit,"*"))		a*= 10  ;  b*= 10  ;  c*= 10	endif	alphaT = str2num(StringByKey("latticeAlphaT",list,"="))	xtal.hashID = ""	xtal.a = a  ;  xtal.b = b  ;  xtal.c = c	xtal.alpha = alpha  ;  xtal.beta = bet  ;  xtal.gam = gam	xtal.SpaceGroup = SpaceGroup	xtal.alphaT = !(alphaT>0) ? 0 : alphaT	ForceLatticeToStructure(xtal)	xtal.desc = StringByKey("structureDesc",list,"=")	if (strlen(xtal.desc)==0)		xtal.desc = StringByKey("latticeDesc",list,"=")	endif	Variable N=0	Variable i,xx,yy,zz, occ,Debye=0	String str,item	do		item = StringByKey("AtomDesctiption"+num2istr(N+1),list,"=")		sscanf item, "{%s %g %g %g %g}",str,xx,yy,zz,occ		if (V_flag!=5)			sscanf item, "{%s %g %g %g}",str,xx,yy,zz			if (V_flag!=4)				break			endif			occ = 1		endif		xtal.atom[N].name = str		xtal.atom[N].Zatom = ZfromLabel(str)		xtal.atom[N].x = xx		xtal.atom[N].y = yy		xtal.atom[N].z = zz		xtal.atom[N].occ = occ		xtal.atom[N].Debye = Debye		N += 1	while(strlen(str) && N<STRUCTURE_ATOMS_MAX-1)	xtal.N = N	xtal.Unconventional00=NaN;  xtal.Unconventional01=NaN;  xtal.Unconventional02=NaN	// transform matrix for an unconventional unit cel	xtal.Unconventional10=NaN;  xtal.Unconventional11=NaN;  xtal.Unconventional12=NaN	// default to a conventional cell	xtal.Unconventional20=NaN;  xtal.Unconventional21=NaN;  xtal.Unconventional22=NaN	str = StringByKey("Unconventional",list,"=")	if (strlen(str))										// found an $Unconventional tag		Variable u00,u10,u20, u01,u11,u21, u02,u12,u22		sscanf str,"{ {%g,%g,%g}, {%g,%g,%g}, {%g,%g,%g} }",u00,u10,u20, u01,u11,u21, u02,u12,u22		if (V_flag==9 && numtype(u00+u10+u20+u01+u11+u21+u02+u12+u22)==0)			xtal.Unconventional00 = u00;	xtal.Unconventional01 = u01;	xtal.Unconventional02 = u02			xtal.Unconventional10 = u10;	xtal.Unconventional11 = u11;	xtal.Unconventional12 = u12			xtal.Unconventional20 = u20;	xtal.Unconventional21 = u21;	xtal.Unconventional22 = u22 		endif	endif	UpdateCrystalStructureDefaults(xtal)	if (N<1)		printf "Failed to Load Crystal Structure from '%s'\r",StringByKey("keyStrFileName",list,"=")		return 1	else		printf "Loaded Crystal Structure from '%s'     using units of '%s'\r",StringByKey("keyStrFileName",list,"="),unit	endif	return 0End//Function read_cri_fileOLD(xtal,fname)	STRUCT crystalStructure &xtal					// this sruct is filled  by this routine	String fname	Variable f	Open/R/M="the .cri file"/T=".cri" f as fname	if (f==0)		return 1	endif	Variable SpaceGroup, a,b,c,alpha,bet,gam	String line	xtal.hashID = ""	FReadLine f, line	xtal.desc = ReplaceString("\r",line,"")	FReadLine f, line	SpaceGroup = str2num(line)	if (!(SpaceGroup>=1 && SpaceGroup<=230))		Close f		return 1	endif	xtal.SpaceGroup = SpaceGroup	FReadLine f, line	sscanf line, "%g %g %g  %g %g %g",a,b,c,alpha,bet,gam	if (V_flag!=6)		Close f		return 1	endif	xtal.a = a	xtal.b = b	xtal.c = c	xtal.alpha = alpha	xtal.beta = bet	xtal.gam = gam	FReadLine f, line	Variable N = str2num(line)	if (!(N>=1 && N<=STRUCTURE_ATOMS_MAX))		Close f		return 1	endif	xtal.N = N	Variable i,xx,yy,zz, occ	String str	for (i=0;i<N;i+=1)		FReadLine f, line		sscanf line, "%s %g %g %g %g",str,xx,yy,zz,occ		if (V_flag!=5)			sscanf line, "%s %g %g %g",str,xx,yy,zz			if (V_flag!=4)				Close f				return 1			endif			occ = 1		endif		xtal.atom[i].name = str		xtal.atom[i].Zatom = ZfromLabel(str)		xtal.atom[i].x = xx		xtal.atom[i].y = yy		xtal.atom[i].z = zz		xtal.atom[i].occ = occ	endfor	Close f	if (ItemsInList(GetRTStackInfo(0))<2)		printf "read structure from file  '%s'\r",S_fileName	endif	xtal.Unconventional00=NaN;  xtal.Unconventional01=NaN;  xtal.Unconventional02=NaN	// transform matrix for an unconventional unit cel	xtal.Unconventional10=NaN;  xtal.Unconventional11=NaN;  xtal.Unconventional12=NaN	// default to a conventional cell	xtal.Unconventional20=NaN;  xtal.Unconventional21=NaN;  xtal.Unconventional22=NaN	ForceLatticeToStructure(xtal)					// set recip and direct and makes lattice constants valid	UpdateCrystalStructureDefaults(xtal)	return 0End//ThreadSafe Static Function ZfromLabel(symb)	// returns Z for an atomic symbol (NOT case sensitive), used for the atomic strucure factor	String symb					// atomic symbol	String symbols = "H;He;Li;Be;B;C;N;O;F;Ne;Na;Mg;Al;Si;P;S;Cl;Ar;"	symbols += "K;Ca;Sc;Ti;V;Cr;Mn;Fe;Co;Ni;Cu;Zn;Ga;Ge;As;Se;Br;Kr;"	symbols += "Rb;Sr;Y;Zr;Nb;Mo;Tc;Ru;Rh;Pd;Ag;Cd;In;Sn;Sb;Te;I;Xe;"	symbols += "Cs;Ba;La;Ce;Pr;Nd;Pm;Sm;Eu;Gd;Tb;Dy;Ho;Er;Tm;Yb;Lu;"	symbols += "Hf;Ta;W;Re;Os;Ir;Pt;Au;Hg;Tl;Pb;Bi;Po;At;Rn;Fr;Ra;Ac;Th;Pa;U;"	symbols += "Np;Pu;Am;Cm;Bk;Cf;Es;Fm;Md;No;Lr;Rf;Db;Sg;Bh;Hs;Mt"	symb = symb[0,1]	symb[0,0] = UpperStr(symb[0,0])		// ensure first char is upper case	symb[1,1] = LowerStr(symb[1,1])		// and second character is lower	Variable c=char2num(symb[1,1])	if (c<97 || c>122)		symb = symb[0,0]	endif	Variable iz = WhichListItem(symb,symbols)+1	return ((iz>0) ? iz : NaN)End//ThreadSafe Static Function/T Z2symbol(Z)	// returns chemical symbol from atomic number Z.	Variable Z					// atomic number	String symbols = "H;He;Li;Be;B;C;N;O;F;Ne;Na;Mg;Al;Si;P;S;Cl;Ar;"	symbols += "K;Ca;Sc;Ti;V;Cr;Mn;Fe;Co;Ni;Cu;Zn;Ga;Ge;As;Se;Br;Kr;"	symbols += "Rb;Sr;Y;Zr;Nb;Mo;Tc;Ru;Rh;Pd;Ag;Cd;In;Sn;Sb;Te;I;Xe;"	symbols += "Cs;Ba;La;Ce;Pr;Nd;Pm;Sm;Eu;Gd;Tb;Dy;Ho;Er;Tm;Yb;Lu;"	symbols += "Hf;Ta;W;Re;Os;Ir;Pt;Au;Hg;Tl;Pb;Bi;Po;At;Rn;Fr;Ra;Ac;Th;Pa;U;"	symbols += "Np;Pu;Am;Cm;Bk;Cf;Es;Fm;Md;No;Lr;Rf;Db;Sg;Bh;Hs;Mt;Ds;Rg;Cn;"	Variable Zmax=itemsInList(symbols)	if (!(Z>=1 && Z<=Zmax))		return ""	endif	return StringFromLIst(Z-1,symbols)End////Function testRead()//	STRUCT crystalStructure xtal					// this sruct is filled  by this routine//	read_cri_fileOLD(xtal,"")//	print_crystalStructure(xtal)//End//	Al2O3 crystal (hexagonal axis)//	   167//	   0.47580   0.47580   1.2991  90.00000  90.00000 120.00000//	     2//	Al001    0.00000   0.00000   0.35230   1.00000//	O0001    0.30640   0.00000   0.25000   1.00000////Function ReadLatticeFromKeyFile(fileName,path,xtal)	// read in the geometry structure from a keyword file//	String fileName										// full path name to the file//	String path											// name of an Igor path to use//	STRUCT crystalStructure &xtal						// the structure to fill from the file////	Variable tempPath = 0//	if (strlen(path)<1)//		path = "userMaterials"//		PathInfo userMaterials//		if (V_flag)//		else//			PathInfo Igor//			NewPath/Z/Q userMaterials,S_path+"User Procedures:materials:"//			tempPath = !V_flag//			if (V_flag)//				path = "home"							// no materials folder, just look in home//			endif//		endif//	endif//	String list = keyStrFromFile(fileName,"LatticeFile",path)// read in all of the tagged values into a keyword list//	if (strlen(list)<1)//		return 1//	endif//	if (tempPath)//		KillPath/Z $path//	endif////	Variable a,b,c,alpha,beta,gam, SpaceGroup, alphaT//	sscanf StringByKey("latticeParameters",list,"="), "{ %g, %g, %g, %g, %g, %g }"  , a,b,c,alpha,beta,gam//	if (V_flag!=6)//		return 1//	endif//	SpaceGroup = str2num(StringByKey("SpaceGroup",list,"="))//	if (numtype(SpaceGroup))//		return 1//	endif//	String unit = StringByKey("lengthUnit",list,"=")//	if (stringmatch(unit,"Ang*"))//		a*= 10  ;  b*= 10  ;  c*= 10//	endif//	alphaT = str2num(StringByKey("latticeAlphaT",list,"="))////	xtal.a = a  ;  xtal.b = b  ;  xtal.c = c//	xtal.alpha = alpha  ;  xtal.beta = beta  ;  xtal.gam = gam//	xtal.SpaceGroup = SpaceGroup//	xtal.desc = StringByKey("latticeDesc",list,"=")////	xtal.alphaT = !(alphaT>0) ? 0 : alphaT//	xtal.alphaT = !(abs(alphaT)<0.1) ? 0 : alphaT	// alphaT can be negative, but it must be small//	ForceLatticeToStructure(xtal)//	printf "Loaded lattice information from '%s'     using units of '%s'\r",StringByKey("keyStrFileName",list,"="),unit//	return 0//EndStatic Function/S keyStrFromFile(fname,ftype,path)	// read in all of the tagged values from a file into a keyword list	String fname									// full path name to file with tagged geometry values	String ftype									// the required file identifier, included as a tag (ftype is optional)	String path									// name of Igor path	Variable refNum	String fullName=""	PathInfo/S materials	GetFileFolderInfo/P=$path/Q/Z fname	fullName = S_Path	if (!V_isFile)		Open/D/M="file with a lattice keyword list"/P=$path/R/T=".xtl" refNum as fname		fullName = S_fileName	endif	if (strlen(fullName)<1)		return ""	else		Open/P=$path/R/Z=1 refNum as fullName		fullName = S_fileName	endif	if (strlen(fullName)<1 || !refNum)		return ""	endif// the above 12 lines should not be necessary, the /Z=2 switch does not work right	String tagStr,valStr,line	if (strlen(ftype))							// an ftype is present, so check the file		FReadLine refNum, line		extractTagValueFromLine(line,tagStr,valStr)	// check both ways		if (!stringmatch(tagStr,ftype) && !(stringmatch(tagStr,"filetype") && stringmatch(valStr,ftype)))			printf "The file must start with '%s', but the first line is '%s'\r",ftype,line			Close refNum			return ""		endif	endif	String list = ReplaceStringByKey("keyStrFileName","",fullName,"=")	Variable i,dollar = char2num("$")	do		FReadLine refNum, line		extractTagValueFromLine(line,tagStr,valStr)		if (strlen(tagStr))			// check if tag is already in list, only take the first instance of a tag, not the last			if (keyInList(tagStr,list,"=",""))	// check if this key is already in list				continue			endif			list = ReplaceStringByKey(tagStr,list,valStr,"=")		endif	while (strlen(line))							// go until EOF	Close refNum	return listEnd//Static Function extractTagValueFromLine(line,tagStr,valStr)	String line										// input line, presumably starting with a %tag	String &tagStr								// returned	String &valStr								// returned	tagStr = ""										// init both to empty	valStr = ""	if (char2num(line)!=char2num("$"))		// if it does not starts with a $, do not process		return 0	endif	Variable i = strsearch(line,"//",0)			// strip off comments	if (i>=0)		line = line[0,i-1]	endif	for (i=0;char2num(line[i+1])>32;i+=1)	// find end of tag, it ends with a space or lower	endfor	tagStr = ReplaceString(";",line[1,i],":")	tagStr = ReplaceString("=",tagStr,"_")	if (strlen(tagStr)<1)		return 1	endif	for (i=i+1;char2num(line[i])<=32;i+=1)	// find first non-white space	endfor	valStr = line[i,Inf]							// value associated with tagStr	for (i=strlen(valStr)-1;char2num(valStr[i])<=32 && i>0;i-=1)	// strip off trailing whitespace	endfor	valStr = ReplaceString(";",valStr[0,i],":")	valStr = ReplaceString("=",valStr,"_")	return 1End//	End of of reading/writing lattice paremeters to a file// =========================================================================// =========================================================================//  ========================================================================= ////  ======================== Start of reading/writing xml files ========================  //Function writeCrystalStructure2xmlFile(path,fname)	// writes the current xtal to an xml file	String path									// path to write to	String fname								// name of file to write	STRUCT crystalStructure xtal				// this sructure is written in this routine	FillCrystalStructDefault(xtal)	ForceLatticeToStructure(xtal)	String cif =  crystalStructure2xml(xtal)	// convert xtal to cif	Variable f	Open/C="R*ch"/F="XML Files (*.xml):.xml;"/M="file to write"/P=$path/Z=2 f as fname	if (V_flag==0)		fprintf f,  "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>"+NL+NL		FBinWrite f, cif		Close f	endif	return V_flagEndFunction readCrystalStructure(xtal,fname,[printIt])	STRUCT crystalStructure &xtal					// this sruct is filled  by this routine	String fname	Variable printit	printit = ParamIsDefault(printit) ? 0 : printit	fname = FindMaterialsFile(fname)				// find full path to fname, and optionally set materials path//	PathInfo materials//	if (strlen(S_path)<1)							// make it if it does not exist//		NewPath/Z materials, ParseFilePath(1,FunctionPath("MaterialsAreHere"),":",1,0)//	endif//	PathInfo materials//	if (strlen(S_path)<1)							// make it if it does not exist//		PathInfo Igor//		NewPath/Z materials, S_path+"User Procedures:materials"//	endif//	String fileFilters = "XML Files (*.xml):.xml;XTL Files (*.xtl):.xtl;old cri Files (*.cri):.cri;All Files:.*;"//	Variable f//	Open/D=2/R/F=fileFilters/M="File with Crystal Information"/P=materials f as fname//	fname = S_fileName//	if (strlen(fname)==0)//		return 1//	endif	// get extension, and extension to choose the appropriate read crystal function	String extension = ParseFilePath(4,fname,":",0,0)	Variable err=1	if (stringmatch(extension,"xml"))		err = readCrystalStructureXML(xtal,fname)	elseif (stringmatch(extension,"xtl"))		err = readCrystalStructure_xtl(xtal,fname)	endif	if (printit)		printf "\r%s xtal structure from '%s'\r\r",SelectString(err,"Loaded","ERROR -- Loading"),fname	endif	return errEnd//Static Function/S FindMaterialsFile(fname)					// returns full path to a materials file	String fname	String fileFilters = "XML Files (*.xml):.xml;XTL Files (*.xtl):.xtl;old cri Files (*.cri):.cri;All Files:.*;"	String dirString, dirList=""							// a list of possible materials directories	PathInfo materials	dirList += SelectString(V_flag,"",S_path+";")							// materials path is already set, the 1st choice	dirString = SpecialDirPath("Igor Pro User Files",0,0,0)+"materials:"	// user's local copy, 2nd choice	GetFileFolderInfo/Q/Z dirString	dirList += SelectString(WhichListItem(dirString,dirList)<0 && V_isFolder,"",dirString+";")	PathInfo Igor	dirString = SelectString(V_flag,"",S_path+"materials:;")				// system local copy, 3rd choice	GetFileFolderInfo/Q/Z dirString	dirList += SelectString(WhichListItem(dirString,dirList)<0 && V_isFolder,"",dirString+";")	dirString=ParseFilePath(1,FunctionPath("MaterialsAreHere"),":",1,0)	// the default distribution, 4th choice	dirList += SelectString(WhichListItem(dirString,dirList)<0 && strlen(dirString),"",dirString+";")	// printf "dirList =  '%s'\r",dirList	GetFileFolderInfo/Q/Z fname						// full path name passed, that was east	if (V_isfile)		return fname	endif	fname = ParseFilePath(0,fname,":",1,0)			// check for fname in each of dirList	Variable i	for (i=0;i<ItemsInList(dirList);i+=1)		dirString = StringFromList(i,dirList)		GetFileFolderInfo/Q/Z dirString+fname		if (V_isFile)									// found fname in dirString			UpdateMaterialsPath(dirString)			return dirString+fname 		endif	endfor	// could not find the materials file, time to start asking user for help	dirString = StringFromList(0,dirList)	if (itemsInList(dirList)>1)		Prompt dirString,"Folder with materials",popup,dirList		DoPrompt "Directory",dirString		if (V_flag)			return ""		endif	endif	UpdateMaterialsPath(dirString)	Variable f	Open/D=2/R/F=fileFilters/M="File with Crystal Information"/P=materials f as fname	fname = S_fileName	// printf "dirList =  '%s'\r",dirList	// printf "fname =  '%s'\r",fname	return fnameEnd//Static Function UpdateMaterialsPath(dirString)	String dirString	GetFileFolderInfo/Q/Z dirString	if (!V_isFolder)		return 1	endif	PathInfo materials	if (V_flag && stringmatch(S_path,dirString))			// nothing to change, all is OK		return 0	endif	NewPath/Z materials, dirString	return 0EndStatic Function readCrystalStructureXML(xtal,fname)	STRUCT crystalStructure &xtal						// this sruct is filled  by this routine	String fname	PathInfo materialsXML	if (strlen(S_path)<1)								// make it if it does not exist//		NewPath/Z materialsXML, ParseFilePath(1,FunctionPath("MaterialsAreHere"),":",1,0)+"xml"		NewPath/Z materialsXML, ParseFilePath(1,FunctionPath("MaterialsAreHere"),":",1,0)	endif	PathInfo materialsXML	if (strlen(S_path)<1)								// make it if it does not exist		PathInfo Igor		NewPath/Z materialsXML, S_path+"User Procedures:materials:xml"	endif	return readFileXML(xtal,fname,path="materialsXML")End//Static Function readFileXML(xtal,fileName,[path])	STRUCT crystalStructure &xtal						// this sruct is printed in this routine	String fileName	String path	if (ParamIsDefault(path))		path = "home"	endif	Variable f	String fileFilters = "XML Files (*.xml):.xml;TEXT Files (*.txt):.txt;All Files:.*;"	Open/R/F=fileFilters/M="Select xml file with Crystal Description"/P=$path/R/Z=2 f as fileName	if (strlen(S_fileName)<1 || V_flag)		return 1	endif	FStatus f	String buf=PadString("",V_logEOF,0x20)	FBinRead f, buf	Close f	buf = XMLremoveComments(buf)	Variable i0,i1	i0 = strsearch(buf,"<cif>",0,2)	if (i0<0)		return 1	endif	i0 += 5												// start just after <cif>	i1 = strsearch(buf,"</cif>",0,2)	if (i1<0)		return 1	endif	i1 -= 1												// ends just before </cif>	String cif = buf[i0,i1]	xtal.hashID = ""	xtal.desc = XMLtagContents("chemical_name_common",cif)	Variable SG = str2num(XMLtagContents("space_group_IT_number",cif))	xtal.SpaceGroup = (SG>=1 && SG<=230) ? SG : 0	String cell = XMLtagContents("cell",cif)				// cell group	String unit	xtal.a = str2num(XMLtagContents("a",cell))	unit = StringByKey("unit", XMLattibutes2KeyList("a",cell),"=")	xtal.a *= ConvertUnits2meters(unit,defaultLen=1e-10)*1e9	// want length in nm	xtal.b = str2num(XMLtagContents("b",cell))	unit = StringByKey("unit", XMLattibutes2KeyList("b",cell),"=")	xtal.b *= ConvertUnits2meters(unit,defaultLen=1e-10)*1e9	xtal.c = str2num(XMLtagContents("c",cell))	unit = StringByKey("unit", XMLattibutes2KeyList("c",cell),"=")	xtal.c *= ConvertUnits2meters(unit,defaultLen=1e-10)*1e9	xtal.alpha = str2num(XMLtagContents("alpha",cell))	xtal.beta = str2num(XMLtagContents("beta",cell))	xtal.gam = str2num(XMLtagContents("gamma",cell))	xtal.alphaT = str2num(XMLtagContents("alphaT",cell))	Variable Temperature = str2num(XMLtagContents("temperature",cell))	unit = StringByKey("unit", XMLattibutes2KeyList("temperature",cell),"=")	unit = SelectString(strlen(unit),"C",unit)						// default Temperature units are C	xtal.Temperature = ConvertTemperatureUnits(Temperature,unit,"C")	xtal.Unconventional00=NaN;  xtal.Unconventional01=NaN;  xtal.Unconventional02=NaN	// transform matrix for an unconventional unit cel	xtal.Unconventional10=NaN;  xtal.Unconventional11=NaN;  xtal.Unconventional12=NaN	// default to a conventional cell	xtal.Unconventional20=NaN;  xtal.Unconventional21=NaN;  xtal.Unconventional22=NaN	String uncoStr = XMLtagContents("Unconventional",cell)	if (strlen(uncoStr))								// found an $Unconventional tag		Variable u00,u10,u20, u01,u11,u21, u02,u12,u22		sscanf uncoStr,"{ {%g,%g,%g}, {%g,%g,%g}, {%g,%g,%g} }",u00,u10,u20, u01,u11,u21, u02,u12,u22		if (V_flag==9 && numtype(u00+u10+u20+u01+u11+u21+u02+u12+u22)==0)			xtal.Unconventional00 = u00;	xtal.Unconventional01 = u01;	xtal.Unconventional02 = u02			xtal.Unconventional10 = u10;	xtal.Unconventional11 = u11;	xtal.Unconventional12 = u12			xtal.Unconventional20 = u20;	xtal.Unconventional21 = u21;	xtal.Unconventional22 = u22 		endif	endif	// collect the atom sites	String atomSite, atomLabel, symbol	Variable Zatom, fracX,fracY,fracZ,occupy,Debye,N=0	i0 = strsearch(cif,"<atom_site",i0,2)	do		atomSite = XMLtagContents("atom_site",cif[i0,Inf])	// one atom site		Wave xyz = str2vec(XMLtagContents2List("fract_xyz",atomSite))		if (WaveExists(xyz) && numpnts(xyz)==3)			fracX = xyz[0]			fracY = xyz[1]			fracZ = xyz[2]		else			fracX = str2num(XMLtagContents("fract_x",atomSite))			fracY = str2num(XMLtagContents("fract_y",atomSite))			fracZ = str2num(XMLtagContents("fract_z",atomSite))		endif		if (numtype(fracX+fracY+fracZ))			break		endif		atomLabel = XMLtagContents("label",atomSite)		symbol = XMLtagContents("symbol",atomSite)		Zatom = ZfromLabel(symbol)		occupy = str2num(XMLtagContents("occupancy",atomSite))		occupy = (occupy>=0 && occupy<=1) ? occupy : 1		Debye = str2num(XMLtagContents("DebyeTemperature",atomSite))		Debye = Debye>0 ? Debye : 0		unit = StringByKey("unit", XMLattibutes2KeyList("DebyeTemperature",atomSite),"=")		unit = SelectString(strlen(unit),"K",unit)		// default Debye Temperature units are K		Debye = ConvertTemperatureUnits(Debye,unit,"K")	// Debye T is always stored as K		xtal.atom[N].name = atomLabel		xtal.atom[N].x = fracX		xtal.atom[N].y = fracY		xtal.atom[N].z = fracZ		xtal.atom[N].occ = occupy		xtal.atom[N].Debye = Debye		xtal.atom[N].Zatom = Zatom		i0 = strsearch(cif,"<atom_site",i0+10,2)		N += 1	while(N<STRUCTURE_ATOMS_MAX && i0>0)	xtal.N = N											// number of atoms described here	Variable Nbond=0, Nlen, i, unitsConvert	String bondKeys, label0,label1,list	i0 = strsearch(cif,"<bond_chemical",i0,2)	do		Wave blen = str2vec(XMLtagContents("bond_chemical",cif[i0,Inf]))	// bond length(s)		bondKeys = XMLattibutes2KeyList("bond_chemical",cif[i0,Inf])		label0 = StringByKey("n0",bondKeys,"=")		label1 = StringByKey("n1",bondKeys,"=")		Nlen = min(numpnts(blen),5)					// number of lengths for this bond		if (strlen(label0) && strlen(label1) && numtype(sum(blen))==0 && Nlen>0)			xtal.bond[Nbond].label0 = label0			xtal.bond[Nbond].label1 = label1			xtal.bond[Nbond].N = Nlen			unit = StringByKey("unit",bondKeys,"=")			unitsConvert = ConvertUnits2meters(unit,defaultLen=1e-10)*1e9	// want length in nm			for (i=0;i<Nlen;i+=1)				xtal.bond[Nbond].len[i] = blen[i]*unitsConvert			endfor			Nbond += 1		endif		i0 = strsearch(cif,"<bond_chemical",i0+10,2)	while(Nbond<(2*STRUCTURE_ATOMS_MAX) && i0>0)	xtal.Nbonds = Nbond	ForceLatticeToStructure(xtal)	UpdateCrystalStructureDefaults(xtal)	return 0End//Static Function ConvertUnits2meters(unit,[defaultLen])	// conversion factor from unit to meters, no default	String unit	Variable defaultLen	defaultLen = ParamIsDefault(defaultLen) ? NaN : defaultLen	unit = ReplaceString(" ",unit,"")				// no spaces	if (stringmatch(unit,"*s"))					// and no trailing 's'		unit = unit[0,strlen(unit)-2]	endif	// first handle the special cases of Angstrom or micron	if (stringmatch(unit,"Ang*") || stringmatch(unit,"*"))	// Angstroms		return 1e-10	elseif (stringmatch(unit,"micrometer") || stringmatch(unit,"micron"))			return 1e-6	endif	String prefix	Variable value=defaultLen, i = max(0,strlen(unit)-1)	if (strsearch(unit,"m",i)==i)					// ends in 'm', means meters		value = 1		prefix = unit[0,strlen(unit)-2]	elseif(stringmatch(unit,"*in") || stringmatch(unit,"*inch"))	 // a few english units just for fun		value = 25.4e-3		i = stringmatch(unit,"*inch") ? 5 : 3		prefix = unit[0,strlen(unit)-i]	elseif(stringmatch(unit,"*ft") || stringmatch(unit,"*foot") || stringmatch(unit,"*feet"))		value = 12*25.4e-3		i = stringmatch(unit,"*foot") ? 5 : 3		i = stringmatch(unit,"*feet") ? 5 : i		prefix = unit[0,strlen(unit)-i]	elseif(stringmatch(unit,"*mi") || stringmatch(unit,"*mile"))		value = 5280*12*25.4e-3		i = stringmatch(unit,"*mile") ? 5 : 3		prefix = unit[0,strlen(unit)-i]	elseif(stringmatch(unit,"*yd") || stringmatch(unit,"*yard"))		value = 3*12*25.4e-3		i = stringmatch(unit,"*yard") ? 5 : 3		prefix = unit[0,strlen(unit)-i]	elseif(stringmatch(unit,"*mil"))				// 0.001 inch		value = 25.4e-6		prefix = unit[0,strlen(unit)-4]	elseif(stringmatch(unit,"*pc") || stringmatch(unit,"*parsec"))		value = 3.08568025e16		i = stringmatch(unit,"*parsec") ? 7 : 3		prefix = unit[0,strlen(unit)-i]	elseif(stringmatch(unit,"*ly") || stringmatch(unit,"*lightYear"))		value = 9.4605284e15		i = stringmatch(unit,"*lightYear") ? 10 : 3		prefix = unit[0,strlen(unit)-i]	else		return defaultLen							// cannot find base value	endif	value *= SIprefix2factor(prefix)	return valueEndStatic Function ConvertTemperatureUnits(Tin,unitIn,unitOut)	// returns Temperature in units of (unitOut)	String unitIn, unitOut							// input and output units, NO defaults allowed	Variable Tin									// input temperature in units of (unitIn)	unitIn = ReplaceString("Kelvin",unitIn,"K")	// use single letter abreviations	unitOut = ReplaceString("Kelvin",unitOut,"K")	unitIn = ReplaceString("Celsius",unitIn,"C")	unitOut = ReplaceString("Celsius",unitOut,"C")	unitIn = ReplaceString(" ",unitIn,"")			// no spaces	unitIn = ReplaceString("¡",unitIn,"")			// no degree signs	if (stringmatch(unitIn,"*s"))					// and no trailing 's'		unitIn = unitIn[0,strlen(unitIn)-2]	endif	unitOut = ReplaceString(" ",unitOut,"")			// no spaces	unitOut = ReplaceString("¡",unitOut,"")			// no degree signs	if (stringmatch(unitOut,"*s"))					// and no trailing 's'		unitOut = unitOut[0,strlen(unitOut)-2]	endif	if (strlen(unitIn)<1 || strlen(unitOut)<1)		return NaN	endif	Variable Tout, Kelvin, factor, n	if (strlen(unitIn)>1)		n = strlen(unitIn)		Tin *= SIprefix2factor(unitIn[0,n-2])		unitIn = unitIn[n-1]					// the last character	endif	strswitch(unitIn)							// first convert Tin to Kelvin		case "F":			Kelvin = (Tin - 32) * 5/9 + 273.15			break		case "R":			Kelvin = Tin * 5/9			break		case "C":			Kelvin = Tin + 273.15			break		case "K":			Kelvin = Tin			break		default:			return NaN		endswitch	if (strlen(unitOut)>1)		n = strlen(unitOut)		factor = SIprefix2factor(unitOut[0,n-2])		unitOut = unitOut[n-1]					// the last character	else		factor = 1	endif	if (WhichListItem(unitOut,"K;C;F;R;",";",0,1)<0)		return NaN	endif	strswitch(unitOut)							// convert Kelvin to Tout		case "F":			Tout = (Kelvin-273.15)*9/5 + 32			break		case "R":			Tout = Kelvin * 9/5			break		case "C":			Tout = Kelvin - 273.15			break		case "K":			Tout = Kelvin			break		default:			return NaN		endswitch	Tout /= factor	return ToutEndStatic Function/T crystalStructure2xml(xtal)	// convert contents of xtal structure to xml sting (suitable for a file)	STRUCT crystalStructure &xtal				// this sruct is printed in this routine	String cif="<cif>"+NL	String str, unit=" unit=\"nm\""	if (strlen(xtal.desc))		cif += "\t<chemical_name_common>"+xtal.desc+"</chemical_name_common>"+NL	endif	if (numtype(xtal.SpaceGroup)==0)		cif += "\t<space_group_IT_number>"+num2istr(xtal.SpaceGroup)+"</space_group_IT_number>"+NL	endif	Variable alphaT = xtal.alphaT	alphaT = alphaT>0 ? alphaT : NaN	cif += "\t<cell>"+NL	cif += "\t\t<a"+unit+">"+num2StrFull(xtal.a)+"</a>"+NL	cif += "\t\t<b"+unit+">"+num2StrFull(xtal.b)+"</b>"+NL	cif += "\t\t<c"+unit+">"+num2StrFull(xtal.c)+"</c>"+NL	cif += "\t\t<alpha>"+num2StrFull(xtal.alpha)+"</alpha>"+NL	cif += "\t\t<beta>"+num2StrFull(xtal.beta)+"</beta>"+NL	cif += "\t\t<gamma>"+num2StrFull(xtal.gam)+"</gamma>"+NL	if (xtal.Vc > 0)		cif += "\t\t<volume>"+num2StrFull(xtal.Vc)+"</volume>"+NL	endif	if (numtype(xtal.Temperature)==0)		Variable Temperature = xtal.Temperature		String Tunits = "C"		if (Temperature<-100)						// for low Temperatures, use Kelvin			Tunits = "K"			Temperature = ConvertTemperatureUnits(Temperature,"C","K")		endif		sprintf str, "<temperature unit=\"%s\">%s</temperature>",Tunits,num2StrFull(Temperature)		cif += "\t\t"+str+NL	endif	if (numtype(alphaT)==0)		cif += "\t\t<alphaT>"+num2StrFull(alphaT)+"</alphaT>"		cif += "\t\t	<!-- a = ao*(1+alphaT*(TempC-22.5)) -->"+NL	endif	if (numtype(xtal.Unconventional00)==0)		str="{"		str += "{"+num2StrFull(xtal.Unconventional00)+","+num2StrFull(xtal.Unconventional10)+","+num2StrFull(xtal.Unconventional20)+","+"}, "		str += "{"+num2StrFull(xtal.Unconventional01)+","+num2StrFull(xtal.Unconventional11)+","+num2StrFull(xtal.Unconventional21)+","+"}, "		str += "{"+num2StrFull(xtal.Unconventional02)+","+num2StrFull(xtal.Unconventional12)+","+num2StrFull(xtal.Unconventional22)+","+"} }"		cif += "\t\t<Unconventional>"+str+"</Unconventional>"+NL		//	<Unconventional>{ {0,1,0}, {0,0,1}, {1,0,0} }</Unconventional>	endif	cif += "\t</cell>"+NL	Variable i	for(i=0; i<xtal.N; i+=1)		cif += "\t<atom_site>"+NL		cif += "\t\t<label>"+xtal.atom[i].name+"</label>"+NL		cif += "\t\t<symbol>"+Z2symbol(xtal.atom[i].Zatom)+"</symbol>"+NL//		cif += "\t\t<fract_x>"+num2StrFull(xtal.atom[i].x)+"</fract_x>"+NL//		cif += "\t\t<fract_y>"+num2StrFull(xtal.atom[i].y)+"</fract_y>"+NL//		cif += "\t\t<fract_z>"+num2StrFull(xtal.atom[i].z)+"</fract_z>"+NL		cif += "\t\t<fract_xyz>"+num2StrFull(xtal.atom[i].x)+" "+num2StrFull(xtal.atom[i].y)+" "+num2StrFull(xtal.atom[i].z)+"</fract_xyz>"+NL		if (xtal.atom[i].occ<1 && numtype(xtal.atom[i].occ)==0)			cif += "\t\t<occupancy>"+num2StrFull(xtal.atom[i].occ)+"</occupancy>"+NL		endif		if (xtal.atom[i].Debye>0)			cif += "\t\t<DebyeTemperature unit=\"K\">"+num2StrFull(xtal.atom[i].Debye)+"</DebyeTemperature>"+NL		endif		cif += "\t</atom_site>"+NL	endfor	String wStr	for(i=0; i<xtal.Nbonds; i+=1)		Make/N=(xtal.bond[i].N)/FREE/D lens		lens = xtal.bond[i].len[p]		wStr = vec2str(lens,bare=1,sep=" ")		sprintf str, "\t<bond_chemical%s n0=\"%s\" n1=\"%s\">%s</bond_chemical>",unit,xtal.bond[i].label0,xtal.bond[i].label1,wStr		cif += str+NL	endfor	cif += "</cif>"+NL	return cifEnd//  ======================== End of reading/writing xml files =========================  ////  ========================================================================= //// =========================================================================// =========================================================================//	Start of xtl --> xml conversionStatic strConstant NL="\r"// convert one xtl file to a newer xml file, also moves *.xtl file to folder "materials/old_xtl_files"Function ConverXTLfile2XMLfile(xtlName)	String xtlName	PathInfo materials	if (strlen(S_path)<1)							// make it if it does not exist		NewPath/Z materials, ParseFilePath(1,FunctionPath("MaterialsAreHere"),":",1,0)	endif	PathInfo materials	if (strlen(S_path)<1)							// make it if it does not exist		PathInfo Igor		NewPath/Z materials, S_path+"User Procedures:materials"	endif	String fileFilters = "XTL Files (*.xtl):.xtl;old cri Files (*.cri):.cri;All Files:.*;"	Variable f	Open/D=2/R/F=fileFilters/M="File with Crystal Information"/P=materials f as xtlName	xtlName = S_fileName	if (strlen(xtlName)==0)		return 1	endif	// check extension	String extension = ParseFilePath(4,xtlName,":",0,0)	if (!stringmatch(extension,"xtl"))		DoAlert 1,"This does not look like an old '*.xtl' file, stop now?"		if (V_flag!=2)			return 1		endif	endif	printf "xtlName = '%s'\r",xtlName	String cif = convertOneXTL2XML(xtlName)	if (strlen(cif)<1)		DoAlert 0,"Unable to properly interpret file '"+xtlName+"'"		return 1	endif	// wite the xml file	String xmlName = ParseFilePath(1,xtlName,":",1,0)+ParseFilePath(3,xtlName,":",0,0)+".xml"	Open/C="R*ch"/T="TEXT"/Z f as xmlName	if (V_flag==0)		fprintf f,  "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>"+NL+NL		FBinWrite f, cif		Close f		Variable err = 0	else		DoAlert 0, "UNable to write to file '"+xmlName+"'"		err = 1	endif	// move xtl file to folder "old_xtl_files",  make sure the folder "old_xtl_files" exists, then move the *.xtl file	String oldXTLpath = ParseFilePath(1,xtlName,":",1,0)+"old_xtl_files:"	NewPath/C/O/Q/Z old_xtl_files, oldXTLpath		// just use NewPath to create the folder	KillPath/Z old_xtl_files	NewPath/C/O/Q/Z original_xtl_path, ParseFilePath(1,xtlName,":",1,0)	// original path to the xtl file	String name=ParseFilePath(0,xtlName,":",1,0)	MoveFile/P=original_xtl_path name  as ":old_xtl_files:"+name			// actually move the file to the "old_xtl_files"	KillPath/Z original_xtl_path	return 0End//Static Function/T convertOneXTL2XML(xtl)		// read in the xtl file, returns string with contents for xml file	String xtl	String keyVals = keyStrFromFile(xtl,"CrystalStructure","home")	if (strlen(keyVals)<1)		return ""	endif	String sval, str, cif="<cif>"+NL	sval = StringByKey("structureDesc",keyVals,"=")	if (strlen(sval))		cif += "\t<chemical_name_common>"+sval+"</chemical_name_common>"+NL	endif	sval = StringByKey("SpaceGroup",keyVals,"=")	if (numtype(str2num(sval))==0)		cif += "\t<space_group_IT_number>"+sval+"</space_group_IT_number>"+NL	endif	String unit= StringByKey("lengthUnit",keyVals,"=")	// length unit for lattice constants a,b,c	if (strlen(unit))		unit = " unit=\""+unit+"\""	endif	Variable alphaT = NumberByKey("latticeAlphaT",keyVals,"=")	Variable temperature = numtype(alphaT) ? NaN : 22.5	// temperature (C)	if (numtype(NumberByKey("temperatureK",keyVals,"="))==0)		temperature = NumberByKey("temperatureK",keyVals,"=") - 273.15	endif	str = StringByKey("latticeParameters",keyVals,"=")	Variable a,b,c,alpha,bet,gam	sscanf str,"{%g, %g, %g, %g, %g, %g}",a,b,c,alpha,bet,gam	if (V_flag!=6)		return ""	endif	cif += "\t<cell>"+NL	cif += "\t\t<a"+unit+">"+num2StrFull(a)+"</a>"+NL	cif += "\t\t<b"+unit+">"+num2StrFull(b)+"</b>"+NL	cif += "\t\t<c"+unit+">"+num2StrFull(c)+"</c>"+NL	cif += "\t\t<alpha>"+num2StrFull(alpha)+"</alpha>"+NL	cif += "\t\t<beta>"+num2StrFull(bet)+"</beta>"+NL	cif += "\t\t<gamma>"+num2StrFull(gam)+"</gamma>"+NL	// cif += "\t\t<volume>"+num2StrFull(volume)+"</volume>"	if (numtype(temperature)==0)		cif += "\t\t<temperature unit=\"C\">"+num2StrFull(temperature)+"</temperature>"+NL	endif	if (numtype(alphaT)==0)		cif += "\t\t<alphaT>"+num2StrFull(alphaT)+"</alphaT>"		cif += "\t\t	<!-- a = ao*(1+alphaT*(TempC-"+SelectString(numtype(temperature),num2StrFull(temperature),"22.5")+")) -->"+NL	endif	str = StringByKey("Unconventional",keyVals,"=")	if (strlen(str)>0)		cif += "\t\t<Unconventional>"+str+"</Unconventional>"+NL	endif	cif += "\t</cell>"+NL	Variable DebyeTemperature = NumberByKey("DebyeTemp",keyVals,"=")	String atomLabel, symbol	Variable xFraction,yFraction,zFraction,occupancy, i=1	do		str = StringByKey("AtomDesctiption"+num2istr(i),keyVals,"=")		if (strlen(str)<1)			break		endif		str = SingleWhiteSpace(str)		sscanf str, "{%s %g %g %g %g}", atomLabel,xFraction,yFraction,zFraction,occupancy		if (V_flag<4)			break		endif		occupancy = V_flag<5 ? 1 : occupancy		cif += "\t<atom_site>"+NL		symbol = SelectString(isdigit(atomLabel[1]),atomLabel[0,1],atomLabel[0])		cif += "\t\t<label>"+atomLabel+"</label>"+NL		cif += "\t\t<symbol>"+symbol+"</symbol>"+NL//		cif += "\t\t<fract_x>"+num2StrFull(xFraction)+"</fract_x>"+NL//		cif += "\t\t<fract_y>"+num2StrFull(yFraction)+"</fract_y>"+NL//		cif += "\t\t<fract_z>"+num2StrFull(zFraction)+"</fract_z>"+NL		cif += "\t\t<fract_xyz>"+num2StrFull(xFraction)+" "+num2StrFull(yFraction)+" "+num2StrFull(zFraction)+"</fract_xyz>"+NL		if (occupancy<1)			cif += "\t\t<occupancy>"+num2StrFull(occupancy)+"</occupancy>"+NL		endif		if (DebyeTemperature>0)			cif += "\t\t<DebyeTemperature unit=\"K\">"+num2StrFull(DebyeTemperature)+"</DebyeTemperature>"+NL		endif		cif += "\t</atom_site>"+NL		i += 1	while (1)	String citation=""	str = StringByKey("citation",keyVals,"=")	if (strlen(str)>0)		citation += str + ";"	endif	str = StringByKey("citation1",keyVals,"=")	if (strlen(str)>0)		citation += str + ";"	endif	str = StringByKey("citation2",keyVals,"=")	if (strlen(str)>0)		citation += str + ";"	endif	str = StringByKey("citation3",keyVals,"=")	if (strlen(str)>0)		citation += str + ";"	endif	if (strlen(citation)>0)		cif += "\t<citation>"+citation+"</citation>"+NL	endif	// treat $remarks as comments	str = StringByKey("remarks",keyVals,"=")	if (strlen(str)>0)		cif += "\t<!-- "+str+" -->"+NL	endif	// transfer any old comment lines	GetFileFolderInfo/P=home/Q/Z xtl	Variable f	if (V_isFile)		Open/R/Z=2/P=home f as S_Path		if (V_flag==0)			String line=" "			do				FReadLine f, line				line = TrimFrontBackWhiteSpace(line)				if (strsearch(line,"//",0)==0 && strlen(line)>2)					cif += "\t<!-- "+line[2,Inf]+" -->"+NL				endif			while (strlen(line))			Close f		endif	endif	cif += "</cif>"+NL	return cifEnd//ThreadSafe Static Function/T num2StrFull(val)	Variable val	Variable i = placesOfPrecision(val)	Variable absVal = abs(val)	i = (absVal>=10 && absVal<1e6) ? max(i,1+floor(log(absVal))) : i	String str, fmt	sprintf fmt, "%%.%dg",i	sprintf str,fmt,val	return strEnd//ThreadSafe Static Function/T SingleWhiteSpace(str,[sep,chars,trim])	String str			// string to change	String sep			// separator to use	String chars		// an optional list of characters to change to white space, default is space & tab	Variable trim		// if true, trim leading or trailing sep	if (ParamIsDefault(sep))					// default separator is a single space		sep = " "	endif	if (ParamIsDefault(chars))					// default is to treat both sapce and tab as white space		chars = "\t"	endif	trim = ParamIsDefault(trim) ? 1 : trim	trim = numtype(trim) ? 1 : trim	sep = sep[0]								// sep can only contain 1 character	chars = ReplaceString(sep,chars,"")		// remove sep, since space is the default separator	Variable i,N=strlen(chars)	for (i=0;i<N;i+=1)							// replace all occurances of characters in chars with sep		str = ReplaceString(chars[i],str,sep)	endfor	do		str = ReplaceString(sep+sep,str,sep)	// replace all runs of sep with a single sep char	while(strsearch(str,sep+sep,0)>=0)	if (trim)									// trim any leading or trailing sep characters		if (stringmatch(str[0],sep))			str = str[1,Inf]						// trim a leading sep character		endif		i = strlen(str)-1		if (stringmatch(str[i],sep))			str = str[0,i-1]					// trim a trailing sep character		endif	endif	return strEnd//	End of xtl --> xml conversion// =========================================================================// =========================================================================// =========================================================================// =========================================================================//	Start of crystal symmetry stuffStatic Constant TRICLINIC=0,MONOCLINIC=1,ORTHORHOMBIC=2,TETRAGONAL=3,TRIGONAL=4,HEXAGONAL=5,CUBIC=6Static Constant P_CENTER=0,F_CENTER=1,B_CENTER=2,RHOMBOHEDRAL=3,C_CENTER=4,A_CENTER=5Static Constant FCC=225,BCC=229,DIA=227,SIMPLE_CUBIC=195,SAPPHIRE=167	// generic Space Group numbersStrconstant LatticeSystemNames="Triclinic;Monoclinic;Orthorhombic;Tetragonal;Trigonal;Hexagonal;Cubic"Function/C getFstruct(h,k,l)				// user interface to getting F for current crystal structure	Variable h,k,l	if (numtype(h+k+l))		h = numtype(h) ? 0 : h		k = numtype(k) ? 0 : k		l = numtype(l) ? 2 : l		Prompt h,"H"		Prompt k,"K"		Prompt l,"L"		DoPrompt "(hkl)",h,k,l		if (V_flag)			return cmplx(NaN,NaN)		endif		if (numtype(h+k+l))			return cmplx(NaN,NaN)		endif	endif	STRUCT crystalStructure xtal						// this sruct is filled  by this routine	FillCrystalStructDefault(xtal)	Variable/C Fc = Fstruct(xtal,h,k,l)	Variable Freal=real(Fc),Fimag=imag(Fc)	if (strlen(GetRTStackInfo(2))==0)		printf "F('%s', %d %d %d) = %g %s i%g,      |F|^2 = %g\r",xtal.desc,h,k,l,real(Fc),SelectString(imag(Fc)<0,"+","-"),abs(imag(Fc)),magsqr(Fc)	endif	return FcEndFunction/C Fstruct(xtal,h,k,l,[keV])	STRUCT crystalStructure &xtal						// this sruct is filled  by this routine	Variable h,k,l	Variable keV	keV = ParamIsDefault(keV) ? 0 : keV	Variable SpaceGroup=xtal.SpaceGroup	if (!(SpaceGroup>=1 || SpaceGroup<=230) || numtype(h+k+l))		return cmplx(NaN,NaN)	// bad inputs	endif	Variable/C zero=cmplx(0,0)	Variable usingHexAxes = (abs(90-xtal.alpha)+abs(90-xtal.beta)+abs(120-xtal.gam))<1e-6	Variable system = latticeSystem(SpaceGroup)	if (!(mod(h,1) || mod(k,1) || mod(l,1)))			// non-integral, always allowed		String sym = getHMsym(SpaceGroup)			// get symmetry symbol		strswitch (sym[0,0])			case "F":				if (!ALLOW_FC(h,k,l))					return zero				endif				break			case "I":				if (!ALLOW_BC(h,k,l))					return zero				endif				break			case "C":				if (!ALLOW_CC(h,k,l))					return zero				endif				break			case "A":				if (!ALLOW_AC(h,k,l))					return zero				endif				break			case "R":				if (usingHexAxes)					if (!ALLOW_RHOM_HEX(h,k,l))		// rhombohedral cell with hexagonal axes						return zero					endif				endif				break										// using rhombohedral axes, so all are allowed		endswitch		if (system==HEXAGONAL)			if (!ALLOW_HEXAGONAL(h,k,l)) 				return zero			endif		endif	endif	Variable useCromer = (exists("Get_f")==6)			// calculate fatom using Cromer-Liberman	if (useCromer)											// need Q vector & energy		Variable Q = 2*PI/dSpacing(xtal,h,k,l)				// |Q| vector (nm)		keV = keV>0 ? keV : NumVarOrDefault("root:Packages:Lattices:keV",0)	endif	Variable Freal=0,Fimag=0	Variable na,i	Variable  arg	Variable/C fatomC	Variable fatomMag, fatomArg=0	String name	Variable m	reMakeAtomXYZs(xtal)	if (!(xtal.N>=1))		return cmplx(1,0)	endif	for (m=0;m<xtal.N;m+=1)		name="root:Packages:Lattices:atom"+num2istr(m)		Wave ww = $name		if (useCromer)			FUNCREF Get_f_proto fa= $"Get_f"			fatomC = fa(Z2symbol(xtal.atom[m].Zatom),Q/10, keV)			fatomC = r2polar(fatomC)			fatomMag = real(fatomC) * xtal.atom[m].occ			fatomArg = imag(fatomC)		else			fatomMag = xtal.atom[m].Zatom		endif		fatomMag *= xtal.atom[m].occ		na = DimSize(ww,0)		for (i=0;i<na;i+=1)			arg = 2*PI*(h*ww[i][0]+k*ww[i][1]+l*ww[i][2]) + fatomArg			Freal += fatomMag*cos(arg)			Fimag += fatomMag*sin(arg)		endfor	endfor	if (system==HEXAGONAL || (usingHexAxes && system==TRIGONAL))		arg = 2*PI*((h+2*k)/3 + l*0.5)				// hexagonal has atoms at (0,0,0) and (1/3, 2/3, 1/2)		Variable Fr=1. + cos(arg), Fi=sin(arg)		Variable rr=Freal, ii=Fimag		Freal = rr*Fr - ii*Fi		Fimag = rr*Fi + ii*Fr		//  for hexagonal:		//	h+2k=3n,		l=even;		F = 4*f			1		//	h+2k=3n±1,	l=odd;		F = sqrt(3)*f   sqrt(3)/4		//	h+2k=3n±1,	l=even;		F = f			1/4		//	h+2k=3n,		l=odd; 		F = 0			0	endif	Freal = abs(Freal)<1e-8 ? 0 : Freal	Fimag = abs(Fimag)<1e-8 ? 0 : Fimag	return cmplx(Freal,Fimag)End//Function/C Get_f_proto(AtomType,Q, keV)	string AtomType	variable keV,Q	return 1End//Function/C Fstruct(xtal,h,k,l)//	STRUCT crystalStructure &xtal						// this sruct is filled  by this routine//	Variable h,k,l////	Variable SpaceGroup=xtal.SpaceGroup//	if (!(SpaceGroup>=1 || SpaceGroup<=230) || numtype(h+k+l))//		return cmplx(NaN,NaN)	// bad inputs//	endif//	Variable/C zero=cmplx(0,0)//	Variable usingHexAxes = (abs(90-xtal.alpha)+abs(90-xtal.beta)+abs(120-xtal.gam))<1e-6//	Variable system = latticeSystem(SpaceGroup)////	if (!(mod(h,1) || mod(k,1) || mod(l,1)))			// non-integral, always allowed//		String sym = getHMsym(SpaceGroup)			// get symmetry symbol//		strswitch (sym[0,0])//			case "F"://				if (!ALLOW_FC(h,k,l))//					return zero//				endif//				break//			case "I"://				if (!ALLOW_BC(h,k,l))//					return zero//				endif//				break//			case "C"://				if (!ALLOW_CC(h,k,l))//					return zero//				endif//				break//			case "A"://				if (!ALLOW_AC(h,k,l))//					return zero//				endif//				break//			case "R"://				if (usingHexAxes)//					if (!ALLOW_RHOM_HEX(h,k,l))		// rhombohedral cell with hexagonal axes//						return zero//					endif//				endif//				break										// using rhombohedral axes, so all are allowed//		endswitch//		if (system==HEXAGONAL)//			if (!ALLOW_HEXAGONAL(h,k,l)) //				return zero//			endif//		endif//	endif////	Variable Freal=0,Fimag=0//	Variable na,i//	Variable  arg//	Variable fatom//	String name//	Variable m//	reMakeAtomXYZs(xtal)//	if (!(xtal.N>=1))//		return cmplx(1,0)//	endif////	for (m=0;m<xtal.N;m+=1)//		name="root:Packages:Lattices:atom"+num2istr(m)//		Wave ww = $name//		fatom = xtal.atom[m].Zatom * xtal.atom[m].occ//		na = DimSize(ww,0)//		for (i=0;i<na;i+=1)//			arg = 2*PI*(h*ww[i][0]+k*ww[i][1]+l*ww[i][2])//			Freal += fatom*cos(arg)//			Fimag += fatom*sin(arg)//		endfor//	endfor////	if (system==HEXAGONAL || (usingHexAxes && system==TRIGONAL))//		arg = 2*PI*((h+2*k)/3 + l*0.5)				// heagnal has atoms at (0,0,0) and (1/3, 2/3, 1/2)//		Variable Fr=1. + cos(arg), Fi=sin(arg)//		Variable rr=Freal, ii=Fimag//		Freal = rr*Fr - ii*Fi//		Fimag = rr*Fi + ii*Fr//		//  for hexagonal://		//	h+2k=3n,		l=even;		F = 4*f			1//		//	h+2k=3n±1,	l=odd;		F = sqrt(3)*f   sqrt(3)/4//		//	h+2k=3n±1,	l=even;		F = f			1/4//		//	h+2k=3n,		l=odd; 		F = 0			0//	endif////	Freal = abs(Freal)<1e-8 ? 0 : Freal//	Fimag = abs(Fimag)<1e-8 ? 0 : Fimag//	return cmplx(Freal,Fimag)//End//Function reMakeAtomXYZs(xtal)	STRUCT crystalStructure &xtal				// this sruct is filled  by this routine	Wave ww = root:Packages:Lattices:atom0	if (WaveExists(ww) && strlen(xtal.hashID))	// if first atom has correct hash, assume the rest are OK too		if (stringmatch(StringByKey("ID",note(ww),"="),xtal.hashID))			return 0								// waves have correct hash, so return		endif	endif	if (strlen(xtal.hashID)<1)		String strStruct		xtal.hashID = ""							// re-set hash function to identify associated waves		StructPut/S xtal, strStruct		xtal.hashID = hash(strStruct,1)	endif	String wnote=ReplaceStringByKey("ID","",xtal.hashID,"="), name	Variable m	for (m=0;m<xtal.N;m+=1)					// loop over each atom type		name="root:Packages:Lattices:atom"+num2istr(m)		Make/N=3/O/D $name		Wave ww = $name		positionsOfOneAtomType(xtal.SpaceGroup,xtal.atom[m].x,xtal.atom[m].y,xtal.atom[m].z,ww)		wnote = ReplaceStringByKey("atomType",wnote,xtal.atom[m].name,"=")		wnote = ReplaceNumberByKey("Zatom",wnote,xtal.atom[m].Zatom,"=")		wnote = ReplaceNumberByKey("occupy",wnote,xtal.atom[m].occ,"=")		Note/K ww, wnote	endfor	return 0End//Function reMakeAtomXYZs(xtal)//	STRUCT crystalStructure &xtal				// this sruct is filled  by this routine//	String wnote=ReplaceStringByKey("ID","",xtal.hashID,"="), name//	Variable m, OK//	for (m=0;m<xtal.N;m+=1)					// loop over each atom type//		name="root:Packages:Lattices:atom"+num2istr(m)//		Wave ww = $name//		OK = 0//		if (WaveExists(ww))//			OK = stringmatch(StringByKey("ID",note(ww),"="),xtal.hashID)//		endif//		if (!OK)									// cached arrays do not match the hashID in crystalStructure//			Make/N=3/O/D $name//			Wave ww = $name//			positionsOfOneAtomType(xtal.SpaceGroup,xtal.atom[m].x,xtal.atom[m].y,xtal.atom[m].z,ww)//			wnote = ReplaceStringByKey("atomType",wnote,xtal.atom[m].name,"=")//			wnote = ReplaceNumberByKey("Zatom",wnote,xtal.atom[m].Zatom,"=")//			wnote = ReplaceNumberByKey("occupy",wnote,xtal.atom[m].occ,"=")//			Note/K ww, wnote//		endif//	endfor//End////Function testFstruct(h,k,l)//	Variable h,k,l//	STRUCT crystalStructure xtal				// this sruct is filled  by this routine////	readCrystalStructure(xtal,"Macintosh HD:Users:tischler:Desktop:new sym calc:al2o3.cri")////	readCrystalStructure(xtal,"Macintosh HD:Users:tischler:Desktop:new sym calc:si.cri")////	readCrystalStructure(xtal,"")////	readCrystalStructure(xtal,"silicon.xtl")//	FillCrystalStructDefault(xtal)////	Variable/C Fc = Fstruct(xtal,h,k,l)//	printf "F(%d %d %d) = %g %s i%g,      |F| = %g\r",h,k,l,real(Fc),SelectString(imag(Fc)<0,"+","-"),abs(imag(Fc)),sqrt(magsqr(Fc))//End//Static Function positionsOfOneAtomType(SpaceGroup,xx,yy,zz,xyz)	Variable SpaceGroup	//Space Group number, from International Tables	Variable xx,yy,zz		// fractional coords of this kind of atom	Wave xyz				// list of all equiv posiitions for this atom in fractional coords	SetSymOpsForSpaceGroup(SpaceGroup)			// ensure existance of symmetry op mats and vecs	Wave mats = $("root:Packages:Lattices:SymOps:equivXYZM"+num2istr(SpaceGroup))	Wave bvecs = $("root:Packages:Lattices:SymOps:equivXYZB"+num2istr(SpaceGroup))	if (!WaveExists(mats) || !WaveExists(bvecs))		Abort"Unable to get symmetry operations in positionsOfOneAtomType()"	endif	Make/N=(3,3)/O/D matTemp_					// temp utiliity waves	Make/N=3/O/D vecTemp_, vecTempIn_	Wave mat=matTemp_, bv=vecTemp_, in=vecTempIn_	Variable m,Neq=NumberByKey("numSymOps", note(mats),"=")	Redimension/N=(Neq,3) xyz	in = {xx,yy,zz}	xyz = NaN	Variable dup, i,N	// printf "atom at  %.5f, %.5f, %.5f\r",in[0],in[1],in[2]	for (m=0,N=0;m<Neq;m+=1)		mat = mats[m][p][q]		bv = bvecs[m][p]		MatrixOp/O rrTemp_ = mat x in + bv		Wave rr = rrTemp_		rr += abs(floor(rr))						// translate back in to unit cell, so value in [0,1)		rr = mod(rr,1)		for (i=0,dup=0;i<N;i+=1)					// reject duplicates positions			if (abs(xyz[i][0]-rr[0])+abs(xyz[i][1]-rr[1])+abs(xyz[i][2]-rr[2])<1e-3)				dup = 1				break			endif		endfor		if (!dup)									// not a duplicate, so add to the list of positions			// printf "atom at  %.5f, %.5f, %.5f\r",rr[0],rr[1],rr[2]			xyz[N][] = rr[q]			N += 1		endif	endfor	Redimension/N=(N,3) xyz						// remove extra space (since no duplicates)	Wave Unconventional=root:Packages:Lattices:Unconventional	if (WaveExists(Unconventional))					// Unconventional exists, transform all the fractional coords		Wave vec = vecTemp_		for (i=0;i<N;i+=1)			vec = xyz[i][p]			MatrixOp/O vec = Unconventional x vec			xyz[i][] = vec[q]		endfor	endif	KillWaves/Z matTemp_, vecTemp_, vecTempIn_, rrTemp_	return NEndFunction allowedHKL(h,k,l,xtal)	Variable h,k,l	STRUCT crystalStructure &xtal	Variable/C Fc = Fstruct(xtal,h,k,l)	return (magsqr(Fc)/(xtal.N)^2 > 0.0001)			// allowed means more than 0.01 electron/atomEndThreadSafe Function/S MakeSymmetryOps(xtal)				// make a wave with the symmetry operation	STRUCT crystalStructure &xtal	String SG = num2istr(xtal.SpaceGroup)	Wave equivXYZM = $("root:Packages:Lattices:SymOps:equivXYZM"+SG)	if (!WaveExists(equivXYZM))		return ""	endif	Variable Nequiv=DimSize(equivXYZM,0)				// number of all symmetry operations for this space group	String/G root:Packages:Lattices:SymOps:SymmetryOpsPath="root:Packages:Lattices:SymOps:SymmetryOps"+SG	String wName = "root:Packages:Lattices:SymOps:SymmetryOps"+SG	Make/N=(2*Nequiv,3,3)/D/O $wName=NaN	Wave ops = $wName	Make/N=(3,3)/D/FREE direct,mat	direct[0][0] = xtal.a0;		direct[0][1] = xtal.b0;		direct[0][2] = xtal.c0	direct[1][0] = xtal.a1;		direct[1][1] = xtal.b1;		direct[1][2] = xtal.c1	direct[2][0] = xtal.a2;		direct[2][1] = xtal.b2;		direct[2][2] = xtal.c2	MatrixOp/FREE/O directI = Inv(direct)	Variable i, N=0, Nproper=0	for (i=0;i<Nequiv;i+=1)									// loop through all Nequiv, rejecting duplicates, and only accepting proper rotations		mat = equivXYZM[i][p][q]		MatrixOp/O/FREE mat = direct x mat x directI		// convert to cartesian, similarity transform		if (isMatInMats(mat,ops) ||MatrixDet(mat)<0)	// skip duplicates and improper rotations			continue		endif		ops[N][][] = mat[q][r]								// save this mat		Nproper += MatrixDet(mat)>0 ? 1 : 0		N += 1	endfor	// go through list again, this time only taking unique IMproper rotations	for (i=0;i<Nequiv;i+=1)									// again, loop through all Nequiv, rejecting duplicates		mat = equivXYZM[i][p][q]		MatrixOp/O/FREE mat = direct x mat x directI		// convert to cartesian, similarity transform		if (isMatInMats(mat,ops))							// skip duplicates			continue		endif		ops[N][][] = mat[q][r]								// save this mat		N += 1	endfor	Redimension/N=(N,-1,-1) ops	ops = abs(ops[p][q][r])<1e-13 ? 0 : ops[p][q][r]		// remove the almost zeros	ops = abs(1-ops[p][q][r])<1e-13 ? 1 : ops[p][q][r]	//  and make almost 1's equal to 1	ops = abs(1+ops[p][q][r])<1e-13 ? -1 : ops[p][q][r]	Note/K ops, "Nproper="+num2istr(Nproper)+";"	return GetWavesDataFolder(ops,2)End//ThreadSafe Static Function isMatInMats(mat,ops)	Wave mat, ops	Make/N=(3,3)/FREE/D delta	Variable i,N=DimSize(ops,0)							// Make/N=(2*N,3,3)/D/O ops=NaN	for (i=0;i<N;i+=1)		delta = mat[p][q] - ops[i][p][q]		if (numtype(sum(delta)))							// extra mats in ops are filled with NaN			break		endif		delta = abs(delta)		if (sum(delta)<1e-13)			return 1		endif	endfor	return 0End////Function testAllSymmetryOps()//	Make/N=(230,3)/O NtestAll=NaN//	SetScale/P x 1,1,"", NtestAll////	Variable SpaceGroup, err//	for (SpaceGroup=1; SpaceGroup<=230 && !err; SpaceGroup+=1)//		LatticeSym#SetSymOpsForSpaceGroup(SpaceGroup)//		err = testOneSymmetryOp(SpaceGroup)//		Wave Mwave = $("root:Packages:Lattices:SymOps:equivXYZM"+num2istr(SpaceGroup))//		NtestAll[SpaceGroup-1][0] = DimSize(Mwave,0)//		Wave Swave = $("root:Packages:Lattices:SymOps:SymmetryOps"+num2istr(SpaceGroup))//		NtestAll[SpaceGroup-1][1] = DimSize(Swave,0)//		NtestAll[SpaceGroup-1][21] = NumberByKey("Nproper",note(Swave),"=")//	endfor//	String str=SelectString(err,"checked all 230 Space Groups with no error","ERROR on Space Group "+num2istr(SpaceGroup-1))//	print str//	DoAlert 0, str//	if (!err)//		KillWaves/Z detTest, NtestAll//	endif//End//Static Function testOneSymmetryOp(SpaceGroup)//	Variable SpaceGroup//	if (SpaceGroup!=limit(round(SpaceGroup),1,230))//		printf "SpaceGroup = %g, not in [1,230]\r",SpaceGroup//		return 1//	endif////	STRUCT crystalStructure xtal//	FillCrystalStructDefault(xtal)//	xtal.SpaceGroup = SpaceGroup//	LatticeSym#setDirectRecip(xtal)//	initSymmetryOperations()						// initialize all symmetry operations//	indexLots#MakeSymmetryOps(xtal)				// make a wave with the symmetry operation//	SVAR symName=root:Packages:Lattices:SymOps:SymmetryOpsPath//	Wave sym=$symName////	Variable Nproper = NumberByKey("Nproper",note(sym),"="), N=DimSize(sym,0), err=0//	if (N!=2*Nproper && 0)//		printf "SpaceGroup = %d,  N=%g, and Nproper = %g,   Nproper is not N/2\r",SpaceGroup,N,Nproper//		err = 1//	endif//	Make/N=(N)/O detTest=NaN//	Make/N=(3,3)/D/FREE mat//	Variable i,det//	for (i=0;i<N;i+=1)//		mat = sym[i][p][q]//		det = MatrixDet(mat)//		detTest[i] = det//		if (i<Nproper && abs(det-1)>1e-8)//			printf "SpaceGroup = %d,  for i=%d, should be proper rotation, but det = %g\r",SpaceGroup,i,det//			err = 1//		elseif (i>=Nproper && abs(det+1)>1e-8)//			printf "SpaceGroup = %d,  for i=%d, should be IMproper rotation, but det = %g\r",SpaceGroup,i,det//			err = 1//		elseif (abs(abs(det)-1)>1e-8)//			printf "SpaceGroup = %d,  for i=%d, strange error, det = %g\r",SpaceGroup,i,det//			err = 1//		endif//	endfor//	return err//End// returns info about the symmetry of a structure// sym holds the symmetry info on return, and xyz holds the atom positions.  It returns the number of atom positions put in xyz// which is always at least 1.  If you call with a bad wave ref for xyz, then it only returns the sym string, and the returned value is 0////	Extensions//	----------//	Monoclinic             unique axis b        unique axis c              unique axis a//					   abc     c-ba		   abc    ba-c		  abc     -acb//					 ----------		---------- 		----------//		cell choice 1   :b1   :-b1			   :c1   :-c1			  :a1     :-a1//				     2   :b2   :-b2			   :c2   :-c2			  :a2     :-a2//				     3   :b3   :-b3			   :c3   :-c3			  :a3     :-a3////    Orthorhombic   :ba-c	change of basis abc -> ba-c//					:1		origin choice 1//					:2ba-c	origin choice 2, change of basis abc -> ba-c////    Tetragonal		:1	origin choice 1//           Cubic		:2	origin choice 2////    Trigonal		:H	hexagonal    axes//					:R	rhombohedral axesThreadSafe Function/S getHMboth(SpaceGroup)	// returns short and (full) Hermann-Mauguin symbol	Variable SpaceGroup						//Space Group number, from International Tables	String short = getHMsym(SpaceGroup)	String full = getFullHMSym(SpaceGroup)	if (StringMatch(short,full))		return short	else		return short + "  ("+full+")"	endifEndThreadSafe Function/S getHMsym(SpaceGroup)	// returns short Hermann-Mauguin symbol	Variable SpaceGroup						//Space Group number, from International Tables	if (SpaceGroup<1 || SpaceGroup>230)		return ""								// invalid SpaceGroup number	endif	// there are 230 items in this list	String symms="P1;P-1;P2:b;P21:b;C2:b1;Pm:b;Pc:b1;"	symms += "Cm:b1;Cc:b1;P2/m:b;P21/m:b;C2/m:b1;P2/c:b1;"	symms += "P21/c:b1;C2/c:b1;P222;P2221;P21212;P212121;"	symms += "C2221;C222;F222;I222;I212121;Pmm2;Pmc21;"	symms += "Pcc2;Pma2;Pca21;Pnc2;Pmn21;Pba2;Pna21;"	symms += "Pnn2;Cmm2;Cmc21;Ccc2;Amm2;Abm2;Ama2;Aba2;"	symms += "Fmm2;Fdd2;Imm2;Iba2;Ima2;Pmmm;Pnnn:1;Pccm;"	symms += "Pban:1;Pmma;Pnna;Pmna;Pcca;Pbam;Pccn;Pbcm;"	symms += "Pnnm;Pmmn:1;Pbcn;Pbca;Pnma;Cmcm;Cmca;Cmmm;"	symms += "Cccm;Cmma;Ccca:1;Fmmm;Fddd:1;Immm;Ibam;Ibca;"	symms += "Imma;P4;P41;P42;P43;I4;I41;P-4;I-4;"	symms += "P4/m;P42/m;P4/n:1;P42/n:1;I4/m;I41/a:1;P422;"	symms += "P4212;P4122;P41212;P4222;P42212;P4322;P43212;"	symms += "I422;I4122;P4mm;P4bm;P42cm;P42nm;P4cc;"	symms += "P4nc;P42mc;P42bc;I4mm;I4cm;I41md;I41cd;"	symms += "P-42m;P-42c;P-421m;P-421c;P-4m2;P-4c2;P-4b2;"	symms += "P-4n2;I-4m2;I-4c2;I-42m;I-42d;P4/mmm;P4/mcc;"	symms += "P4/nbm:1;P4/nnc:1;P4/mbm;P4/mnc;P4/nmm:1;P4/ncc:1;"	symms += "P42/mmc;P42/mcm;P42/nbc:1;P42/nnm:1;P42/mbc;P42/mnm;"	symms += "P42/nmc:1;P42/ncm:1;I4/mmm;I4/mcm;I41/amd:1;"	symms += "I41/acd:1;P3;P31;P32;R3:H;P-3;R-3:H;P312;"	symms += "P321;P3112;P3121;P3212;P3221;R32:H;P3m1;P31m;"	symms += "P3c1;P31c;R3m:H;R3c:H;P-31m;P-31c;P-3m1;P-3c1;"	symms += "R-3m:H;R-3c:H;P6;P61;P65;P62;P64;P63;P-6;"	symms += "P6/m;P63/m;P622;P6122;P6522;P6222;P6422;P6322;"	symms += "P6mm;P6cc;P63cm;P63mc;P-6m2;P-6c2;P-62m;P-62c;"	symms += "P6/mmm;P6/mcc;P63/mcm;P63/mmc;P23;F23;I23;P213;"	symms += "I213;Pm-3;Pn-3:1;Fm-3;Fd-3:1;Im-3;Pa-3;Ia-3;"	symms += "P432;P4232;F432;F4132;I432;P4332;P4132;I4132;"	symms += "P-43m;F-43m;I-43m;P-43n;F-43c;I-43d;Pm-3m;"	symms += "Pn-3n:1;Pm-3n;Pn-3m:1;Fm-3m;Fm-3c;Fd-3m:1;Fd-3c:1;"	symms += "Im-3m;Ia-3d;"	return StringFromList(SpaceGroup-1,symms)	// set the symmetry symbolEnd// Full H-M symbols only differ from the regular ones (in getHMsym) for Space Groups: 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15ThreadSafe Function/S getFullHMSym(SpaceGroup)	// returns full Hermann-Mauguin symbol	Variable SpaceGroup					//Space Group number, from International Tables	if (SpaceGroup<1 || SpaceGroup>230)		return ""							// invalid SpaceGroup number	endif	// there are 230 items in this list	String fullSymms="P1;P-1;P121:b;P1211:b;C121:b1;P1m1:b;"	fullSymms += "P1c1:b1;C1m1:b1;C1c1:b1;P12/m1:b;P121/m1:b;"	fullSymms += "C12/m1:b1;P12/c1:b1;P121/c1:b1;C12/c1:b1;P222;"	fullSymms += "P2221;P21212;P212121;C2221;C222;F222;I222;I212121;"	fullSymms += "Pmm2;Pmc21;Pcc2;Pma2;Pca21;Pnc2;Pmn21;Pba2;Pna21;"	fullSymms += "Pnn2;Cmm2;Cmc21;Ccc2;Amm2;Abm2;Ama2;Aba2;Fmm2;"	fullSymms += "Fdd2;Imm2;Iba2;Ima2;Pmmm;Pnnn:1;Pccm;Pban:1;Pmma;"	fullSymms += "Pnna;Pmna;Pcca;Pbam;Pccn;Pbcm;Pnnm;Pmmn:1;Pbcn;"	fullSymms += "Pbca;Pnma;Cmcm;Cmca;Cmmm;Cccm;Cmma;Ccca:1;Fmmm;"	fullSymms += "Fddd:1;Immm;Ibam;Ibca;Imma;P4;P41;P42;P43;I4;I41"	fullSymms += ";P-4;I-4;P4/m;P42/m;P4/n:1;P42/n:1;I4/m;I41/a:1;"	fullSymms += "P422;P4212;P4122;P41212;P4222;P42212;P4322;P43212;"	fullSymms += "I422;I4122;P4mm;P4bm;P42cm;P42nm;P4cc;P4nc;P42mc;"	fullSymms += "P42bc;I4mm;I4cm;I41md;I41cd;P-42m;P-42c;P-421m;"	fullSymms += "P-421c;P-4m2;P-4c2;P-4b2;P-4n2;I-4m2;I-4c2;I-42m;"	fullSymms += "I-42d;P4/mmm;P4/mcc;P4/nbm:1;P4/nnc:1;P4/mbm;P4/mnc;"	fullSymms += "P4/nmm:1;P4/ncc:1;P42/mmc;P42/mcm;P42/nbc:1;P42/nnm:1;"	fullSymms += "P42/mbc;P42/mnm;P42/nmc:1;P42/ncm:1;I4/mmm;I4/mcm;"	fullSymms += "I41/amd:1;I41/acd:1;P3;P31;P32;R3:H;P-3;R-3:H;P312;"	fullSymms += "P321;P3112;P3121;P3212;P3221;R32:H;P3m1;P31m;P3c1;"	fullSymms += "P31c;R3m:H;R3c:H;P-31m;P-31c;P-3m1;P-3c1;R-3m:H;"	fullSymms += "R-3c:H;P6;P61;P65;P62;P64;P63;P-6;P6/m;P63/m;P622;"	fullSymms += "P6122;P6522;P6222;P6422;P6322;P6mm;P6cc;P63cm;P63mc;"	fullSymms += "P-6m2;P-6c2;P-62m;P-62c;P6/mmm;P6/mcc;P63/mcm;"	fullSymms += "P63/mmc;P23;F23;I23;P213;I213;Pm-3;Pn-3:1;Fm-3;"	fullSymms += "Fd-3:1;Im-3;Pa-3;Ia-3;P432;P4232;F432;F4132;I432;"	fullSymms += "P4332;P4132;I4132;P-43m;F-43m;I-43m;P-43n;F-43c;"	fullSymms += "I-43d;Pm-3m;Pn-3n:1;Pm-3n;Pn-3m:1;Fm-3m;Fm-3c;"	fullSymms += "Fd-3m:1;Fd-3c:1;Im-3m;Ia-3d"	return StringFromList(SpaceGroup-1,fullSymms)	// set the symmetry symbolEndThreadSafe Function/S getHallSymbol(SpaceGroup)	Variable SpaceGroup					//Space Group number, from International Tables	if (SpaceGroup<1 || SpaceGroup>230)		return ""							// invalid SpaceGroup number	endif	// there are 230 items in this list	String Hall="P 1;-P 1;P 2y:b;P 2yb:b;C 2y:b1;P -2y:b;P -2yc:b1;"	Hall += "C -2y:b1;C -2yc:b1;-P 2y:b;-P 2yb:b;-C 2y:b1;-P 2yc:b1;"	Hall += "-P 2ybc:b1;-C 2yc:b1;P 2 2;P 2c 2;P 2 2ab;P 2ac 2ab;"	Hall += "C 2c 2;C 2 2;F 2 2;I 2 2;I 2b 2c;P 2 -2;P 2c -2;"	Hall += "P 2 -2c;P 2 -2a;P 2c -2ac;P 2 -2bc;P 2ac -2;P 2 -2ab;"	Hall += "P 2c -2n;P 2 -2n;C 2 -2;C 2c -2;C 2 -2c;A 2 -2;A 2 -2c;"	Hall += "A 2 -2a;A 2 -2ac;F 2 -2;F 2 -2d;I 2 -2;I 2 -2c;I 2 -2a;"	Hall += "-P 2 2;P 2 2 -1n:1;-P 2 2c;P 2 2 -1ab:1;-P 2a 2a;"	Hall += "-P 2a 2bc;-P 2ac 2;-P 2a 2ac;-P 2 2ab;-P 2ab 2ac;"	Hall += "-P 2c 2b;-P 2 2n;P 2 2ab -1ab:1;-P 2n 2ab;-P 2ac 2ab;"	Hall += "-P 2ac 2n;-C 2c 2;-C 2bc 2;-C 2 2;-C 2 2c;-C 2b 2;"	Hall += "C 2 2 -1bc:1;-F 2 2;F 2 2 -1d:1;-I 2 2;-I 2 2c;-I 2b 2c;"	Hall += "-I 2b 2;P 4;P 4w;P 4c;P 4cw;I 4;I 4bw;P -4;I -4;-P 4;"	Hall += "-P 4c;P 4ab -1ab:1;P 4n -1n:1;-I 4;I 4bw -1bw:1;P 4 2;"	Hall += "P 4ab 2ab;P 4w 2c;P 4abw 2nw;P 4c 2;P 4n 2n;P 4cw 2c;"	Hall += "P 4nw 2abw;I 4 2;I 4bw 2bw;P 4 -2;P 4 -2ab;P 4c -2c;"	Hall += "P 4n -2n;P 4 -2c;P 4 -2n;P 4c -2;P 4c -2ab;I 4 -2;"	Hall += "I 4 -2c;I 4bw -2;I 4bw -2c;P -4 2;P -4 2c;P -4 2ab;"	Hall += "P -4 2n;P -4 -2;P -4 -2c;P -4 -2ab;P -4 -2n;I -4 -2;"	Hall += "I -4 -2c;I -4 2;I -4 2bw;-P 4 2;-P 4 2c;P 4 2 -1ab:1;"	Hall += "P 4 2 -1n:1;-P 4 2ab;-P 4 2n;P 4ab 2ab -1ab:1;"	Hall += "P 4ab 2n -1ab:1;-P 4c 2;-P 4c 2c;P 4n 2c -1n:1;"	Hall += "P 4n 2 -1n:1;-P 4c 2ab;-P 4n 2n;P 4n 2n -1n:1;"	Hall += "P 4n 2ab -1n:1;-I 4 2;-I 4 2c;I 4bw 2bw -1bw:1;"	Hall += "I 4bw 2aw -1bw:1;P 3;P 31;P 32;R 3:H;-P 3;-R 3:H;"	Hall += "P 3 2;P 3 2'';P 31 2c (0 0 1);P 31 2'';P 32 2c (0 0 -1);"	Hall += "P 32 2'';R 3 2'':H;P 3 -2'';P 3 -2;P 3 -2''c;P 3 -2c;R 3 -2'':H;"	Hall += "R 3 -2''c:H;-P 3 2;-P 3 2c;-P 3 2'';-P 3 2''c;-R 3 2'':H;"	Hall += "-R 3 2''c:H;P 6;P 61;P 65;P 62;P 64;P 6c;P -6;-P 6;-P 6c;"	Hall += "P 6 2;P 61 2 (0 0 -1);P 65 2 (0 0 1);P 62 2c (0 0 1);"	Hall += "P 64 2c (0 0 -1);P 6c 2c;P 6 -2;P 6 -2c;P 6c -2;P 6c -2c;"	Hall += "P -6 2;P -6c 2;P -6 -2;P -6c -2c;-P 6 2;-P 6 2c;-P 6c 2;"	Hall += "-P 6c 2c;P 2 2 3;F 2 2 3;I 2 2 3;P 2ac 2ab 3;I 2b 2c 3;"	Hall += "-P 2 2 3;P 2 2 3 -1n:1;-F 2 2 3;F 2 2 3 -1d:1;-I 2 2 3;"	Hall += "-P 2ac 2ab 3;-I 2b 2c 3;P 4 2 3;P 4n 2 3;F 4 2 3;F 4d 2 3;"	Hall += "I 4 2 3;P 4acd 2ab 3;P 4bd 2ab 3;I 4bd 2c 3;P -4 2 3;"	Hall += "F -4 2 3;I -4 2 3;P -4n 2 3;F -4c 2 3;I -4bd 2c 3;-P 4 2 3;"	Hall += "P 4 2 3 -1n:1;-P 4n 2 3;P 4n 2 3 -1n:1;-F 4 2 3;-F 4c 2 3;"	Hall += "F 4d 2 3 -1d:1;F 4d 2 3 -1cd:1;-I 4 2 3;-I 4bd 2c 3;"	return StringFromList(SpaceGroup-1,Hall)	// set the Hall symbolEndThreadSafe Static Function latticeSystem(SpaceGroup)	Variable SpaceGroup				//Space Group number, from International Tables	if (SpaceGroup>230)		return -1					  	 // invalid	elseif (SpaceGroup>=195)		return CUBIC	elseif (SpaceGroup>=168)		return HEXAGONAL	elseif (SpaceGroup>=143)		return TRIGONAL				// Trigonal, (using the hexagonal cell axes)	elseif (SpaceGroup>=75)		return TETRAGONAL	elseif (SpaceGroup>=16)		return ORTHORHOMBIC	elseif (SpaceGroup>=3)		return MONOCLINIC	elseif  (SpaceGroup>0)		return TRICLINIC	endif	return -1							// invalidEndFunction/S symmtry2SG(strIN,[type,printIt])	// find the Space Group number from the symmetry string	String strIN	Variable type						// 0=Check All, 1=Hermann-Mauguin, 2=Full Hermann-Mauguin, 3=Hall, 4=Lattice System, 5=SpaceGroup Number, 	Variable printIt	type = ParamIsDefault(type) ? 0 : round(type)	type = type<0 || type>5 ? NaN : type	printIt = ParamIsDefault(printIt) ? NaN : printIt	printIt = numtype(printIt) ?  strlen(GetRTStackInfo(2))<1 : !(!printIt)	if (strlen(strIN)<1 || numtype(type))		Prompt strIN, "Symmetry Symbol or Space Group Number, (e.g. \"Pmm*\"), wild cards allowed"		Prompt type,"Symbol Type",popup,"Check All Symbol Types;Hermann-Mauguin;Full Hermann-Mauguin;Hall;Lattice System;SpaceGroup Number"		type += 1		DoPrompt "Symmetry Symbol",strIN,type		if (V_flag)			return ""		endif		type -= 1		printIt = 1	endif	if (strlen(strIN)<1)		return ""	endif	type = round(type)	String list="", name=StringFromList(type,"any type of;Hermann-Mauguin;FULL Hermann-Mauguin;Hall;Lattice System;")	Variable SG	if (type==5 || type==0)		SG = round(str2num(strIN))		SG = (SG>=1 && SG<=230) ? SG : NaN		if (numtype(SG)==0)			sprintf list,"%d;",SG		endif	endif	if (type==1 || type==0)		list += SymString2SG(strIn,1)	endif	if (type==2 || type==0)		list += SymString2SG(strIn,2)	endif	if (type==3 || type==0)		list += SymString2SG(strIn,3)	endif	if (type==4 || type==0)		list += SymString2SG(strIn,4)	endif	Variable i,Nlist=ItemsInList(list), last, now	String str = SortList(list,";",2)	list = ""	for (last=-Inf,i=0; i<Nlist; i+=1)		// remove duplicates		now = str2num(StringFromList(i,str))		now = numtype(now) ? NaN : now		now = (now>=1 && now<=230) ? now : NaN		if (now>last)			list += num2istr(now)+";"			last = now		endif	endfor	// finally print out information about each SG in list	if (printIt)		if (Nlist<1)			printf "No matches of \"%s\" to a %s symbol\r",strIN,name			return ""		elseif (Nlist>1)			printf "There are %g possible matches of  \"%s\"  to %s symbol\r",Nlist,strIN,name		endif		printf "SG\t\t\t\tSystem\t\t\t\tH-M\t\t\tHall\r"		String tab,fullHM,HM, system, systemNames="Triclinic\t;Monoclinic\t;Orthorhombic;Tetragonal\t;Trigonal\t;Hexagonal\t;Cubic\t\t"		for (SG=NaN,i=0; i<Nlist; i+=1)			SG = str2num(StringFromList(i,list))			SG = (SG>=1 && SG<=230) ? SG : NaN			if (numtype(SG)==0)				fullHM = getFullHMSym(SG)			// usually fullHM is the same as HM				HM = getHMSym(SG)				fullHM = SelectString(StringMatch(fullHM,HM),"\t\tfull H-M = ["+fullHM+"]","")				tab = SelectString(strlen(getFullHMSym(SG))>5,"\t","")				system = StringFromList(latticeSystem(SG),systemNames)				printf "%d   \t-->\t\t%s\t\t%s\t\t%s%s%s\r", SG,system,HM,tab,getHallSymbol(SG),fullHM			endif		endfor	endif	return listEndStatic Function/S SymString2SG(symIN,type)	// finds space group of a Hermann-Mauguin or Hall symbol, wild cards allowed	String symIN						// requested symbol, if empty, then a dialog will come up	Variable type						// 1=Hermann-Mauguin, 2=Full Hermann-Mauguin, 3=Hall, 4=Lattice System	String find = ReplaceString(" ",symIN,"")	// do not include spaces in search	String list=""	type = round(type)	if (type==1)		FUNCREF getHMsym symbolFunc = getHMsym	elseif (type==2)		FUNCREF getHMsym symbolFunc = getFullHMSym	elseif (type==3)		FUNCREF getHMsym symbolFunc = getHallSymbol	elseif (type==4)		if (StringMatch("Triclinic",find))			list += expandRange("1-2",";")+";"		endif		if (StringMatch("Monoclinic",find))			list += expandRange("3-15",";")+";"		endif		if (StringMatch("Orthorhombic",find))			list += expandRange("16-74",";")+";"		endif		if (StringMatch("Tetragonal",find))			list += expandRange("75-142",";")+";"		endif		if (StringMatch("Trigonal",find))			list += expandRange("143-167",";")+";"		elseif (StringMatch("Rhombohedral",find))			list += expandRange("143-167",";")+";"		endif		if (StringMatch("Hexagonal",find))			list += expandRange("168-193",";")+";"		endif		if (StringMatch("Cubic",find))			list += expandRange("195-230",";")+";"		endif	else		return ""	endif	String sym	Variable SG	for (SG=1;SG<=230;SG+=1)					// check all 230 space goups		sym = symbolFunc(SG)		if (StringMatch(ReplaceString(" ",sym,"")	,find))// ignore spaces			list += num2istr(SG)+";"				// found a match, save it		endif	endfor	return listEnd//	DEPRECATED	DEPRECATED	DEPRECATED	DEPRECATED// This function is DEPRECATED, it is just left here for old stuff, use getHMsym() insteadThreadSafe Function/S getSymString(SpaceGroup)	// returns short Hermann-Mauguin symbol	Variable SpaceGroup							//Space Group number, from International Tables	return getHMsym(SpaceGroup)EndThreadSafe Function/C Hex2Rhom(aH,cH)			// convert lattice constants	Variable aH,cH					// Hexagonal lattice constants	Variable aR,alpha				// Rhombohedral lattice constants	aR = (1/3) * sqrt(3*aH^2 + cH^2)	alpha = asin( 3/2 / sqrt(3+(cH/aH)^2) ) * 2 * 180/PI	return cmplx(aR,alpha)EndThreadSafe Function/C Rhom2Hex(aR,alpha)		// convert lattice constants	Variable aR, alpha				// Rhombohedral lattice constants	Variable aH,cH					// Hexagonal lattice constants	Variable  ca2					// (cH/aH)^2	ca2 = (3/2 / sin(alpha*PI/180/2))^2 - 3	aH  = sqrt( (3*aR)^2/(ca2 + 3) )	cH = aH*sqrt(ca2)	return cmplx(aH,cH)End//	#define ALLOW_FC(H,K,L) (!(((H)+(K))%2) && !(((K)+(L))%2))		// H,K,L all even or all odd//	#define ALLOW_BC(H,K,L) (!(((H)+(K)+(L))%2))					// !mod(round(h+k+l),2)//	#define ALLOW_CC(H,K,L) (!((H)+(K))%2)							// !mod(round(h+k),2)//	#define ALLOW_AC(H,K,L) (!((K)+(L))%2)							// !mod(round(k+l),2)//	#define ALLOW_RHOM_HEX(H,K,L) (((-(H)+(K)+(L))%3)==0 || (((H)-(K)+(L))%3)==0)   // allowed are -H+K+L=3n or H-K+L=3n//	#define ALLOW_HEXAGONAL(H,K,L) ((((H)+2*(K))%3) || !((L)%2))   // forbidden are: H+2K=3N with L odd//ThreadSafe Static Function ALLOW_FC(h,k,l)			// face-centered, hkl must be all even or all odd	Variable h,k,l	return !mod(h+k,2) && !mod(k+l,2)End//ThreadSafe Static Function ALLOW_BC(h,k,l)			// body-centered, !mod(round(h+k+l),2), sum must be even	Variable h,k,l	return !mod(round(h+k+l),2)End//ThreadSafe Static Function ALLOW_CC(h,k,l)			// C-centered, !mod(round(h+k),2)	Variable h,k,l	return !mod(round(h+k),2)End//ThreadSafe Static Function ALLOW_AC(h,k,l)			// A-centered, !mod(round(k+l),2)	Variable h,k,l	return !mod(round(k+l),2)End//ThreadSafe Static Function ALLOW_RHOM_HEX(h,k,l)	// rhombohedral hexagonal, allowed are -H+K+L=3n or H-K+L=3n	Variable h,k,l	return !mod(-h+k+l,3) || !mod(h-k+l,3)End//ThreadSafe Static Function ALLOW_HEXAGONAL(h,k,l)	// hexagonal, // forbidden are: H+2K=3N with L odd	Variable h,k,l	return mod(h+2*k,3) || !mod(l,2)EndThreadSafe Function isRhombohedral(SpaceGroup)	Variable SpaceGroup	switch(SpaceGroup)		// there are only 7 space groups that are Rhombohedral, sym for these all start with "R"		case 146:		case 148:		case 155:		case 160:		case 161:		case 166:		case 167:			return 1	endswitch	return 0EndThreadSafe Function PrimitiveCellFactor(xtal)		// number of primitive unit cells in conventional cell, or number of atoms in conventional cell	STRUCT crystalStructure &xtal	String sym = getHMsym(xtal.SpaceGroup)		// symmetry string	strswitch(sym[0,0])		case "F":										// Face Centered			return 4		case "I":										// Body Centered		case "C":										// Side Centered		case "A":										// Side Centered		case "B":										// Side Centered			return 2		case "R":										// Rhombohedral			if (abs(xtal.alpha-90)+abs(xtal.beta-90)+abs(xtal.gam-120) < 0.01)		// using Hexagonal axes				return 3								// there are 3 rhombohedral cells / hexagonal cell			else				return 1			endif	endswitch//	Variable SG = xtal.SpaceGroup//	if (SG<=194 && SG>=168)						// Hexagonal//		return 1										// Hexagonal is a primitive cell//	elseif (SG<168 && SG>=143)					// Trigonal (Rhombohedral)//		if (abs(xtal.alpha-90)+abs(xtal.beta-90)+abs(xtal.gam-120) < 0.01)		// using Hexagonal axes//			return 3									// there are 3 rhombohedral cells / hexagonal cell//		endif//	endif	return 1End//	End of crystal symmetry stuff// =========================================================================// =========================================================================// =========================================================================// =========================================================================//	Start of some utility routines// changes hkl[3] to the lowest order hkl, ignores whether a reflection is allowed, just removes common factorsThreadSafe Function lowestOrderHKL(h,k,l)	Variable &h,&k,&l							// these hkl are returned with all common factors removed	Variable maxDiv								// max possible divisor	Variable i	maxDiv = max(abs(h),abs(k))				// the maximum divisor cannot be bigger than the smallest of hkl	maxDiv = max(maxDiv,abs(l))	for (i=maxDiv;i>=2;i-=1)					// check all divisorts in range [2, maxDiv]		if (mod(h,i) || mod(k,i) || mod(l,i))	// i is not a factor of h, k, and l			continue		endif		h /= i		k /= i		l /= i	endforEnd// changes hkl[3] to the lowest order allowed hkl (ie for FCC, 0,0,12 -> 002 not 001Function lowestAllowedHKL(h,k,l)	Variable &h,&k,&l	STRUCT crystalStructure xtal			// temporary crystal structure	FillCrystalStructDefault(xtal)			//fill the lattice structure with default values//	ForceLatticeToStructure(xtal)	Variable i	Variable hh=h, kk=k, ll=l	lowestOrderHKL(hh,kk,ll)			// remove all common factors	for (i=1;i<16;i+=1)					// never need more than 16 to reach an allowed reflection		h = i*hh							// try each of the multiples to reach an allowed reflection		k = i*kk		l = i*ll		if (allowedHKL(h,k,l,xtal))			return 0		endif	endfor	return 0EndThreadSafe Function/WAVE str2recip(str)			// returns a FREE wave with reciprocal lattice	String str	Variable as0,as1,as2,bs0,bs1,bs2,cs0,cs1,cs2	sscanf str, "{{%g,%g,%g}{%g,%g,%g}{%g,%g,%g}}",as0,as1,as2,bs0,bs1,bs2,cs0,cs1,cs2	if (V_flag==9)		Make/N=(3,3)/D/FREE RL		RL[0][0]= {as0,as1,as2}					// the reciprocal lattice		RL[0][1]= {bs0,bs1,bs2}		RL[0][2]= {cs0,cs1,cs2}		return RL	else		return $""	endifEndThreadSafe Function/S hkl2str(h,k,l)	// format h,k,l into a string of acceptable minimal length	Variable h,k,l	if (numtype(h+k+l))		return "nan,nan,nan"	endif	h = abs(h)<1e-14 ? 0 : h	k = abs(k)<1e-14 ? 0 : k	l = abs(l)<1e-14 ? 0 : l	String hkl	if (abs(mod(h,1))+abs(mod(k,1))+abs(mod(l,1)) > 1e-6)	// hkl are non-integers		sprintf hkl,"%g, %g, %g",h,k,l	elseif (k<0 || l<0)		sprintf hkl,"%.0f, %.0f, %.0f",h,k,l	elseif (abs(h)<10 && k<10 && l<10)		sprintf hkl,"%.0f%.0f%.0f",h,k,l	else		sprintf hkl,"%.0f %.0f %.0f",h,k,l	endif	return hklEndThreadSafe Function/T hkl2IgorBarStr(h,k,l)	// changes negatives to a bar over the number, only for displaying, not printing	Variable h,k,l				// hkl value	if (numtype(h+k+l))		return num2str(h)+","+num2str(k)+","+num2str(l)	endif	String extra=SelectString(abs(h)>9 || abs(k)>9 || abs(l)>9 || h<0 || k<0 || l<0,""," ")	String str=""	str += minus2bar(num2istr(h),spaces=floor(log(abs(h)))) + extra	str += minus2bar(num2istr(k),spaces=floor(log(abs(k)))) + extra	str += minus2bar(num2istr(l),spaces=floor(log(abs(l))))	return strEnd//	str += SelectString(h<0,"","\\S \\f01Ñ\\f00\\M\\X0")+" "+num2istr(abs(h))	// mac//	str += SelectString(k<0,"","\\[1\\S\\f01 Ñ\\f00\\M\\X1")+" "+num2istr(abs(k))//	str += SelectString(l<0,"","\\[2\\S \\f01Ñ\\f00\\M\\X2")+" "+num2istr(abs(l))ThreadSafe Function/T minus2bar(str,[spaces])		// change an Igor string that has minuses to one using a bar over the following character	String str	Variable spaces	spaces = ParamIsDefault(spaces) ? 0 : spaces	spaces = round(spaces)==limit(spaces,1,5) ? spaces : 0	String sspaces = PadString("",spaces,0x20), bs	String bChar=SelectString(stringmatch(IgorInfo(2),"Windows"),"Ñ","¯")	// Mac bar character, on Windows use "¯"	for (; strsearch(str,"-",0)>=0;)		sprintf bs, "\\[9\\S\\f01%s\\]9\\M\\X9",sspaces+bChar		str = ReplaceString("-",str,bs,0,1)	endfor	return strEnd//Function/T minus2bar(str)		// change an Igor string that has minuses to one using a bar over following character//	String str//	String bs//	Variable i//	String bChar=SelectString(stringmatch(IgorInfo(2),"Windows"),"Ñ","¯")	// Mac bar character, on Windows use "¯"//	for (i=0; i<=9 && strsearch(str,"-",0)>=0; i+=1)//		sprintf bs, "\\[%d\\S\\f01%s\\f00\\M\\X%d",i,bChar,i//		str = ReplaceString("-",str,bs,0,1)//	endfor//	return str//EndThreadSafe Static Function placesOfPrecision(a)		// number of significant figures in a number	Variable a	a = roundSignificant(abs(a),17)	Variable i	for (i=1;i<18;i+=1)		if (abs(a-roundSignificant(a,i))/a<1e-15)			break		endif	endfor	return iEndFunction copy_xtal(target,source)						// copy a crystalStructure source to target	STRUCT crystalStructure &source	STRUCT crystalStructure &target	target.desc = source.desc	target.a = source.a	target.b = source.b	target.c = source.c	target.alpha = source.alpha	target.beta = source.beta	target.gam = source.gam	target.SpaceGroup = source.SpaceGroup	target.Vc = source.Vc	target.density = source.density	target.alphaT = source.alphaT	target.hashID = source.hashID	target.N = source.N	Variable i, N=source.N	for (i=0;i<N;i+=1)		target.atom[i].name = source.atom[i].name		target.atom[i].Zatom = source.atom[i].Zatom		target.atom[i].x = source.atom[i].x		target.atom[i].y = source.atom[i].y		target.atom[i].z = source.atom[i].z		target.atom[i].occ = source.atom[i].occ		target.atom[i].Debye = source.atom[i].Debye	endfor	target.a0 = source.a0	target.b0 = source.b0	target.c0 = source.c0	target.a1 = source.a1	target.b1 = source.b1	target.c1 = source.c1	target.a2 = source.a2	target.b2 = source.b2	target.c2 = source.c2	target.as0 = source.as0	target.bs0 = source.bs0	target.cs0 = source.cs0	target.as1 = source.as1	target.bs1 = source.bs1	target.cs1 = source.cs1	target.as2 = source.as2	target.bs2 = source.bs2	target.cs2 = source.cs2	target.Unconventional00 = source.Unconventional00	target.Unconventional01 = source.Unconventional01	target.Unconventional02 = source.Unconventional02	target.Unconventional10 = source.Unconventional10	target.Unconventional11 = source.Unconventional11	target.Unconventional12 = source.Unconventional12	target.Unconventional20 = source.Unconventional20	target.Unconventional21 = source.Unconventional21	target.Unconventional22 = source.Unconventional22End//	End of utility// =========================================================================// =========================================================================////	================================================================================////			This section creates the wave definitions used in    InitLatticeSymPackage()//Function InitLatticeSymPackage()								// used to initialize this package	NewDataFolder/O root:Packages	NewDataFolder/O root:Packages:Lattices	NewDataFolder/O root:Packages:Lattices:SymOpsEnd////	================================================================================////			This section is for making the matricies for the symmetry operations for Space Groups//Static Function SetSymOpsForSpaceGroup(SpaceGroup)		// make the symmetry operations mats and vecs (if needed), returns number of operations	Variable SpaceGroup	Wave mats = $("root:Packages:Lattices:SymOps:equivXYZM"+num2istr(SpaceGroup))	Wave bvecs = $("root:Packages:Lattices:SymOps:equivXYZB"+num2istr(SpaceGroup))	Variable numSymOps	if (WaveExists(mats) && WaveExists(bvecs))				// check if they exist		numSymOps = NumberByKey("numSymOps",note(mats),"=")		return numtype(numSymOps) ? 0 : numSymOps		// do not re-make, just return number of operations	endif	if (SpaceGroup<1 || 230<SpaceGroup)						// Space Group must be in range [1, 230]		DoAlert 0, "Bad Space Group = "+num2str(SpaceGroup)+", in SetSymOpsForSpaceGroup"		return 1	endif	if (!DataFolderExists("root:Packages:Lattices:SymOps:"))		DoAlert 0, "Cannot make symmetry matricies, the target data folder does not exist"		print "Cannot make symmetry matricies, the target data folder does not exist,  'root:Packages:Lattices:SymOps:'\r"		return 0	endif	String symOperations=setSymLine(SpaceGroup)			// a string like "x,y,z;-x,-y,z;-x,y,-z;x,-y,-z;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z;-x+1/2,y+1/2,-z;x+1/2,-y+1/2,-z"	Variable i,N=ItemsInList(symOperations)	String wName = "root:Packages:Lattices:SymOps:equivXYZM"+num2istr(SpaceGroup)	Make/N=(N,3,3)/O/B $wName								// this only holds 0 or ±1	Wave equivM = $wName	wName = "root:Packages:Lattices:SymOps:equivXYZB"+num2istr(SpaceGroup)	Make/N=(N,3)/O/D $wName	Wave equivB = $wName	Make/N=(3,3)/O/D mat_SymItem	Make/N=3/O/D vec_SymItem	Wave mat=mat_SymItem, vec=vec_SymItem	Variable err = 0	for (i=0;i<N;i+=1)		err = err || make1MatrixAndVecFromSymLine(StringFromList(i,symOperations))		equivM[i][][] = mat[q][r]		equivB[i][] = vec[q]	endfor	KillWaves/Z mat_SymItem,vec_SymItem	if (err)		Abort "error making symmetry matricies in SetSymOpsForSpaceGroup()"	endif	Note/K equivM, ReplaceNumberByKey("numSymOps","",N,"=")	Note/K equivB, ReplaceNumberByKey("numSymOps","",N,"=")	return NEnd//// makes one matrix[3][3] and one vector[3] from the expression like "x+1/3,y+2/3,z+2/3"Static Function make1MatrixAndVecFromSymLine(symItem)		// returns result in mat_SymItem and vec_SymItem, return value is error flag	String symItem													// something like "-x+1/2,-y+1/2,z"	Wave mat=mat_SymItem, vec=vec_SymItem	if (!WaveExists(mat) || !WaveExists(vec))		Make/N=(3,3)/O/D mat_SymItem		Make/N=3/O/D vec_SymItem		Wave mat=mat_SymItem, vec=vec_SymItem	endif	Variable m0,m1,m2, b	Variable i, err=0	for (i=0;i<3;i+=1)		err = err || ParseOneSymEquation(StringFromList(i,symItem,","),m0,m1,m2,b)		mat[i][0] = m0		mat[i][1] = m1		mat[i][2] = m2		vec[i] = b	endfor	return errEnd//Static Function ParseOneSymEquation(expression,m0,m1,m2,b)		// parse one expression of form "-x+y"  or "-x", or "-x+y, etc.	String expression	Variable &m0,&m1,&m2, &b	m0=0  ;  m1=0  ;  m2=0 ; b=0	// init, some may not be set in the strswitch	Variable num=NaN, denom=NaN	Variable i,is, N=strlen(expression), op	for (i=0, op=1,is=1; i<N && op; i+=1)		strswitch(expression[i,i])			case "-":				is = -1				break			case "+":				is = 1				break			case "x":				m0 = is				is = 1				break			case "y":				m1 = is				is = 1				break			case "z":				m2 = is				is = 1				break			default:					//should be a digit				op=0					// halt loop, and set pointer back				num=str2num(expression[i,Inf])		endswitch	endfor	if (op)								// ran out of things to do, no b		return 0	endif	if (char2num("/")!=char2num(expression[i]))		DoAlert 0, "ERROR"		print "error on expression = ",expression		return 1	endif	b = is * num/str2num(expression[i+1]) // eval the constant	if (numtype(b))		DoAlert 0, "ERROR"		print "error on expression = ",expression		return 1	endif	return 0							// return no-errorEnd//Function testParseOne()//	String expression = "-x+y-2/3"//	Variable m0,m1,m2, b//	ParseOneSymEquation(expression,m0,m1,m2,b)//	print expression,"    ",m0,"  ",m1,"  ",m2,"  ",b//	expression = "x-y"//	ParseOneSymEquation(expression,m0,m1,m2,b)//	print expression,"    ",m0,"  ",m1,"  ",m2,"  ",b//	expression = "-z-1/4"//	ParseOneSymEquation(expression,m0,m1,m2,b)//	print expression,"    ",m0,"  ",m1,"  ",m2,"  ",b//End////////Window Table_symLines() : Table//	PauseUpdate; Silent 1		// building window...//	Edit/W=(5,44,1379,833) numOps.xy,symLines.y//	ModifyTable format(Point)=1,width(Point)=36,alignment(symLines.y)=0,width(symLines.y)=1248//	ModifyTable width(numOps.x)=48,alignment(numOps.d)=1,width(numOps.d)=54//EndMacro//Static Function/T setSymLine(SpaceGroup)	Variable SpaceGroup								// Space Group number [1,230]	if (!(1<=SpaceGroup && SpaceGroup<=230))		// invalid		return ""	endif	Make/N=230/O/T symLines_temp__	Wave/T symLines = symLines_temp__	symLines[0]  = "x,y,z"	symLines[1]  = "x,y,z;-x,-y,-z"	symLines[2]  = "x,y,z;-x,y,-z"	symLines[3]  = "x,y,z;-x,y+1/2,-z"	symLines[4]  = "x,y,z;-x,y,-z;x+1/2,y+1/2,z;-x+1/2,y+1/2,-z"	symLines[5]  = "x,y,z;x,-y,z"	symLines[6]  = "x,y,z;x,-y,z+1/2"	symLines[7]  = "x,y,z;x,-y,z;x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[8]  = "x,y,z;x,-y,z+1/2;x+1/2,y+1/2,z;x+1/2,-y+1/2,z+1/2"	symLines[9]  = "x,y,z;-x,y,-z;-x,-y,-z;x,-y,z"	symLines[10]  = "x,y,z;-x,y+1/2,-z;-x,-y,-z;x,-y+1/2,z"	symLines[11]  = "x,y,z;-x,y,-z;-x,-y,-z;x,-y,z;x+1/2,y+1/2,z;-x+1/2,y+1/2,-z;-x+1/2,-y+1/2,-z;x+1/2,-y+1/2,z"	symLines[12]  = "x,y,z;-x,y,-z+1/2;-x,-y,-z;x,-y,z+1/2"	symLines[13]  = "x,y,z;-x,y+1/2,-z+1/2;-x,-y,-z;x,-y+1/2,z+1/2"	symLines[14]  = "x,y,z;-x,y,-z+1/2;-x,-y,-z;x,-y,z+1/2;x+1/2,y+1/2,z;-x+1/2,y+1/2,-z+1/2;-x+1/2,-y+1/2,-z;x+1/2,-y+1/2,z+1/2"	symLines[15]  = "x,y,z;-x,-y,z;x,-y,-z;-x,y,-z"	symLines[16]  = "x,y,z;-x,-y,z+1/2;x,-y,-z;-x,y,-z+1/2"	symLines[17]  = "x,y,z;-x,-y,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z"	symLines[18]  = "x,y,z;-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z;-x,y+1/2,-z+1/2"	symLines[19]  = "x,y,z;-x,-y,z+1/2;x,-y,-z;-x,y,-z+1/2;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z+1/2;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z+1/2"	symLines[20]  = "x,y,z;-x,-y,z;x,-y,-z;-x,y,-z;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z"	symLines[21]  = "x,y,z;-x,-y,z;x,-y,-z;-x,y,-z;x,y+1/2,z+1/2;-x,-y+1/2,z+1/2;x,-y+1/2,-z+1/2;-x,y+1/2,-z+1/2;x+1/2,y,z+1/2;"	symLines[21] += "-x+1/2,-y,z+1/2;x+1/2,-y,-z+1/2;-x+1/2,y,-z+1/2;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z"	symLines[22]  = "x,y,z;-x,-y,z;x,-y,-z;-x,y,-z;x+1/2,y+1/2,z+1/2;-x+1/2,-y+1/2,z+1/2;x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2"	symLines[23]  = "x,y,z;-x,-y+1/2,z;x,-y,-z+1/2;-x+1/2,y,-z;x+1/2,y+1/2,z+1/2;-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z;-x,y+1/2,-z+1/2"	symLines[24]  = "x,y,z;-x,-y,z;-x,y,z;x,-y,z"	symLines[25]  = "x,y,z;-x,-y,z+1/2;-x,y,z;x,-y,z+1/2"	symLines[26]  = "x,y,z;-x,-y,z;-x,y,z+1/2;x,-y,z+1/2"	symLines[27]  = "x,y,z;-x,-y,z;-x+1/2,y,z;x+1/2,-y,z"	symLines[28]  = "x,y,z;-x,-y,z+1/2;-x+1/2,y,z+1/2;x+1/2,-y,z"	symLines[29]  = "x,y,z;-x,-y,z;-x,y+1/2,z+1/2;x,-y+1/2,z+1/2"	symLines[30]  = "x,y,z;-x+1/2,-y,z+1/2;-x,y,z;x+1/2,-y,z+1/2"	symLines[31]  = "x,y,z;-x,-y,z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[32]  = "x,y,z;-x,-y,z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z"	symLines[33]  = "x,y,z;-x,-y,z;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[34]  = "x,y,z;-x,-y,z;-x,y,z;x,-y,z;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[35]  = "x,y,z;-x,-y,z+1/2;-x,y,z;x,-y,z+1/2;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z+1/2;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z+1/2"	symLines[36]  = "x,y,z;-x,-y,z;-x,y,z+1/2;x,-y,z+1/2;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[37]  = "x,y,z;-x,-y,z;-x,y,z;x,-y,z;x,y+1/2,z+1/2;-x,-y+1/2,z+1/2;-x,y+1/2,z+1/2;x,-y+1/2,z+1/2"	symLines[38]  = "x,y,z;-x,-y,z;-x,y,z+1/2;x,-y,z+1/2;x,y+1/2,z+1/2;-x,-y+1/2,z+1/2;-x,y+1/2,z;x,-y+1/2,z"	symLines[39]  = "x,y,z;-x,-y,z;-x+1/2,y,z;x+1/2,-y,z;x,y+1/2,z+1/2;-x,-y+1/2,z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[40]  = "x,y,z;-x,-y,z;-x+1/2,y,z+1/2;x+1/2,-y,z+1/2;x,y+1/2,z+1/2;-x,-y+1/2,z+1/2;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[41]  = "x,y,z;-x,-y,z;-x,y,z;x,-y,z;x,y+1/2,z+1/2;-x,-y+1/2,z+1/2;-x,y+1/2,z+1/2;x,-y+1/2,z+1/2;x+1/2,y,z+1/2;"	symLines[41] += "-x+1/2,-y,z+1/2;-x+1/2,y,z+1/2;x+1/2,-y,z+1/2;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[42]  = "x,y,z;-x,-y,z;-x+1/4,y+1/4,z+1/4;x+1/4,-y+1/4,z+1/4;x,y+1/2,z+1/2;-x,-y+1/2,z+1/2;-x+1/4,y+3/4,z+3/4;"	symLines[42] += "x+1/4,-y+3/4,z+3/4;x+1/2,y,z+1/2;-x+1/2,-y,z+1/2;-x+3/4,y+1/4,z+3/4;x+3/4,-y+1/4,z+3/4;x+1/2,y+1/2,z;"	symLines[42] += "-x+1/2,-y+1/2,z;-x+3/4,y+3/4,z+1/4;x+3/4,-y+3/4,z+1/4"	symLines[43]  = "x,y,z;-x,-y,z;-x,y,z;x,-y,z;x+1/2,y+1/2,z+1/2;-x+1/2,-y+1/2,z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[44]  = "x,y,z;-x,-y,z;-x,y,z+1/2;x,-y,z+1/2;x+1/2,y+1/2,z+1/2;-x+1/2,-y+1/2,z+1/2;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[45]  = "x,y,z;-x,-y,z;-x+1/2,y,z;x+1/2,-y,z;x+1/2,y+1/2,z+1/2;-x+1/2,-y+1/2,z+1/2;-x,y+1/2,z+1/2;x,-y+1/2,z+1/2"	symLines[46]  = "x,y,z;-x,-y,z;x,-y,-z;-x,y,-z;-x,-y,-z;x,y,-z;-x,y,z;x,-y,z"	symLines[47]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;-x,-y,z;x,-y,-z;-x,y,-z;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[48]  = "x,y,z;-x,-y,z;x,-y,-z+1/2;-x,y,-z+1/2;-x,-y,-z;x,y,-z;-x,y,z+1/2;x,-y,z+1/2"	symLines[49]  = "x,y,z;-x+1/2,-y+1/2,-z;-x,-y,z;x,-y,-z;-x,y,-z;x+1/2,y+1/2,-z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[50]  = "x,y,z;-x+1/2,-y,z;x+1/2,-y,-z;-x,y,-z;-x,-y,-z;x+1/2,y,-z;-x+1/2,y,z;x,-y,z"	symLines[51]  = "x,y,z;-x+1/2,-y,z;x,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;-x,-y,-z;x+1/2,y,-z;-x,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[52]  = "x,y,z;-x+1/2,-y,z+1/2;x,-y,-z;-x+1/2,y,-z+1/2;-x,-y,-z;x+1/2,y,-z+1/2;-x,y,z;x+1/2,-y,z+1/2"	symLines[53]  = "x,y,z;-x+1/2,-y,z;x+1/2,-y,-z+1/2;-x,y,-z+1/2;-x,-y,-z;x+1/2,y,-z;-x+1/2,y,z+1/2;x,-y,z+1/2"	symLines[54]  = "x,y,z;-x,-y,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;-x,-y,-z;x,y,-z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[55]  = "x,y,z;-x+1/2,-y+1/2,z;x+1/2,-y,-z+1/2;-x,y+1/2,-z+1/2;-x,-y,-z;x+1/2,y+1/2,-z;-x+1/2,y,z+1/2;x,-y+1/2,z+1/2"	symLines[56]  = "x,y,z;-x,-y,z+1/2;x,-y+1/2,-z;-x,y+1/2,-z+1/2;-x,-y,-z;x,y,-z+1/2;-x,y+1/2,z;x,-y+1/2,z+1/2"	symLines[57]  = "x,y,z;-x,-y,z;x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;-x,-y,-z;x,y,-z;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[58]  = "x,y,z;-x+1/2,-y+1/2,-z;-x,-y,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;x+1/2,y+1/2,-z;-x,y,z;x,-y,z"	symLines[59]  = "x,y,z;-x+1/2,-y+1/2,z+1/2;x+1/2,-y+1/2,-z;-x,y,-z+1/2;-x,-y,-z;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z;x,-y,z+1/2"	symLines[60]  = "x,y,z;-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z;-x,y+1/2,-z+1/2;-x,-y,-z;x+1/2,y,-z+1/2;-x+1/2,y+1/2,z;x,-y+1/2,z+1/2"	symLines[61]  = "x,y,z;-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z+1/2;-x,y+1/2,-z;-x,-y,-z;x+1/2,y,-z+1/2;-x+1/2,y+1/2,z+1/2;x,-y+1/2,z"	symLines[62]  = "x,y,z;-x,-y,z+1/2;x,-y,-z;-x,y,-z+1/2;-x,-y,-z;x,y,-z+1/2;-x,y,z;x,-y,z+1/2;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z+1/2;"	symLines[62] += "x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z+1/2;-x+1/2,-y+1/2,-z;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z+1/2"	symLines[63]  = "x,y,z;-x,-y+1/2,z+1/2;x,-y,-z;-x,y+1/2,-z+1/2;-x,-y,-z;x,y+1/2,-z+1/2;-x,y,z;x,-y+1/2,z+1/2;x+1/2,y+1/2,z;"	symLines[63] += "-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z;-x+1/2,y,-z+1/2;-x+1/2,-y+1/2,-z;x+1/2,y,-z+1/2;-x+1/2,y+1/2,z;x+1/2,-y,z+1/2"	symLines[64]  = "x,y,z;-x,-y,z;x,-y,-z;-x,y,-z;-x,-y,-z;x,y,-z;-x,y,z;x,-y,z;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z;x+1/2,-y+1/2,-z;"	symLines[64] += "-x+1/2,y+1/2,-z;-x+1/2,-y+1/2,-z;x+1/2,y+1/2,-z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[65]  = "x,y,z;-x,-y,z;x,-y,-z+1/2;-x,y,-z+1/2;-x,-y,-z;x,y,-z;-x,y,z+1/2;x,-y,z+1/2;x+1/2,y+1/2,z;-x+1/2,-y+1/2,z;"	symLines[65] += "x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;-x+1/2,-y+1/2,-z;x+1/2,y+1/2,-z;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[66]  = "x,y,z;-x,-y+1/2,z;x,-y,-z;-x,y+1/2,-z;-x,-y,-z;x,y+1/2,-z;-x,y,z;x,-y+1/2,z;x+1/2,y+1/2,z;-x+1/2,-y,z;"	symLines[66] += "x+1/2,-y+1/2,-z;-x+1/2,y,-z;-x+1/2,-y+1/2,-z;x+1/2,y,-z;-x+1/2,y+1/2,z;x+1/2,-y,z"	symLines[67]  = "x,y,z;-x,-y+1/2,-z+1/2;-x,-y,z;x,-y,-z;-x,y,-z;x,y+1/2,-z+1/2;-x,y+1/2,z+1/2;x,-y+1/2,z+1/2;x+1/2,y+1/2,z;"	symLines[67] += "-x+1/2,-y,-z+1/2;-x+1/2,-y+1/2,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;x+1/2,y,-z+1/2;-x+1/2,y,z+1/2;x+1/2,-y,z+1/2"	symLines[68]  = "x,y,z;-x,-y,z;x,-y,-z;-x,y,-z;-x,-y,-z;x,y,-z;-x,y,z;x,-y,z;x,y+1/2,z+1/2;-x,-y+1/2,z+1/2;x,-y+1/2,-z+1/2;"	symLines[68] += "-x,y+1/2,-z+1/2;-x,-y+1/2,-z+1/2;x,y+1/2,-z+1/2;-x,y+1/2,z+1/2;x,-y+1/2,z+1/2;x+1/2,y,z+1/2;-x+1/2,-y,z+1/2;"	symLines[68] += "x+1/2,-y,-z+1/2;-x+1/2,y,-z+1/2;-x+1/2,-y,-z+1/2;x+1/2,y,-z+1/2;-x+1/2,y,z+1/2;x+1/2,-y,z+1/2;x+1/2,y+1/2,z;"	symLines[68] += "-x+1/2,-y+1/2,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;-x+1/2,-y+1/2,-z;x+1/2,y+1/2,-z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[69]  = "x,y,z;-x+1/4,-y+1/4,-z+1/4;-x,-y,z;x,-y,-z;-x,y,-z;x+1/4,y+1/4,-z+1/4;-x+1/4,y+1/4,z+1/4;x+1/4,-y+1/4,z+1/4;"	symLines[69] += "x,y+1/2,z+1/2;-x+1/4,-y+3/4,-z+3/4;-x,-y+1/2,z+1/2;x,-y+1/2,-z+1/2;-x,y+1/2,-z+1/2;x+1/4,y+3/4,-z+3/4;"	symLines[69] += "-x+1/4,y+3/4,z+3/4;x+1/4,-y+3/4,z+3/4;x+1/2,y,z+1/2;-x+3/4,-y+1/4,-z+3/4;-x+1/2,-y,z+1/2;x+1/2,-y,-z+1/2;"	symLines[69] += "-x+1/2,y,-z+1/2;x+3/4,y+1/4,-z+3/4;-x+3/4,y+1/4,z+3/4;x+3/4,-y+1/4,z+3/4;x+1/2,y+1/2,z;-x+3/4,-y+3/4,-z+1/4;"	symLines[69] += "-x+1/2,-y+1/2,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;x+3/4,y+3/4,-z+1/4;-x+3/4,y+3/4,z+1/4;x+3/4,-y+3/4,z+1/4"	symLines[70]  = "x,y,z;-x,-y,z;x,-y,-z;-x,y,-z;-x,-y,-z;x,y,-z;-x,y,z;x,-y,z;x+1/2,y+1/2,z+1/2;-x+1/2,-y+1/2,z+1/2;"	symLines[70] += "x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;-x+1/2,-y+1/2,-z+1/2;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;"	symLines[70] += "x+1/2,-y+1/2,z+1/2"	symLines[71]  = "x,y,z;-x,-y,z;x,-y,-z+1/2;-x,y,-z+1/2;-x,-y,-z;x,y,-z;-x,y,z+1/2;x,-y,z+1/2;x+1/2,y+1/2,z+1/2;"	symLines[71] += "-x+1/2,-y+1/2,z+1/2;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;-x+1/2,-y+1/2,-z+1/2;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z;"	symLines[71] += "x+1/2,-y+1/2,z"	symLines[72]  = "x,y,z;-x,-y+1/2,z;x,-y,-z+1/2;-x+1/2,y,-z;-x,-y,-z;x,y+1/2,-z;-x,y,z+1/2;x+1/2,-y,z;x+1/2,y+1/2,z+1/2;"	symLines[72] += "-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z;-x,y+1/2,-z+1/2;-x+1/2,-y+1/2,-z+1/2;x+1/2,y,-z+1/2;-x+1/2,y+1/2,z;"	symLines[72] += "x,-y+1/2,z+1/2"	symLines[73]  = "x,y,z;-x,-y+1/2,z;x,-y,-z;-x,y+1/2,-z;-x,-y,-z;x,y+1/2,-z;-x,y,z;x,-y+1/2,z;x+1/2,y+1/2,z+1/2;-x+1/2,-y,z+1/2;"	symLines[73] += "x+1/2,-y+1/2,-z+1/2;-x+1/2,y,-z+1/2;-x+1/2,-y+1/2,-z+1/2;x+1/2,y,-z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y,z+1/2"	symLines[74]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z"	symLines[75]  = "x,y,z;-y,x,z+1/4;-x,-y,z+1/2;y,-x,z+3/4"	symLines[76]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2"	symLines[77]  = "x,y,z;-y,x,z+3/4;-x,-y,z+1/2;y,-x,z+1/4"	symLines[78]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x+1/2,y+1/2,z+1/2;-y+1/2,x+1/2,z+1/2;-x+1/2,-y+1/2,z+1/2;y+1/2,-x+1/2,z+1/2"	symLines[79]  = "x,y,z;-y,x+1/2,z+1/4;-x,-y,z;y,-x+1/2,z+1/4;x+1/2,y+1/2,z+1/2;-y+1/2,x,z+3/4;-x+1/2,-y+1/2,z+1/2;y+1/2,-x,z+3/4"	symLines[80]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z"	symLines[81]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;x+1/2,y+1/2,z+1/2;y+1/2,-x+1/2,-z+1/2;-x+1/2,-y+1/2,z+1/2;-y+1/2,x+1/2,-z+1/2"	symLines[82]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z"	symLines[83]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2;-x,-y,-z;y,-x,-z+1/2;x,y,-z;-y,x,-z+1/2"	symLines[84]  = "x,y,z;-x+1/2,-y+1/2,-z;-y+1/2,x+1/2,z;-x,-y,z;y+1/2,-x+1/2,z;y,-x,-z;-y,x,-z;x+1/2,y+1/2,-z"	symLines[85]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;y,-x,-z;-y,x,-z;x+1/2,y+1/2,-z+1/2"	symLines[86]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z;x+1/2,y+1/2,z+1/2;-y+1/2,x+1/2,z+1/2;"	symLines[86] += "-x+1/2,-y+1/2,z+1/2;y+1/2,-x+1/2,z+1/2;-x+1/2,-y+1/2,-z+1/2;y+1/2,-x+1/2,-z+1/2;x+1/2,y+1/2,-z+1/2;"	symLines[86] += "-y+1/2,x+1/2,-z+1/2"	symLines[87]  = "x,y,z;-x,-y+1/2,-z+1/4;-y,x+1/2,z+1/4;-x,-y,z;y,-x+1/2,z+1/4;y,-x,-z;-y,x,-z;x,y+1/2,-z+1/4;x+1/2,y+1/2,z+1/2;"	symLines[87] += "-x+1/2,-y,-z+3/4;-y+1/2,x,z+3/4;-x+1/2,-y+1/2,z+1/2;y+1/2,-x,z+3/4;y+1/2,-x+1/2,-z+1/2;-y+1/2,x+1/2,-z+1/2;"	symLines[87] += "x+1/2,y,-z+3/4"	symLines[88]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-y,-z;-x,y,-z;y,x,-z;-y,-x,-z"	symLines[89]  = "x,y,z;-y+1/2,x+1/2,z;-x,-y,z;y+1/2,-x+1/2,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;y,x,-z;-y,-x,-z"	symLines[90]  = "x,y,z;-y,x,z+1/4;-x,-y,z+1/2;y,-x,z+3/4;x,-y,-z+1/2;-x,y,-z;y,x,-z+3/4;-y,-x,-z+1/4"	symLines[91]  = "x,y,z;-y+1/2,x+1/2,z+1/4;-x,-y,z+1/2;y+1/2,-x+1/2,z+3/4;x+1/2,-y+1/2,-z+3/4;-x+1/2,y+1/2,-z+1/4;y,x,-z;-y,-x,-z+1/2"	symLines[92]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2;x,-y,-z;-x,y,-z;y,x,-z+1/2;-y,-x,-z+1/2"	symLines[93]  = "x,y,z;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;y,x,-z;-y,-x,-z"	symLines[94]  = "x,y,z;-y,x,z+3/4;-x,-y,z+1/2;y,-x,z+1/4;x,-y,-z+1/2;-x,y,-z;y,x,-z+1/4;-y,-x,-z+3/4"	symLines[95]  = "x,y,z;-y+1/2,x+1/2,z+3/4;-x,-y,z+1/2;y+1/2,-x+1/2,z+1/4;x+1/2,-y+1/2,-z+1/4;-x+1/2,y+1/2,-z+3/4;y,x,-z;-y,-x,-z+1/2"	symLines[96]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-y,-z;-x,y,-z;y,x,-z;-y,-x,-z;x+1/2,y+1/2,z+1/2;-y+1/2,x+1/2,z+1/2;"	symLines[96] += "-x+1/2,-y+1/2,z+1/2;y+1/2,-x+1/2,z+1/2;x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;y+1/2,x+1/2,-z+1/2;"	symLines[96] += "-y+1/2,-x+1/2,-z+1/2"	symLines[97]  = "x,y,z;-y,x+1/2,z+1/4;-x,-y,z;y,-x+1/2,z+1/4;x,-y+1/2,-z+1/4;-x,y+1/2,-z+1/4;y,x,-z;-y,-x,-z;x+1/2,y+1/2,z+1/2;"	symLines[97] += "-y+1/2,x,z+3/4;-x+1/2,-y+1/2,z+1/2;y+1/2,-x,z+3/4;x+1/2,-y,-z+3/4;-x+1/2,y,-z+3/4;y+1/2,x+1/2,-z+1/2;"	symLines[97] += "-y+1/2,-x+1/2,-z+1/2"	symLines[98]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;-x,y,z;x,-y,z;-y,-x,z;y,x,z"	symLines[99]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z"	symLines[100]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2;-x,y,z+1/2;x,-y,z+1/2;-y,-x,z;y,x,z"	symLines[101]  = "x,y,z;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y,-x,z;y,x,z"	symLines[102]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;-x,y,z+1/2;x,-y,z+1/2;-y,-x,z+1/2;y,x,z+1/2"	symLines[103]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2"	symLines[104]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2;-x,y,z;x,-y,z;-y,-x,z+1/2;y,x,z+1/2"	symLines[105]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2"	symLines[106]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;-x,y,z;x,-y,z;-y,-x,z;y,x,z;x+1/2,y+1/2,z+1/2;-y+1/2,x+1/2,z+1/2;"	symLines[106] += "-x+1/2,-y+1/2,z+1/2;y+1/2,-x+1/2,z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y+1/2,-x+1/2,z+1/2;"	symLines[106] += "y+1/2,x+1/2,z+1/2"	symLines[107]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;-x,y,z+1/2;x,-y,z+1/2;-y,-x,z+1/2;y,x,z+1/2;x+1/2,y+1/2,z+1/2;-y+1/2,x+1/2,z+1/2;"	symLines[107] += "-x+1/2,-y+1/2,z+1/2;y+1/2,-x+1/2,z+1/2;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z"	symLines[108]  = "x,y,z;-y,x+1/2,z+1/4;-x,-y,z;y,-x+1/2,z+1/4;-x,y,z;x,-y,z;-y,-x+1/2,z+1/4;y,x+1/2,z+1/4;x+1/2,y+1/2,z+1/2;"	symLines[108] += "-y+1/2,x,z+3/4;-x+1/2,-y+1/2,z+1/2;y+1/2,-x,z+3/4;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y+1/2,-x,z+3/4;"	symLines[108] += "y+1/2,x,z+3/4"	symLines[109]  = "x,y,z;-y,x+1/2,z+1/4;-x,-y,z;y,-x+1/2,z+1/4;-x,y,z+1/2;x,-y,z+1/2;-y+1/2,-x,z+1/4;y+1/2,x,z+1/4;"	symLines[109] += "x+1/2,y+1/2,z+1/2;-y+1/2,x,z+3/4;-x+1/2,-y+1/2,z+1/2;y+1/2,-x,z+3/4;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;"	symLines[109] += "-y,-x+1/2,z+3/4;y,x+1/2,z+3/4"	symLines[110]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;x,-y,-z;-x,y,-z;-y,-x,z;y,x,z"	symLines[111]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;x,-y,-z+1/2;-x,y,-z+1/2;-y,-x,z+1/2;y,x,z+1/2"	symLines[112]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z"	symLines[113]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2"	symLines[114]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;y,x,-z;-y,-x,-z;-x,y,z;x,-y,z"	symLines[115]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;y,x,-z+1/2;-y,-x,-z+1/2;-x,y,z+1/2;x,-y,z+1/2"	symLines[116]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;y+1/2,x+1/2,-z;-y+1/2,-x+1/2,-z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[117]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[118]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;y,x,-z;-y,-x,-z;-x,y,z;x,-y,z;x+1/2,y+1/2,z+1/2;y+1/2,-x+1/2,-z+1/2;"	symLines[118] += "-x+1/2,-y+1/2,z+1/2;-y+1/2,x+1/2,-z+1/2;y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;"	symLines[118] += "x+1/2,-y+1/2,z+1/2"	symLines[119]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;y,x,-z+1/2;-y,-x,-z+1/2;-x,y,z+1/2;x,-y,z+1/2;x+1/2,y+1/2,z+1/2;"	symLines[119] += "y+1/2,-x+1/2,-z+1/2;-x+1/2,-y+1/2,z+1/2;-y+1/2,x+1/2,-z+1/2;y+1/2,x+1/2,-z;-y+1/2,-x+1/2,-z;-x+1/2,y+1/2,z;"	symLines[119] += "x+1/2,-y+1/2,z"	symLines[120]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;x,-y,-z;-x,y,-z;-y,-x,z;y,x,z;x+1/2,y+1/2,z+1/2;y+1/2,-x+1/2,-z+1/2;"	symLines[120] += "-x+1/2,-y+1/2,z+1/2;-y+1/2,x+1/2,-z+1/2;x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;-y+1/2,-x+1/2,z+1/2;"	symLines[120] += "y+1/2,x+1/2,z+1/2"	symLines[121]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;x,-y+1/2,-z+1/4;-x,y+1/2,-z+1/4;-y,-x+1/2,z+1/4;y,x+1/2,z+1/4;x+1/2,y+1/2,z+1/2;"	symLines[121] += "y+1/2,-x+1/2,-z+1/2;-x+1/2,-y+1/2,z+1/2;-y+1/2,x+1/2,-z+1/2;x+1/2,-y,-z+3/4;-x+1/2,y,-z+3/4;-y+1/2,-x,z+3/4;"	symLines[121] += "y+1/2,x,z+3/4"	symLines[122]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-y,-z;-x,y,-z;y,x,-z;-y,-x,-z;-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z;-x,y,z;x,-y,z;-y,-x,z;y,x,z"	symLines[123]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-y,-z+1/2;-x,y,-z+1/2;y,x,-z+1/2;-y,-x,-z+1/2;-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z;"	symLines[123] += "-x,y,z+1/2;x,-y,z+1/2;-y,-x,z+1/2;y,x,z+1/2"	symLines[124]  = "x,y,z;-x+1/2,-y+1/2,-z;-y,x,z;-x,-y,z;y,-x,z;y+1/2,-x+1/2,-z;-y+1/2,x+1/2,-z;x,-y,-z;-x,y,-z;y,x,-z;-y,-x,-z;"	symLines[124] += "x+1/2,y+1/2,-z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z"	symLines[125]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;-y,x,z;-x,-y,z;y,-x,z;y+1/2,-x+1/2,-z+1/2;-y+1/2,x+1/2,-z+1/2;x,-y,-z;-x,y,-z;"	symLines[125] += "y,x,-z;-y,-x,-z;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2"	symLines[126]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;y+1/2,x+1/2,-z;-y+1/2,-x+1/2,-z;-x,-y,-z;y,-x,-z;"	symLines[126] += "x,y,-z;-y,x,-z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z"	symLines[127]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;"	symLines[127] += "-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2"	symLines[128]  = "x,y,z;-x+1/2,-y+1/2,-z;-y+1/2,x+1/2,z;-x,-y,z;y+1/2,-x+1/2,z;y,-x,-z;-y,x,-z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;"	symLines[128] += "y,x,-z;-y,-x,-z;x+1/2,y+1/2,-z;-x,y,z;x,-y,z;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z"	symLines[129]  = "x,y,z;-x+1/2,-y+1/2,-z;-y+1/2,x+1/2,z;-x,-y,z;y+1/2,-x+1/2,z;y,-x,-z;-y,x,-z;x+1/2,-y+1/2,-z+1/2;"	symLines[129] += "-x+1/2,y+1/2,-z+1/2;y,x,-z+1/2;-y,-x,-z+1/2;x+1/2,y+1/2,-z;-x,y,z+1/2;x,-y,z+1/2;-y+1/2,-x+1/2,z+1/2;"	symLines[129] += "y+1/2,x+1/2,z+1/2"	symLines[130]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2;x,-y,-z;-x,y,-z;y,x,-z+1/2;-y,-x,-z+1/2;-x,-y,-z;y,-x,-z+1/2;x,y,-z;"	symLines[130] += "-y,x,-z+1/2;-x,y,z;x,-y,z;-y,-x,z+1/2;y,x,z+1/2"	symLines[131]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2;x,-y,-z+1/2;-x,y,-z+1/2;y,x,-z;-y,-x,-z;-x,-y,-z;y,-x,-z+1/2;x,y,-z;"	symLines[131] += "-y,x,-z+1/2;-x,y,z+1/2;x,-y,z+1/2;-y,-x,z;y,x,z"	symLines[132]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;y,-x,-z;-y,x,-z;x,-y,-z+1/2;"	symLines[132] += "-x,y,-z+1/2;y+1/2,x+1/2,-z;-y+1/2,-x+1/2,-z;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;-y,-x,z+1/2;"	symLines[132] += "y,x,z+1/2"	symLines[133]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;y,-x,-z;-y,x,-z;x,-y,-z;-x,y,-z;"	symLines[133] += "y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y,-x,z;y,x,z"	symLines[134]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;"	symLines[134] += "-x,-y,-z;y,-x,-z+1/2;x,y,-z;-y,x,-z+1/2;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2"	symLines[135]  = "x,y,z;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;y,x,-z;-y,-x,-z;"	symLines[135] += "-x,-y,-z;y+1/2,-x+1/2,-z+1/2;x,y,-z;-y+1/2,x+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y,-x,z;y,x,z"	symLines[136]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;y,-x,-z;-y,x,-z;x+1/2,-y+1/2,-z+1/2;"	symLines[136] += "-x+1/2,y+1/2,-z+1/2;y,x,-z;-y,-x,-z;x+1/2,y+1/2,-z+1/2;-x,y,z;x,-y,z;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2"	symLines[137]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;y,-x,-z;-y,x,-z;x+1/2,-y+1/2,-z;"	symLines[137] += "-x+1/2,y+1/2,-z;y,x,-z+1/2;-y,-x,-z+1/2;x+1/2,y+1/2,-z+1/2;-x,y,z+1/2;x,-y,z+1/2;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z"	symLines[138]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-y,-z;-x,y,-z;y,x,-z;-y,-x,-z;-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z;-x,y,z;x,-y,z;"	symLines[138] += "-y,-x,z;y,x,z;x+1/2,y+1/2,z+1/2;-y+1/2,x+1/2,z+1/2;-x+1/2,-y+1/2,z+1/2;y+1/2,-x+1/2,z+1/2;x+1/2,-y+1/2,-z+1/2;"	symLines[138] += "-x+1/2,y+1/2,-z+1/2;y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;-x+1/2,-y+1/2,-z+1/2;y+1/2,-x+1/2,-z+1/2;"	symLines[138] += "x+1/2,y+1/2,-z+1/2;-y+1/2,x+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y+1/2,-x+1/2,z+1/2;"	symLines[138] += "y+1/2,x+1/2,z+1/2"	symLines[139]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-y,-z+1/2;-x,y,-z+1/2;y,x,-z+1/2;-y,-x,-z+1/2;-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z;"	symLines[139] += "-x,y,z+1/2;x,-y,z+1/2;-y,-x,z+1/2;y,x,z+1/2;x+1/2,y+1/2,z+1/2;-y+1/2,x+1/2,z+1/2;-x+1/2,-y+1/2,z+1/2;"	symLines[139] += "y+1/2,-x+1/2,z+1/2;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;y+1/2,x+1/2,-z;-y+1/2,-x+1/2,-z;-x+1/2,-y+1/2,-z+1/2;"	symLines[139] += "y+1/2,-x+1/2,-z+1/2;x+1/2,y+1/2,-z+1/2;-y+1/2,x+1/2,-z+1/2;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;-y+1/2,-x+1/2,z;"	symLines[139] += "y+1/2,x+1/2,z"	symLines[140]  = "x,y,z;-x,-y+1/2,-z+1/4;-y,x+1/2,z+1/4;-x,-y,z;y,-x+1/2,z+1/4;y,-x,-z;-y,x,-z;x,-y+1/2,-z+1/4;-x,y+1/2,-z+1/4;"	symLines[140] += "y,x,-z;-y,-x,-z;x,y+1/2,-z+1/4;-x,y,z;x,-y,z;-y,-x+1/2,z+1/4;y,x+1/2,z+1/4;x+1/2,y+1/2,z+1/2;-x+1/2,-y,-z+3/4;"	symLines[140] += "-y+1/2,x,z+3/4;-x+1/2,-y+1/2,z+1/2;y+1/2,-x,z+3/4;y+1/2,-x+1/2,-z+1/2;-y+1/2,x+1/2,-z+1/2;x+1/2,-y,-z+3/4;"	symLines[140] += "-x+1/2,y,-z+3/4;y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;x+1/2,y,-z+3/4;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;"	symLines[140] += "-y+1/2,-x,z+3/4;y+1/2,x,z+3/4"	symLines[141]  = "x,y,z;-x,-y+1/2,-z+1/4;-y,x+1/2,z+1/4;-x,-y,z;y,-x+1/2,z+1/4;y,-x,-z;-y,x,-z;x+1/2,-y,-z+1/4;-x+1/2,y,-z+1/4;"	symLines[141] += "y,x,-z+1/2;-y,-x,-z+1/2;x,y+1/2,-z+1/4;-x,y,z+1/2;x,-y,z+1/2;-y+1/2,-x,z+1/4;y+1/2,x,z+1/4;x+1/2,y+1/2,z+1/2;"	symLines[141] += "-x+1/2,-y,-z+3/4;-y+1/2,x,z+3/4;-x+1/2,-y+1/2,z+1/2;y+1/2,-x,z+3/4;y+1/2,-x+1/2,-z+1/2;-y+1/2,x+1/2,-z+1/2;"	symLines[141] += "x,-y+1/2,-z+3/4;-x,y+1/2,-z+3/4;y+1/2,x+1/2,-z;-y+1/2,-x+1/2,-z;x+1/2,y,-z+3/4;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z;"	symLines[141] += "-y,-x+1/2,z+3/4;y,x+1/2,z+3/4"	symLines[142]  = "x,y,z;-y,x-y,z;-x+y,-x,z"	symLines[143]  = "x,y,z;-y,x-y,z+1/3;-x+y,-x,z+2/3"	symLines[144]  = "x,y,z;-y,x-y,z+2/3;-x+y,-x,z+1/3"	symLines[145]  = "x,y,z;-y,x-y,z;-x+y,-x,z;x+2/3,y+1/3,z+1/3;-y+2/3,x-y+1/3,z+1/3;-x+y+2/3,-x+1/3,z+1/3;x+1/3,y+2/3,z+2/3;"	symLines[145] += "-y+1/3,x-y+2/3,z+2/3;-x+y+1/3,-x+2/3,z+2/3"	symLines[146]  = "x,y,z;-y,x-y,z;-x+y,-x,z;-x,-y,-z;y,-x+y,-z;x-y,x,-z"	symLines[147]  = "x,y,z;-y,x-y,z;-x+y,-x,z;-x,-y,-z;y,-x+y,-z;x-y,x,-z;x+2/3,y+1/3,z+1/3;-y+2/3,x-y+1/3,z+1/3;"	symLines[147] += "-x+y+2/3,-x+1/3,z+1/3;-x+2/3,-y+1/3,-z+1/3;y+2/3,-x+y+1/3,-z+1/3;x-y+2/3,x+1/3,-z+1/3;x+1/3,y+2/3,z+2/3;"	symLines[147] += "-y+1/3,x-y+2/3,z+2/3;-x+y+1/3,-x+2/3,z+2/3;-x+1/3,-y+2/3,-z+2/3;y+1/3,-x+y+2/3,-z+2/3;x-y+1/3,x+2/3,-z+2/3"	symLines[148]  = "x,y,z;-y,x-y,z;-x+y,-x,z;-y,-x,-z;-x+y,y,-z;x,x-y,-z"	symLines[149]  = "x,y,z;-y,x-y,z;-x+y,-x,z;x-y,-y,-z;-x,-x+y,-z;y,x,-z"	symLines[150]  = "x,y,z;-y,x-y,z+1/3;-x+y,-x,z+2/3;-y,-x,-z+2/3;-x+y,y,-z+1/3;x,x-y,-z"	symLines[151]  = "x,y,z;-y,x-y,z+1/3;-x+y,-x,z+2/3;x-y,-y,-z+2/3;-x,-x+y,-z+1/3;y,x,-z"	symLines[152]  = "x,y,z;-y,x-y,z+2/3;-x+y,-x,z+1/3;-y,-x,-z+1/3;-x+y,y,-z+2/3;x,x-y,-z"	symLines[153]  = "x,y,z;-y,x-y,z+2/3;-x+y,-x,z+1/3;x-y,-y,-z+1/3;-x,-x+y,-z+2/3;y,x,-z"	symLines[154]  = "x,y,z;-y,x-y,z;-x+y,-x,z;x-y,-y,-z;-x,-x+y,-z;y,x,-z;x+2/3,y+1/3,z+1/3;-y+2/3,x-y+1/3,z+1/3;"	symLines[154] += "-x+y+2/3,-x+1/3,z+1/3;x-y+2/3,-y+1/3,-z+1/3;-x+2/3,-x+y+1/3,-z+1/3;y+2/3,x+1/3,-z+1/3;x+1/3,y+2/3,z+2/3;"	symLines[154] += "-y+1/3,x-y+2/3,z+2/3;-x+y+1/3,-x+2/3,z+2/3;x-y+1/3,-y+2/3,-z+2/3;-x+1/3,-x+y+2/3,-z+2/3;y+1/3,x+2/3,-z+2/3"	symLines[155]  = "x,y,z;-y,x-y,z;-x+y,-x,z;-x+y,y,z;x,x-y,z;-y,-x,z"	symLines[156]  = "x,y,z;-y,x-y,z;-x+y,-x,z;y,x,z;x-y,-y,z;-x,-x+y,z"	symLines[157]  = "x,y,z;-y,x-y,z;-x+y,-x,z;-x+y,y,z+1/2;x,x-y,z+1/2;-y,-x,z+1/2"	symLines[158]  = "x,y,z;-y,x-y,z;-x+y,-x,z;y,x,z+1/2;x-y,-y,z+1/2;-x,-x+y,z+1/2"	symLines[159]  = "x,y,z;-y,x-y,z;-x+y,-x,z;-x+y,y,z;x,x-y,z;-y,-x,z;x+2/3,y+1/3,z+1/3;-y+2/3,x-y+1/3,z+1/3;-x+y+2/3,-x+1/3,z+1/3;"	symLines[159] += "-x+y+2/3,y+1/3,z+1/3;x+2/3,x-y+1/3,z+1/3;-y+2/3,-x+1/3,z+1/3;x+1/3,y+2/3,z+2/3;-y+1/3,x-y+2/3,z+2/3;"	symLines[159] += "-x+y+1/3,-x+2/3,z+2/3;-x+y+1/3,y+2/3,z+2/3;x+1/3,x-y+2/3,z+2/3;-y+1/3,-x+2/3,z+2/3"	symLines[160]  = "x,y,z;-y,x-y,z;-x+y,-x,z;-x+y,y,z+1/2;x,x-y,z+1/2;-y,-x,z+1/2;x+2/3,y+1/3,z+1/3;-y+2/3,x-y+1/3,z+1/3;"	symLines[160] += "-x+y+2/3,-x+1/3,z+1/3;-x+y+2/3,y+1/3,z+5/6;x+2/3,x-y+1/3,z+5/6;-y+2/3,-x+1/3,z+5/6;x+1/3,y+2/3,z+2/3;"	symLines[160] += "-y+1/3,x-y+2/3,z+2/3;-x+y+1/3,-x+2/3,z+2/3;-x+y+1/3,y+2/3,z+1/6;x+1/3,x-y+2/3,z+1/6;-y+1/3,-x+2/3,z+1/6"	symLines[161]  = "x,y,z;-y,x-y,z;-x+y,-x,z;-y,-x,-z;-x+y,y,-z;x,x-y,-z;-x,-y,-z;y,-x+y,-z;x-y,x,-z;y,x,z;x-y,-y,z;-x,-x+y,z"	symLines[162]  = "x,y,z;-y,x-y,z;-x+y,-x,z;-y,-x,-z+1/2;-x+y,y,-z+1/2;x,x-y,-z+1/2;-x,-y,-z;y,-x+y,-z;x-y,x,-z;y,x,z+1/2;"	symLines[162] += "x-y,-y,z+1/2;-x,-x+y,z+1/2"	symLines[163]  = "x,y,z;-y,x-y,z;-x+y,-x,z;x-y,-y,-z;-x,-x+y,-z;y,x,-z;-x,-y,-z;y,-x+y,-z;x-y,x,-z;-x+y,y,z;x,x-y,z;-y,-x,z"	symLines[164]  = "x,y,z;-y,x-y,z;-x+y,-x,z;x-y,-y,-z+1/2;-x,-x+y,-z+1/2;y,x,-z+1/2;-x,-y,-z;y,-x+y,-z;x-y,x,-z;-x+y,y,z+1/2;"	symLines[164] += "x,x-y,z+1/2;-y,-x,z+1/2"	symLines[165]  = "x,y,z;-y,x-y,z;-x+y,-x,z;x-y,-y,-z;-x,-x+y,-z;y,x,-z;-x,-y,-z;y,-x+y,-z;x-y,x,-z;-x+y,y,z;x,x-y,z;-y,-x,z;"	symLines[165] += "x+2/3,y+1/3,z+1/3;-y+2/3,x-y+1/3,z+1/3;-x+y+2/3,-x+1/3,z+1/3;x-y+2/3,-y+1/3,-z+1/3;-x+2/3,-x+y+1/3,-z+1/3;"	symLines[165] += "y+2/3,x+1/3,-z+1/3;-x+2/3,-y+1/3,-z+1/3;y+2/3,-x+y+1/3,-z+1/3;x-y+2/3,x+1/3,-z+1/3;-x+y+2/3,y+1/3,z+1/3;"	symLines[165] += "x+2/3,x-y+1/3,z+1/3;-y+2/3,-x+1/3,z+1/3;x+1/3,y+2/3,z+2/3;-y+1/3,x-y+2/3,z+2/3;-x+y+1/3,-x+2/3,z+2/3;"	symLines[165] += "x-y+1/3,-y+2/3,-z+2/3;-x+1/3,-x+y+2/3,-z+2/3;y+1/3,x+2/3,-z+2/3;-x+1/3,-y+2/3,-z+2/3;y+1/3,-x+y+2/3,-z+2/3;"	symLines[165] += "x-y+1/3,x+2/3,-z+2/3;-x+y+1/3,y+2/3,z+2/3;x+1/3,x-y+2/3,z+2/3;-y+1/3,-x+2/3,z+2/3"	symLines[166]  = "x,y,z;-y,x-y,z;-x+y,-x,z;x-y,-y,-z+1/2;-x,-x+y,-z+1/2;y,x,-z+1/2;-x,-y,-z;y,-x+y,-z;x-y,x,-z;-x+y,y,z+1/2;"	symLines[166] += "x,x-y,z+1/2;-y,-x,z+1/2;x+2/3,y+1/3,z+1/3;-y+2/3,x-y+1/3,z+1/3;-x+y+2/3,-x+1/3,z+1/3;x-y+2/3,-y+1/3,-z+5/6;"	symLines[166] += "-x+2/3,-x+y+1/3,-z+5/6;y+2/3,x+1/3,-z+5/6;-x+2/3,-y+1/3,-z+1/3;y+2/3,-x+y+1/3,-z+1/3;x-y+2/3,x+1/3,-z+1/3;"	symLines[166] += "-x+y+2/3,y+1/3,z+5/6;x+2/3,x-y+1/3,z+5/6;-y+2/3,-x+1/3,z+5/6;x+1/3,y+2/3,z+2/3;-y+1/3,x-y+2/3,z+2/3;"	symLines[166] += "-x+y+1/3,-x+2/3,z+2/3;x-y+1/3,-y+2/3,-z+1/6;-x+1/3,-x+y+2/3,-z+1/6;y+1/3,x+2/3,-z+1/6;-x+1/3,-y+2/3,-z+2/3;"	symLines[166] += "y+1/3,-x+y+2/3,-z+2/3;x-y+1/3,x+2/3,-z+2/3;-x+y+1/3,y+2/3,z+1/6;x+1/3,x-y+2/3,z+1/6;-y+1/3,-x+2/3,z+1/6"	symLines[167]  = "x,y,z;x-y,x,z;-y,x-y,z;-x,-y,z;-x+y,-x,z;y,-x+y,z"	symLines[168]  = "x,y,z;x-y,x,z+1/6;-y,x-y,z+1/3;-x,-y,z+1/2;-x+y,-x,z+2/3;y,-x+y,z+5/6"	symLines[169]  = "x,y,z;x-y,x,z+5/6;-y,x-y,z+2/3;-x,-y,z+1/2;-x+y,-x,z+1/3;y,-x+y,z+1/6"	symLines[170]  = "x,y,z;x-y,x,z+1/3;-y,x-y,z+2/3;-x,-y,z;-x+y,-x,z+1/3;y,-x+y,z+2/3"	symLines[171]  = "x,y,z;x-y,x,z+2/3;-y,x-y,z+1/3;-x,-y,z;-x+y,-x,z+2/3;y,-x+y,z+1/3"	symLines[172]  = "x,y,z;x-y,x,z+1/2;-y,x-y,z;-x,-y,z+1/2;-x+y,-x,z;y,-x+y,z+1/2"	symLines[173]  = "x,y,z;-x+y,-x,-z;-y,x-y,z;x,y,-z;-x+y,-x,z;-y,x-y,-z"	symLines[174]  = "x,y,z;x-y,x,z;-y,x-y,z;-x,-y,z;-x+y,-x,z;y,-x+y,z;-x,-y,-z;-x+y,-x,-z;y,-x+y,-z;x,y,-z;x-y,x,-z;-y,x-y,-z"	symLines[175]  = "x,y,z;x-y,x,z+1/2;-y,x-y,z;-x,-y,z+1/2;-x+y,-x,z;y,-x+y,z+1/2;-x,-y,-z;-x+y,-x,-z+1/2;y,-x+y,-z;x,y,-z+1/2;"	symLines[175] += "x-y,x,-z;-y,x-y,-z+1/2"	symLines[176]  = "x,y,z;x-y,x,z;-y,x-y,z;-x,-y,z;-x+y,-x,z;y,-x+y,z;x-y,-y,-z;-x,-x+y,-z;y,x,-z;-y,-x,-z;-x+y,y,-z;x,x-y,-z"	symLines[177]  = "x,y,z;x-y,x,z+1/6;-y,x-y,z+1/3;-x,-y,z+1/2;-x+y,-x,z+2/3;y,-x+y,z+5/6;x-y,-y,-z;-x,-x+y,-z+2/3;y,x,-z+1/3;"	symLines[177] += "-y,-x,-z+5/6;-x+y,y,-z+1/2;x,x-y,-z+1/6"	symLines[178]  = "x,y,z;x-y,x,z+5/6;-y,x-y,z+2/3;-x,-y,z+1/2;-x+y,-x,z+1/3;y,-x+y,z+1/6;x-y,-y,-z;-x,-x+y,-z+1/3;y,x,-z+2/3;"	symLines[178] += "-y,-x,-z+1/6;-x+y,y,-z+1/2;x,x-y,-z+5/6"	symLines[179]  = "x,y,z;x-y,x,z+1/3;-y,x-y,z+2/3;-x,-y,z;-x+y,-x,z+1/3;y,-x+y,z+2/3;x-y,-y,-z;-x,-x+y,-z+1/3;y,x,-z+2/3;"	symLines[179] += "-y,-x,-z+2/3;-x+y,y,-z;x,x-y,-z+1/3"	symLines[180]  = "x,y,z;x-y,x,z+2/3;-y,x-y,z+1/3;-x,-y,z;-x+y,-x,z+2/3;y,-x+y,z+1/3;x-y,-y,-z;-x,-x+y,-z+2/3;y,x,-z+1/3;"	symLines[180] += "-y,-x,-z+1/3;-x+y,y,-z;x,x-y,-z+2/3"	symLines[181]  = "x,y,z;x-y,x,z+1/2;-y,x-y,z;-x,-y,z+1/2;-x+y,-x,z;y,-x+y,z+1/2;x-y,-y,-z;-x,-x+y,-z;y,x,-z;-y,-x,-z+1/2;"	symLines[181] += "-x+y,y,-z+1/2;x,x-y,-z+1/2"	symLines[182]  = "x,y,z;x-y,x,z;-y,x-y,z;-x,-y,z;-x+y,-x,z;y,-x+y,z;-x+y,y,z;x,x-y,z;-y,-x,z;y,x,z;x-y,-y,z;-x,-x+y,z"	symLines[183]  = "x,y,z;x-y,x,z;-y,x-y,z;-x,-y,z;-x+y,-x,z;y,-x+y,z;-x+y,y,z+1/2;x,x-y,z+1/2;-y,-x,z+1/2;y,x,z+1/2;x-y,-y,z+1/2;-x,-x+y,z+1/2"	symLines[184]  = "x,y,z;x-y,x,z+1/2;-y,x-y,z;-x,-y,z+1/2;-x+y,-x,z;y,-x+y,z+1/2;-x+y,y,z+1/2;x,x-y,z+1/2;-y,-x,z+1/2;y,x,z;x-y,-y,z;-x,-x+y,z"	symLines[185]  = "x,y,z;x-y,x,z+1/2;-y,x-y,z;-x,-y,z+1/2;-x+y,-x,z;y,-x+y,z+1/2;-x+y,y,z;x,x-y,z;-y,-x,z;y,x,z+1/2;x-y,-y,z+1/2;-x,-x+y,z+1/2"	symLines[186]  = "x,y,z;-x+y,-x,-z;-y,x-y,z;x,y,-z;-x+y,-x,z;-y,x-y,-z;-y,-x,-z;-x+y,y,-z;x,x-y,-z;-x+y,y,z;x,x-y,z;-y,-x,z"	symLines[187]  = "x,y,z;-x+y,-x,-z+1/2;-y,x-y,z;x,y,-z+1/2;-x+y,-x,z;-y,x-y,-z+1/2;-y,-x,-z;-x+y,y,-z;x,x-y,-z;-x+y,y,z+1/2;"	symLines[187] += "x,x-y,z+1/2;-y,-x,z+1/2"	symLines[188]  = "x,y,z;-x+y,-x,-z;-y,x-y,z;x,y,-z;-x+y,-x,z;-y,x-y,-z;x-y,-y,-z;-x,-x+y,-z;y,x,-z;y,x,z;x-y,-y,z;-x,-x+y,z"	symLines[189]  = "x,y,z;-x+y,-x,-z+1/2;-y,x-y,z;x,y,-z+1/2;-x+y,-x,z;-y,x-y,-z+1/2;x-y,-y,-z;-x,-x+y,-z;y,x,-z;y,x,z+1/2;"	symLines[189] += "x-y,-y,z+1/2;-x,-x+y,z+1/2"	symLines[190]  = "x,y,z;x-y,x,z;-y,x-y,z;-x,-y,z;-x+y,-x,z;y,-x+y,z;x-y,-y,-z;-x,-x+y,-z;y,x,-z;-y,-x,-z;-x+y,y,-z;x,x-y,-z;"	symLines[190] += "-x,-y,-z;-x+y,-x,-z;y,-x+y,-z;x,y,-z;x-y,x,-z;-y,x-y,-z;-x+y,y,z;x,x-y,z;-y,-x,z;y,x,z;x-y,-y,z;-x,-x+y,z"	symLines[191]  = "x,y,z;x-y,x,z;-y,x-y,z;-x,-y,z;-x+y,-x,z;y,-x+y,z;x-y,-y,-z+1/2;-x,-x+y,-z+1/2;y,x,-z+1/2;-y,-x,-z+1/2;"	symLines[191] += "-x+y,y,-z+1/2;x,x-y,-z+1/2;-x,-y,-z;-x+y,-x,-z;y,-x+y,-z;x,y,-z;x-y,x,-z;-y,x-y,-z;-x+y,y,z+1/2;x,x-y,z+1/2;"	symLines[191] += "-y,-x,z+1/2;y,x,z+1/2;x-y,-y,z+1/2;-x,-x+y,z+1/2"	symLines[192]  = "x,y,z;x-y,x,z+1/2;-y,x-y,z;-x,-y,z+1/2;-x+y,-x,z;y,-x+y,z+1/2;x-y,-y,-z+1/2;-x,-x+y,-z+1/2;y,x,-z+1/2;-y,-x,-z;"	symLines[192] += "-x+y,y,-z;x,x-y,-z;-x,-y,-z;-x+y,-x,-z+1/2;y,-x+y,-z;x,y,-z+1/2;x-y,x,-z;-y,x-y,-z+1/2;-x+y,y,z+1/2;"	symLines[192] += "x,x-y,z+1/2;-y,-x,z+1/2;y,x,z;x-y,-y,z;-x,-x+y,z"	symLines[193]  = "x,y,z;x-y,x,z+1/2;-y,x-y,z;-x,-y,z+1/2;-x+y,-x,z;y,-x+y,z+1/2;x-y,-y,-z;-x,-x+y,-z;y,x,-z;-y,-x,-z+1/2;"	symLines[193] += "-x+y,y,-z+1/2;x,x-y,-z+1/2;-x,-y,-z;-x+y,-x,-z+1/2;y,-x+y,-z;x,y,-z+1/2;x-y,x,-z;-y,x-y,-z+1/2;-x+y,y,z;"	symLines[193] += "x,x-y,z;-y,-x,z;y,x,z+1/2;x-y,-y,z+1/2;-x,-x+y,z+1/2"	symLines[194]  = "x,y,z;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-x,-y,z;x,-y,-z;-x,y,-z"	symLines[195]  = "x,y,z;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-x,-y,z;x,-y,-z;-x,y,-z;x,y+1/2,z+1/2;"	symLines[195] += "z,x+1/2,y+1/2;y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;z,-x+1/2,-y+1/2;-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;-z,x+1/2,-y+1/2;"	symLines[195] += "y,-z+1/2,-x+1/2;-x,-y+1/2,z+1/2;x,-y+1/2,-z+1/2;-x,y+1/2,-z+1/2;x+1/2,y,z+1/2;z+1/2,x,y+1/2;y+1/2,z,x+1/2;"	symLines[195] += "-y+1/2,-z,x+1/2;z+1/2,-x,-y+1/2;-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;"	symLines[195] += "-x+1/2,-y,z+1/2;x+1/2,-y,-z+1/2;-x+1/2,y,-z+1/2;x+1/2,y+1/2,z;z+1/2,x+1/2,y;y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;"	symLines[195] += "z+1/2,-x+1/2,-y;-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;-x+1/2,-y+1/2,z;"	symLines[195] += "x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z"	symLines[196]  = "x,y,z;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-x,-y,z;x,-y,-z;-x,y,-z;x+1/2,y+1/2,z+1/2;"	symLines[196] += "z+1/2,x+1/2,y+1/2;y+1/2,z+1/2,x+1/2;-y+1/2,-z+1/2,x+1/2;z+1/2,-x+1/2,-y+1/2;-y+1/2,z+1/2,-x+1/2;"	symLines[196] += "-z+1/2,-x+1/2,y+1/2;-z+1/2,x+1/2,-y+1/2;y+1/2,-z+1/2,-x+1/2;-x+1/2,-y+1/2,z+1/2;x+1/2,-y+1/2,-z+1/2;"	symLines[196] += "-x+1/2,y+1/2,-z+1/2"	symLines[197]  = "x,y,z;z,x,y;y,z,x;-y+1/2,-z,x+1/2;z+1/2,-x+1/2,-y;-y,z+1/2,-x+1/2;-z+1/2,-x,y+1/2;-z,x+1/2,-y+1/2;"	symLines[197] += "y+1/2,-z+1/2,-x;-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z;-x,y+1/2,-z+1/2"	symLines[198]  = "x,y,z;z,x,y;y,z,x;-y,-z+1/2,x;z,-x,-y+1/2;-y+1/2,z,-x;-z,-x+1/2,y;-z+1/2,x,-y;y,-z,-x+1/2;-x,-y+1/2,z;"	symLines[198] += "x,-y,-z+1/2;-x+1/2,y,-z;x+1/2,y+1/2,z+1/2;z+1/2,x+1/2,y+1/2;y+1/2,z+1/2,x+1/2;-y+1/2,-z,x+1/2;z+1/2,-x+1/2,-y;"	symLines[198] += "-y,z+1/2,-x+1/2;-z+1/2,-x,y+1/2;-z,x+1/2,-y+1/2;y+1/2,-z+1/2,-x;-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z;-x,y+1/2,-z+1/2"	symLines[199]  = "x,y,z;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-x,-y,z;x,-y,-z;-x,y,-z;-x,-y,-z;-z,-x,-y;"	symLines[199] += "-y,-z,-x;y,z,-x;-z,x,y;y,-z,x;z,x,-y;z,-x,y;-y,z,x;x,y,-z;-x,y,z;x,-y,z"	symLines[200]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-z+1/2,-x+1/2,-y+1/2;"	symLines[200] += "-y+1/2,-z+1/2,-x+1/2;y+1/2,z+1/2,-x+1/2;-z+1/2,x+1/2,y+1/2;y+1/2,-z+1/2,x+1/2;z+1/2,x+1/2,-y+1/2;"	symLines[200] += "z+1/2,-x+1/2,y+1/2;-y+1/2,z+1/2,x+1/2;-x,-y,z;x,-y,-z;-x,y,-z;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;"	symLines[200] += "x+1/2,-y+1/2,z+1/2"	symLines[201]  = "x,y,z;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-x,-y,z;x,-y,-z;-x,y,-z;-x,-y,-z;-z,-x,-y;"	symLines[201] += "-y,-z,-x;y,z,-x;-z,x,y;y,-z,x;z,x,-y;z,-x,y;-y,z,x;x,y,-z;-x,y,z;x,-y,z;x,y+1/2,z+1/2;z,x+1/2,y+1/2;"	symLines[201] += "y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;z,-x+1/2,-y+1/2;-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;"	symLines[201] += "-x,-y+1/2,z+1/2;x,-y+1/2,-z+1/2;-x,y+1/2,-z+1/2;-x,-y+1/2,-z+1/2;-z,-x+1/2,-y+1/2;-y,-z+1/2,-x+1/2;"	symLines[201] += "y,z+1/2,-x+1/2;-z,x+1/2,y+1/2;y,-z+1/2,x+1/2;z,x+1/2,-y+1/2;z,-x+1/2,y+1/2;-y,z+1/2,x+1/2;x,y+1/2,-z+1/2;"	symLines[201] += "-x,y+1/2,z+1/2;x,-y+1/2,z+1/2;x+1/2,y,z+1/2;z+1/2,x,y+1/2;y+1/2,z,x+1/2;-y+1/2,-z,x+1/2;z+1/2,-x,-y+1/2;"	symLines[201] += "-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;-x+1/2,-y,z+1/2;x+1/2,-y,-z+1/2;"	symLines[201] += "-x+1/2,y,-z+1/2;-x+1/2,-y,-z+1/2;-z+1/2,-x,-y+1/2;-y+1/2,-z,-x+1/2;y+1/2,z,-x+1/2;-z+1/2,x,y+1/2;"	symLines[201] += "y+1/2,-z,x+1/2;z+1/2,x,-y+1/2;z+1/2,-x,y+1/2;-y+1/2,z,x+1/2;x+1/2,y,-z+1/2;-x+1/2,y,z+1/2;x+1/2,-y,z+1/2;"	symLines[201] += "x+1/2,y+1/2,z;z+1/2,x+1/2,y;y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;z+1/2,-x+1/2,-y;-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;"	symLines[201] += "-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;-x+1/2,-y+1/2,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;-x+1/2,-y+1/2,-z;"	symLines[201] += "-z+1/2,-x+1/2,-y;-y+1/2,-z+1/2,-x;y+1/2,z+1/2,-x;-z+1/2,x+1/2,y;y+1/2,-z+1/2,x;z+1/2,x+1/2,-y;z+1/2,-x+1/2,y;"	symLines[201] += "-y+1/2,z+1/2,x;x+1/2,y+1/2,-z;-x+1/2,y+1/2,z;x+1/2,-y+1/2,z"	symLines[202]  = "x,y,z;-x+1/4,-y+1/4,-z+1/4;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-z+1/4,-x+1/4,-y+1/4;"	symLines[202] += "-y+1/4,-z+1/4,-x+1/4;y+1/4,z+1/4,-x+1/4;-z+1/4,x+1/4,y+1/4;y+1/4,-z+1/4,x+1/4;z+1/4,x+1/4,-y+1/4;"	symLines[202] += "z+1/4,-x+1/4,y+1/4;-y+1/4,z+1/4,x+1/4;-x,-y,z;x,-y,-z;-x,y,-z;x+1/4,y+1/4,-z+1/4;-x+1/4,y+1/4,z+1/4;"	symLines[202] += "x+1/4,-y+1/4,z+1/4;x,y+1/2,z+1/2;-x+1/4,-y+3/4,-z+3/4;z,x+1/2,y+1/2;y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;"	symLines[202] += "z,-x+1/2,-y+1/2;-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;-z+1/4,-x+3/4,-y+3/4;"	symLines[202] += "-y+1/4,-z+3/4,-x+3/4;y+1/4,z+3/4,-x+3/4;-z+1/4,x+3/4,y+3/4;y+1/4,-z+3/4,x+3/4;z+1/4,x+3/4,-y+3/4;"	symLines[202] += "z+1/4,-x+3/4,y+3/4;-y+1/4,z+3/4,x+3/4;-x,-y+1/2,z+1/2;x,-y+1/2,-z+1/2;-x,y+1/2,-z+1/2;x+1/4,y+3/4,-z+3/4;"	symLines[202] += "-x+1/4,y+3/4,z+3/4;x+1/4,-y+3/4,z+3/4;x+1/2,y,z+1/2;-x+3/4,-y+1/4,-z+3/4;z+1/2,x,y+1/2;y+1/2,z,x+1/2;"	symLines[202] += "-y+1/2,-z,x+1/2;z+1/2,-x,-y+1/2;-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;"	symLines[202] += "-z+3/4,-x+1/4,-y+3/4;-y+3/4,-z+1/4,-x+3/4;y+3/4,z+1/4,-x+3/4;-z+3/4,x+1/4,y+3/4;y+3/4,-z+1/4,x+3/4;"	symLines[202] += "z+3/4,x+1/4,-y+3/4;z+3/4,-x+1/4,y+3/4;-y+3/4,z+1/4,x+3/4;-x+1/2,-y,z+1/2;x+1/2,-y,-z+1/2;-x+1/2,y,-z+1/2;"	symLines[202] += "x+3/4,y+1/4,-z+3/4;-x+3/4,y+1/4,z+3/4;x+3/4,-y+1/4,z+3/4;x+1/2,y+1/2,z;-x+3/4,-y+3/4,-z+1/4;z+1/2,x+1/2,y;"	symLines[202] += "y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;z+1/2,-x+1/2,-y;-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;"	symLines[202] += "-z+3/4,-x+3/4,-y+1/4;-y+3/4,-z+3/4,-x+1/4;y+3/4,z+3/4,-x+1/4;-z+3/4,x+3/4,y+1/4;y+3/4,-z+3/4,x+1/4;"	symLines[202] += "z+3/4,x+3/4,-y+1/4;z+3/4,-x+3/4,y+1/4;-y+3/4,z+3/4,x+1/4;-x+1/2,-y+1/2,z;x+1/2,-y+1/2,-z;-x+1/2,y+1/2,-z;"	symLines[202] += "x+3/4,y+3/4,-z+1/4;-x+3/4,y+3/4,z+1/4;x+3/4,-y+3/4,z+1/4"	symLines[203]  = "x,y,z;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-x,-y,z;x,-y,-z;-x,y,-z;-x,-y,-z;-z,-x,-y;"	symLines[203] += "-y,-z,-x;y,z,-x;-z,x,y;y,-z,x;z,x,-y;z,-x,y;-y,z,x;x,y,-z;-x,y,z;x,-y,z;x+1/2,y+1/2,z+1/2;z+1/2,x+1/2,y+1/2;"	symLines[203] += "y+1/2,z+1/2,x+1/2;-y+1/2,-z+1/2,x+1/2;z+1/2,-x+1/2,-y+1/2;-y+1/2,z+1/2,-x+1/2;-z+1/2,-x+1/2,y+1/2;"	symLines[203] += "-z+1/2,x+1/2,-y+1/2;y+1/2,-z+1/2,-x+1/2;-x+1/2,-y+1/2,z+1/2;x+1/2,-y+1/2,-z+1/2;-x+1/2,y+1/2,-z+1/2;"	symLines[203] += "-x+1/2,-y+1/2,-z+1/2;-z+1/2,-x+1/2,-y+1/2;-y+1/2,-z+1/2,-x+1/2;y+1/2,z+1/2,-x+1/2;-z+1/2,x+1/2,y+1/2;"	symLines[203] += "y+1/2,-z+1/2,x+1/2;z+1/2,x+1/2,-y+1/2;z+1/2,-x+1/2,y+1/2;-y+1/2,z+1/2,x+1/2;x+1/2,y+1/2,-z+1/2;"	symLines[203] += "-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2"	symLines[204]  = "x,y,z;z,x,y;y,z,x;-y+1/2,-z,x+1/2;z+1/2,-x+1/2,-y;-y,z+1/2,-x+1/2;-z+1/2,-x,y+1/2;-z,x+1/2,-y+1/2;"	symLines[204] += "y+1/2,-z+1/2,-x;-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z;-x,y+1/2,-z+1/2;-x,-y,-z;-z,-x,-y;-y,-z,-x;y+1/2,z,-x+1/2;"	symLines[204] += "-z+1/2,x+1/2,y;y,-z+1/2,x+1/2;z+1/2,x,-y+1/2;z,-x+1/2,y+1/2;-y+1/2,z+1/2,x;x+1/2,y,-z+1/2;-x+1/2,y+1/2,z;"	symLines[204] += "x,-y+1/2,z+1/2"	symLines[205]  = "x,y,z;z,x,y;y,z,x;-y,-z+1/2,x;z,-x,-y+1/2;-y+1/2,z,-x;-z,-x+1/2,y;-z+1/2,x,-y;y,-z,-x+1/2;-x,-y+1/2,z;"	symLines[205] += "x,-y,-z+1/2;-x+1/2,y,-z;-x,-y,-z;-z,-x,-y;-y,-z,-x;y,z+1/2,-x;-z,x,y+1/2;y+1/2,-z,x;z,x+1/2,-y;z+1/2,-x,y;"	symLines[205] += "-y,z,x+1/2;x,y+1/2,-z;-x,y,z+1/2;x+1/2,-y,z;x+1/2,y+1/2,z+1/2;z+1/2,x+1/2,y+1/2;y+1/2,z+1/2,x+1/2;"	symLines[205] += "-y+1/2,-z,x+1/2;z+1/2,-x+1/2,-y;-y,z+1/2,-x+1/2;-z+1/2,-x,y+1/2;-z,x+1/2,-y+1/2;y+1/2,-z+1/2,-x;"	symLines[205] += "-x+1/2,-y,z+1/2;x+1/2,-y+1/2,-z;-x,y+1/2,-z+1/2;-x+1/2,-y+1/2,-z+1/2;-z+1/2,-x+1/2,-y+1/2;-y+1/2,-z+1/2,-x+1/2;"	symLines[205] += "y+1/2,z,-x+1/2;-z+1/2,x+1/2,y;y,-z+1/2,x+1/2;z+1/2,x,-y+1/2;z,-x+1/2,y+1/2;-y+1/2,z+1/2,x;x+1/2,y,-z+1/2;"	symLines[205] += "-x+1/2,y+1/2,z;x,-y+1/2,z+1/2"	symLines[206]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-z,y;x,-y,-z;x,z,-y;z,y,-x;-x,y,-z;-z,y,x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;"	symLines[206] += "-z,-x,y;-z,x,-y;y,-z,-x;y,x,-z;-y,-x,-z;-x,z,y;-x,-z,-y;z,-y,x;-z,-y,-x"	symLines[207]  = "x,y,z;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;x+1/2,-z+1/2,y+1/2;x,-y,-z;x+1/2,z+1/2,-y+1/2;"	symLines[207] += "z+1/2,y+1/2,-x+1/2;-x,y,-z;-z+1/2,y+1/2,x+1/2;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;"	symLines[207] += "y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;-x+1/2,z+1/2,y+1/2;-x+1/2,-z+1/2,-y+1/2;z+1/2,-y+1/2,x+1/2;"	symLines[207] += "-z+1/2,-y+1/2,-x+1/2"	symLines[208]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-z,y;x,-y,-z;x,z,-y;z,y,-x;-x,y,-z;-z,y,x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;"	symLines[208] += "-z,-x,y;-z,x,-y;y,-z,-x;y,x,-z;-y,-x,-z;-x,z,y;-x,-z,-y;z,-y,x;-z,-y,-x;x,y+1/2,z+1/2;-y,x+1/2,z+1/2;"	symLines[208] += "-x,-y+1/2,z+1/2;y,-x+1/2,z+1/2;x,-z+1/2,y+1/2;x,-y+1/2,-z+1/2;x,z+1/2,-y+1/2;z,y+1/2,-x+1/2;-x,y+1/2,-z+1/2;"	symLines[208] += "-z,y+1/2,x+1/2;z,x+1/2,y+1/2;y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;z,-x+1/2,-y+1/2;-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;"	symLines[208] += "-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;y,x+1/2,-z+1/2;-y,-x+1/2,-z+1/2;-x,z+1/2,y+1/2;-x,-z+1/2,-y+1/2;z,-y+1/2,x+1/2;"	symLines[208] += "-z,-y+1/2,-x+1/2;x+1/2,y,z+1/2;-y+1/2,x,z+1/2;-x+1/2,-y,z+1/2;y+1/2,-x,z+1/2;x+1/2,-z,y+1/2;x+1/2,-y,-z+1/2;"	symLines[208] += "x+1/2,z,-y+1/2;z+1/2,y,-x+1/2;-x+1/2,y,-z+1/2;-z+1/2,y,x+1/2;z+1/2,x,y+1/2;y+1/2,z,x+1/2;-y+1/2,-z,x+1/2;"	symLines[208] += "z+1/2,-x,-y+1/2;-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;y+1/2,x,-z+1/2;"	symLines[208] += "-y+1/2,-x,-z+1/2;-x+1/2,z,y+1/2;-x+1/2,-z,-y+1/2;z+1/2,-y,x+1/2;-z+1/2,-y,-x+1/2;x+1/2,y+1/2,z;-y+1/2,x+1/2,z;"	symLines[208] += "-x+1/2,-y+1/2,z;y+1/2,-x+1/2,z;x+1/2,-z+1/2,y;x+1/2,-y+1/2,-z;x+1/2,z+1/2,-y;z+1/2,y+1/2,-x;-x+1/2,y+1/2,-z;"	symLines[208] += "-z+1/2,y+1/2,x;z+1/2,x+1/2,y;y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;z+1/2,-x+1/2,-y;-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;"	symLines[208] += "-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;y+1/2,x+1/2,-z;-y+1/2,-x+1/2,-z;-x+1/2,z+1/2,y;-x+1/2,-z+1/2,-y;z+1/2,-y+1/2,x;"	symLines[208] += "-z+1/2,-y+1/2,-x"	symLines[209]  = "x,y,z;-y+1/4,x+1/4,z+1/4;-x,-y,z;y+1/4,-x+1/4,z+1/4;x+1/4,-z+1/4,y+1/4;x,-y,-z;x+1/4,z+1/4,-y+1/4;"	symLines[209] += "z+1/4,y+1/4,-x+1/4;-x,y,-z;-z+1/4,y+1/4,x+1/4;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;"	symLines[209] += "y+1/4,x+1/4,-z+1/4;-y+1/4,-x+1/4,-z+1/4;-x+1/4,z+1/4,y+1/4;-x+1/4,-z+1/4,-y+1/4;z+1/4,-y+1/4,x+1/4;"	symLines[209] += "-z+1/4,-y+1/4,-x+1/4;x,y+1/2,z+1/2;-y+1/4,x+3/4,z+3/4;-x,-y+1/2,z+1/2;y+1/4,-x+3/4,z+3/4;x+1/4,-z+3/4,y+3/4;"	symLines[209] += "x,-y+1/2,-z+1/2;x+1/4,z+3/4,-y+3/4;z+1/4,y+3/4,-x+3/4;-x,y+1/2,-z+1/2;-z+1/4,y+3/4,x+3/4;z,x+1/2,y+1/2;"	symLines[209] += "y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;z,-x+1/2,-y+1/2;-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;"	symLines[209] += "y+1/4,x+3/4,-z+3/4;-y+1/4,-x+3/4,-z+3/4;-x+1/4,z+3/4,y+3/4;-x+1/4,-z+3/4,-y+3/4;z+1/4,-y+3/4,x+3/4;"	symLines[209] += "-z+1/4,-y+3/4,-x+3/4;x+1/2,y,z+1/2;-y+3/4,x+1/4,z+3/4;-x+1/2,-y,z+1/2;y+3/4,-x+1/4,z+3/4;x+3/4,-z+1/4,y+3/4;"	symLines[209] += "x+1/2,-y,-z+1/2;x+3/4,z+1/4,-y+3/4;z+3/4,y+1/4,-x+3/4;-x+1/2,y,-z+1/2;-z+3/4,y+1/4,x+3/4;z+1/2,x,y+1/2;"	symLines[209] += "y+1/2,z,x+1/2;-y+1/2,-z,x+1/2;z+1/2,-x,-y+1/2;-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;"	symLines[209] += "y+3/4,x+1/4,-z+3/4;-y+3/4,-x+1/4,-z+3/4;-x+3/4,z+1/4,y+3/4;-x+3/4,-z+1/4,-y+3/4;z+3/4,-y+1/4,x+3/4;"	symLines[209] += "-z+3/4,-y+1/4,-x+3/4;x+1/2,y+1/2,z;-y+3/4,x+3/4,z+1/4;-x+1/2,-y+1/2,z;y+3/4,-x+3/4,z+1/4;x+3/4,-z+3/4,y+1/4;"	symLines[209] += "x+1/2,-y+1/2,-z;x+3/4,z+3/4,-y+1/4;z+3/4,y+3/4,-x+1/4;-x+1/2,y+1/2,-z;-z+3/4,y+3/4,x+1/4;z+1/2,x+1/2,y;"	symLines[209] += "y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;z+1/2,-x+1/2,-y;-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;"	symLines[209] += "y+3/4,x+3/4,-z+1/4;-y+3/4,-x+3/4,-z+1/4;-x+3/4,z+3/4,y+1/4;-x+3/4,-z+3/4,-y+1/4;z+3/4,-y+3/4,x+1/4;"	symLines[209] += "-z+3/4,-y+3/4,-x+1/4"	symLines[210]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-z,y;x,-y,-z;x,z,-y;z,y,-x;-x,y,-z;-z,y,x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;"	symLines[210] += "-z,-x,y;-z,x,-y;y,-z,-x;y,x,-z;-y,-x,-z;-x,z,y;-x,-z,-y;z,-y,x;-z,-y,-x;x+1/2,y+1/2,z+1/2;-y+1/2,x+1/2,z+1/2;"	symLines[210] += "-x+1/2,-y+1/2,z+1/2;y+1/2,-x+1/2,z+1/2;x+1/2,-z+1/2,y+1/2;x+1/2,-y+1/2,-z+1/2;x+1/2,z+1/2,-y+1/2;"	symLines[210] += "z+1/2,y+1/2,-x+1/2;-x+1/2,y+1/2,-z+1/2;-z+1/2,y+1/2,x+1/2;z+1/2,x+1/2,y+1/2;y+1/2,z+1/2,x+1/2;"	symLines[210] += "-y+1/2,-z+1/2,x+1/2;z+1/2,-x+1/2,-y+1/2;-y+1/2,z+1/2,-x+1/2;-z+1/2,-x+1/2,y+1/2;-z+1/2,x+1/2,-y+1/2;"	symLines[210] += "y+1/2,-z+1/2,-x+1/2;y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;-x+1/2,z+1/2,y+1/2;-x+1/2,-z+1/2,-y+1/2;"	symLines[210] += "z+1/2,-y+1/2,x+1/2;-z+1/2,-y+1/2,-x+1/2"	symLines[211]  = "x,y,z;-y+3/4,x+1/4,z+3/4;-x+1/2,-y,z+1/2;y+3/4,-x+3/4,z+1/4;x+3/4,-z+3/4,y+1/4;x+1/2,-y+1/2,-z;"	symLines[211] += "x+1/4,z+3/4,-y+3/4;z+1/4,y+3/4,-x+3/4;-x,y+1/2,-z+1/2;-z+3/4,y+1/4,x+3/4;z,x,y;y,z,x;-y+1/2,-z,x+1/2;"	symLines[211] += "z+1/2,-x+1/2,-y;-y,z+1/2,-x+1/2;-z+1/2,-x,y+1/2;-z,x+1/2,-y+1/2;y+1/2,-z+1/2,-x;y+1/4,x+3/4,-z+3/4;"	symLines[211] += "-y+1/4,-x+1/4,-z+1/4;-x+3/4,z+1/4,y+3/4;-x+1/4,-z+1/4,-y+1/4;z+3/4,-y+3/4,x+1/4;-z+1/4,-y+1/4,-x+1/4"	symLines[212]  = "x,y,z;-y+1/4,x+3/4,z+1/4;-x+1/2,-y,z+1/2;y+1/4,-x+1/4,z+3/4;x+1/4,-z+1/4,y+3/4;x+1/2,-y+1/2,-z;"	symLines[212] += "x+3/4,z+1/4,-y+1/4;z+3/4,y+1/4,-x+1/4;-x,y+1/2,-z+1/2;-z+1/4,y+3/4,x+1/4;z,x,y;y,z,x;-y+1/2,-z,x+1/2;"	symLines[212] += "z+1/2,-x+1/2,-y;-y,z+1/2,-x+1/2;-z+1/2,-x,y+1/2;-z,x+1/2,-y+1/2;y+1/2,-z+1/2,-x;y+3/4,x+1/4,-z+1/4;"	symLines[212] += "-y+3/4,-x+3/4,-z+3/4;-x+1/4,z+3/4,y+1/4;-x+3/4,-z+3/4,-y+3/4;z+1/4,-y+1/4,x+3/4;-z+3/4,-y+3/4,-x+3/4"	symLines[213]  = "x,y,z;-y+1/4,x+3/4,z+1/4;-x,-y+1/2,z;y+1/4,-x+1/4,z+3/4;x+1/4,-z+1/4,y+3/4;x,-y,-z+1/2;x+3/4,z+1/4,-y+1/4;"	symLines[213] += "z+3/4,y+1/4,-x+1/4;-x+1/2,y,-z;-z+1/4,y+3/4,x+1/4;z,x,y;y,z,x;-y,-z+1/2,x;z,-x,-y+1/2;-y+1/2,z,-x;-z,-x+1/2,y;"	symLines[213] += "-z+1/2,x,-y;y,-z,-x+1/2;y+3/4,x+1/4,-z+1/4;-y+1/4,-x+1/4,-z+1/4;-x+1/4,z+3/4,y+1/4;-x+1/4,-z+1/4,-y+1/4;"	symLines[213] += "z+1/4,-y+1/4,x+3/4;-z+1/4,-y+1/4,-x+1/4;x+1/2,y+1/2,z+1/2;-y+3/4,x+1/4,z+3/4;-x+1/2,-y,z+1/2;"	symLines[213] += "y+3/4,-x+3/4,z+1/4;x+3/4,-z+3/4,y+1/4;x+1/2,-y+1/2,-z;x+1/4,z+3/4,-y+3/4;z+1/4,y+3/4,-x+3/4;-x,y+1/2,-z+1/2;"	symLines[213] += "-z+3/4,y+1/4,x+3/4;z+1/2,x+1/2,y+1/2;y+1/2,z+1/2,x+1/2;-y+1/2,-z,x+1/2;z+1/2,-x+1/2,-y;-y,z+1/2,-x+1/2;"	symLines[213] += "-z+1/2,-x,y+1/2;-z,x+1/2,-y+1/2;y+1/2,-z+1/2,-x;y+1/4,x+3/4,-z+3/4;-y+3/4,-x+3/4,-z+3/4;-x+3/4,z+1/4,y+3/4;"	symLines[213] += "-x+3/4,-z+3/4,-y+3/4;z+3/4,-y+3/4,x+1/4;-z+3/4,-y+3/4,-x+3/4"	symLines[214]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;-x,z,-y;x,-y,-z;-x,-z,y;-z,-y,x;-x,y,-z;z,-y,-x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;"	symLines[214] += "-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-y,-x,z;y,x,z;x,-z,-y;x,z,y;-z,y,-x;z,y,x"	symLines[215]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;-x,z,-y;x,-y,-z;-x,-z,y;-z,-y,x;-x,y,-z;z,-y,-x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;"	symLines[215] += "-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-y,-x,z;y,x,z;x,-z,-y;x,z,y;-z,y,-x;z,y,x;x,y+1/2,z+1/2;y,-x+1/2,-z+1/2;"	symLines[215] += "-x,-y+1/2,z+1/2;-y,x+1/2,-z+1/2;-x,z+1/2,-y+1/2;x,-y+1/2,-z+1/2;-x,-z+1/2,y+1/2;-z,-y+1/2,x+1/2;"	symLines[215] += "-x,y+1/2,-z+1/2;z,-y+1/2,-x+1/2;z,x+1/2,y+1/2;y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;z,-x+1/2,-y+1/2;-y,z+1/2,-x+1/2;"	symLines[215] += "-z,-x+1/2,y+1/2;-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;-y,-x+1/2,z+1/2;y,x+1/2,z+1/2;x,-z+1/2,-y+1/2;x,z+1/2,y+1/2;"	symLines[215] += "-z,y+1/2,-x+1/2;z,y+1/2,x+1/2;x+1/2,y,z+1/2;y+1/2,-x,-z+1/2;-x+1/2,-y,z+1/2;-y+1/2,x,-z+1/2;-x+1/2,z,-y+1/2;"	symLines[215] += "x+1/2,-y,-z+1/2;-x+1/2,-z,y+1/2;-z+1/2,-y,x+1/2;-x+1/2,y,-z+1/2;z+1/2,-y,-x+1/2;z+1/2,x,y+1/2;y+1/2,z,x+1/2;"	symLines[215] += "-y+1/2,-z,x+1/2;z+1/2,-x,-y+1/2;-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;"	symLines[215] += "-y+1/2,-x,z+1/2;y+1/2,x,z+1/2;x+1/2,-z,-y+1/2;x+1/2,z,y+1/2;-z+1/2,y,-x+1/2;z+1/2,y,x+1/2;x+1/2,y+1/2,z;"	symLines[215] += "y+1/2,-x+1/2,-z;-x+1/2,-y+1/2,z;-y+1/2,x+1/2,-z;-x+1/2,z+1/2,-y;x+1/2,-y+1/2,-z;-x+1/2,-z+1/2,y;"	symLines[215] += "-z+1/2,-y+1/2,x;-x+1/2,y+1/2,-z;z+1/2,-y+1/2,-x;z+1/2,x+1/2,y;y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;z+1/2,-x+1/2,-y;"	symLines[215] += "-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z;x+1/2,-z+1/2,-y;"	symLines[215] += "x+1/2,z+1/2,y;-z+1/2,y+1/2,-x;z+1/2,y+1/2,x"	symLines[216]  = "x,y,z;y,-x,-z;-x,-y,z;-y,x,-z;-x,z,-y;x,-y,-z;-x,-z,y;-z,-y,x;-x,y,-z;z,-y,-x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;"	symLines[216] += "-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-y,-x,z;y,x,z;x,-z,-y;x,z,y;-z,y,-x;z,y,x;x+1/2,y+1/2,z+1/2;"	symLines[216] += "y+1/2,-x+1/2,-z+1/2;-x+1/2,-y+1/2,z+1/2;-y+1/2,x+1/2,-z+1/2;-x+1/2,z+1/2,-y+1/2;x+1/2,-y+1/2,-z+1/2;"	symLines[216] += "-x+1/2,-z+1/2,y+1/2;-z+1/2,-y+1/2,x+1/2;-x+1/2,y+1/2,-z+1/2;z+1/2,-y+1/2,-x+1/2;z+1/2,x+1/2,y+1/2;"	symLines[216] += "y+1/2,z+1/2,x+1/2;-y+1/2,-z+1/2,x+1/2;z+1/2,-x+1/2,-y+1/2;-y+1/2,z+1/2,-x+1/2;-z+1/2,-x+1/2,y+1/2;"	symLines[216] += "-z+1/2,x+1/2,-y+1/2;y+1/2,-z+1/2,-x+1/2;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2;x+1/2,-z+1/2,-y+1/2;"	symLines[216] += "x+1/2,z+1/2,y+1/2;-z+1/2,y+1/2,-x+1/2;z+1/2,y+1/2,x+1/2"	symLines[217]  = "x,y,z;y+1/2,-x+1/2,-z+1/2;-x,-y,z;-y+1/2,x+1/2,-z+1/2;-x+1/2,z+1/2,-y+1/2;x,-y,-z;-x+1/2,-z+1/2,y+1/2;"	symLines[217] += "-z+1/2,-y+1/2,x+1/2;-x,y,-z;z+1/2,-y+1/2,-x+1/2;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;"	symLines[217] += "-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2;x+1/2,-z+1/2,-y+1/2;x+1/2,z+1/2,y+1/2;-z+1/2,y+1/2,-x+1/2;"	symLines[217] += "z+1/2,y+1/2,x+1/2"	symLines[218]  = "x,y,z;y,-x,-z+1/2;-x,-y,z;-y,x,-z+1/2;-x,z,-y+1/2;x,-y,-z;-x,-z,y+1/2;-z,-y,x+1/2;-x,y,-z;z,-y,-x+1/2;z,x,y;"	symLines[218] += "y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-y,-x,z+1/2;y,x,z+1/2;x,-z,-y+1/2;x,z,y+1/2;-z,y,-x+1/2;"	symLines[218] += "z,y,x+1/2;x,y+1/2,z+1/2;y,-x+1/2,-z;-x,-y+1/2,z+1/2;-y,x+1/2,-z;-x,z+1/2,-y;x,-y+1/2,-z+1/2;-x,-z+1/2,y;"	symLines[218] += "-z,-y+1/2,x;-x,y+1/2,-z+1/2;z,-y+1/2,-x;z,x+1/2,y+1/2;y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;z,-x+1/2,-y+1/2;"	symLines[218] += "-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;-y,-x+1/2,z;y,x+1/2,z;x,-z+1/2,-y;x,z+1/2,y;"	symLines[218] += "-z,y+1/2,-x;z,y+1/2,x;x+1/2,y,z+1/2;y+1/2,-x,-z;-x+1/2,-y,z+1/2;-y+1/2,x,-z;-x+1/2,z,-y;x+1/2,-y,-z+1/2;"	symLines[218] += "-x+1/2,-z,y;-z+1/2,-y,x;-x+1/2,y,-z+1/2;z+1/2,-y,-x;z+1/2,x,y+1/2;y+1/2,z,x+1/2;-y+1/2,-z,x+1/2;"	symLines[218] += "z+1/2,-x,-y+1/2;-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;-y+1/2,-x,z;y+1/2,x,z;"	symLines[218] += "x+1/2,-z,-y;x+1/2,z,y;-z+1/2,y,-x;z+1/2,y,x;x+1/2,y+1/2,z;y+1/2,-x+1/2,-z+1/2;-x+1/2,-y+1/2,z;"	symLines[218] += "-y+1/2,x+1/2,-z+1/2;-x+1/2,z+1/2,-y+1/2;x+1/2,-y+1/2,-z;-x+1/2,-z+1/2,y+1/2;-z+1/2,-y+1/2,x+1/2;"	symLines[218] += "-x+1/2,y+1/2,-z;z+1/2,-y+1/2,-x+1/2;z+1/2,x+1/2,y;y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;z+1/2,-x+1/2,-y;"	symLines[218] += "-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2;"	symLines[218] += "x+1/2,-z+1/2,-y+1/2;x+1/2,z+1/2,y+1/2;-z+1/2,y+1/2,-x+1/2;z+1/2,y+1/2,x+1/2"	symLines[219]  = "x,y,z;y+1/4,-x+3/4,-z+1/4;-x,-y+1/2,z;-y+1/4,x+1/4,-z+3/4;-x+1/4,z+1/4,-y+3/4;x,-y,-z+1/2;-x+3/4,-z+1/4,y+1/4;"	symLines[219] += "-z+3/4,-y+1/4,x+1/4;-x+1/2,y,-z;z+1/4,-y+3/4,-x+1/4;z,x,y;y,z,x;-y,-z+1/2,x;z,-x,-y+1/2;-y+1/2,z,-x;"	symLines[219] += "-z,-x+1/2,y;-z+1/2,x,-y;y,-z,-x+1/2;-y+3/4,-x+1/4,z+1/4;y+1/4,x+1/4,z+1/4;x+1/4,-z+3/4,-y+1/4;"	symLines[219] += "x+1/4,z+1/4,y+1/4;-z+1/4,y+1/4,-x+3/4;z+1/4,y+1/4,x+1/4;x+1/2,y+1/2,z+1/2;y+3/4,-x+1/4,-z+3/4;-x+1/2,-y,z+1/2;"	symLines[219] += "-y+3/4,x+3/4,-z+1/4;-x+3/4,z+3/4,-y+1/4;x+1/2,-y+1/2,-z;-x+1/4,-z+3/4,y+3/4;-z+1/4,-y+3/4,x+3/4;"	symLines[219] += "-x,y+1/2,-z+1/2;z+3/4,-y+1/4,-x+3/4;z+1/2,x+1/2,y+1/2;y+1/2,z+1/2,x+1/2;-y+1/2,-z,x+1/2;z+1/2,-x+1/2,-y;"	symLines[219] += "-y,z+1/2,-x+1/2;-z+1/2,-x,y+1/2;-z,x+1/2,-y+1/2;y+1/2,-z+1/2,-x;-y+1/4,-x+3/4,z+3/4;y+3/4,x+3/4,z+3/4;"	symLines[219] += "x+3/4,-z+1/4,-y+3/4;x+3/4,z+3/4,y+3/4;-z+3/4,y+3/4,-x+1/4;z+3/4,y+3/4,x+3/4"	symLines[220]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-z,y;x,-y,-z;x,z,-y;z,y,-x;-x,y,-z;-z,y,x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;"	symLines[220] += "-z,-x,y;-z,x,-y;y,-z,-x;y,x,-z;-y,-x,-z;-x,z,y;-x,-z,-y;z,-y,x;-z,-y,-x;-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z;"	symLines[220] += "-x,z,-y;-x,y,z;-x,-z,y;-z,-y,x;x,-y,z;z,-y,-x;-z,-x,-y;-y,-z,-x;y,z,-x;-z,x,y;y,-z,x;z,x,-y;z,-x,y;-y,z,x;"	symLines[220] += "-y,-x,z;y,x,z;x,-z,-y;x,z,y;-z,y,-x;z,y,x"	symLines[221]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;-y,x,z;-x,-y,z;y,-x,z;x,-z,y;x,-y,-z;x,z,-y;z,y,-x;-x,y,-z;-z,y,x;"	symLines[221] += "y+1/2,-x+1/2,-z+1/2;-y+1/2,x+1/2,-z+1/2;-x+1/2,z+1/2,-y+1/2;-x+1/2,-z+1/2,y+1/2;-z+1/2,-y+1/2,x+1/2;"	symLines[221] += "z+1/2,-y+1/2,-x+1/2;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-z+1/2,-x+1/2,-y+1/2;"	symLines[221] += "-y+1/2,-z+1/2,-x+1/2;y+1/2,z+1/2,-x+1/2;-z+1/2,x+1/2,y+1/2;y+1/2,-z+1/2,x+1/2;z+1/2,x+1/2,-y+1/2;"	symLines[221] += "z+1/2,-x+1/2,y+1/2;-y+1/2,z+1/2,x+1/2;y,x,-z;-y,-x,-z;-x,z,y;-x,-z,-y;z,-y,x;-z,-y,-x;x+1/2,y+1/2,-z+1/2;"	symLines[221] += "-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2;x+1/2,-z+1/2,-y+1/2;"	symLines[221] += "x+1/2,z+1/2,y+1/2;-z+1/2,y+1/2,-x+1/2;z+1/2,y+1/2,x+1/2"	symLines[222]  = "x,y,z;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;x+1/2,-z+1/2,y+1/2;x,-y,-z;x+1/2,z+1/2,-y+1/2;"	symLines[222] += "z+1/2,y+1/2,-x+1/2;-x,y,-z;-z+1/2,y+1/2,x+1/2;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;"	symLines[222] += "y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;-x+1/2,z+1/2,y+1/2;-x+1/2,-z+1/2,-y+1/2;z+1/2,-y+1/2,x+1/2;"	symLines[222] += "-z+1/2,-y+1/2,-x+1/2;-x,-y,-z;y+1/2,-x+1/2,-z+1/2;x,y,-z;-y+1/2,x+1/2,-z+1/2;-x+1/2,z+1/2,-y+1/2;-x,y,z;"	symLines[222] += "-x+1/2,-z+1/2,y+1/2;-z+1/2,-y+1/2,x+1/2;x,-y,z;z+1/2,-y+1/2,-x+1/2;-z,-x,-y;-y,-z,-x;y,z,-x;-z,x,y;y,-z,x;"	symLines[222] += "z,x,-y;z,-x,y;-y,z,x;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2;x+1/2,-z+1/2,-y+1/2;x+1/2,z+1/2,y+1/2;"	symLines[222] += "-z+1/2,y+1/2,-x+1/2;z+1/2,y+1/2,x+1/2"	symLines[223]  = "x,y,z;-x+1/2,-y+1/2,-z+1/2;-y+1/2,x+1/2,z+1/2;-x,-y,z;y+1/2,-x+1/2,z+1/2;x+1/2,-z+1/2,y+1/2;x,-y,-z;"	symLines[223] += "x+1/2,z+1/2,-y+1/2;z+1/2,y+1/2,-x+1/2;-x,y,-z;-z+1/2,y+1/2,x+1/2;y,-x,-z;-y,x,-z;-x,z,-y;-x,-z,y;-z,-y,x;"	symLines[223] += "z,-y,-x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-z+1/2,-x+1/2,-y+1/2;-y+1/2,-z+1/2,-x+1/2;"	symLines[223] += "y+1/2,z+1/2,-x+1/2;-z+1/2,x+1/2,y+1/2;y+1/2,-z+1/2,x+1/2;z+1/2,x+1/2,-y+1/2;z+1/2,-x+1/2,y+1/2;"	symLines[223] += "-y+1/2,z+1/2,x+1/2;y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;-x+1/2,z+1/2,y+1/2;-x+1/2,-z+1/2,-y+1/2;"	symLines[223] += "z+1/2,-y+1/2,x+1/2;-z+1/2,-y+1/2,-x+1/2;x+1/2,y+1/2,-z+1/2;-x+1/2,y+1/2,z+1/2;x+1/2,-y+1/2,z+1/2;-y,-x,z;y,x,z;"	symLines[223] += "x,-z,-y;x,z,y;-z,y,-x;z,y,x"	symLines[224]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-z,y;x,-y,-z;x,z,-y;z,y,-x;-x,y,-z;-z,y,x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;"	symLines[224] += "-z,-x,y;-z,x,-y;y,-z,-x;y,x,-z;-y,-x,-z;-x,z,y;-x,-z,-y;z,-y,x;-z,-y,-x;-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z;"	symLines[224] += "-x,z,-y;-x,y,z;-x,-z,y;-z,-y,x;x,-y,z;z,-y,-x;-z,-x,-y;-y,-z,-x;y,z,-x;-z,x,y;y,-z,x;z,x,-y;z,-x,y;-y,z,x;"	symLines[224] += "-y,-x,z;y,x,z;x,-z,-y;x,z,y;-z,y,-x;z,y,x;x,y+1/2,z+1/2;-y,x+1/2,z+1/2;-x,-y+1/2,z+1/2;y,-x+1/2,z+1/2;"	symLines[224] += "x,-z+1/2,y+1/2;x,-y+1/2,-z+1/2;x,z+1/2,-y+1/2;z,y+1/2,-x+1/2;-x,y+1/2,-z+1/2;-z,y+1/2,x+1/2;z,x+1/2,y+1/2;"	symLines[224] += "y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;z,-x+1/2,-y+1/2;-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;"	symLines[224] += "y,x+1/2,-z+1/2;-y,-x+1/2,-z+1/2;-x,z+1/2,y+1/2;-x,-z+1/2,-y+1/2;z,-y+1/2,x+1/2;-z,-y+1/2,-x+1/2;"	symLines[224] += "-x,-y+1/2,-z+1/2;y,-x+1/2,-z+1/2;x,y+1/2,-z+1/2;-y,x+1/2,-z+1/2;-x,z+1/2,-y+1/2;-x,y+1/2,z+1/2;-x,-z+1/2,y+1/2;"	symLines[224] += "-z,-y+1/2,x+1/2;x,-y+1/2,z+1/2;z,-y+1/2,-x+1/2;-z,-x+1/2,-y+1/2;-y,-z+1/2,-x+1/2;y,z+1/2,-x+1/2;-z,x+1/2,y+1/2;"	symLines[224] += "y,-z+1/2,x+1/2;z,x+1/2,-y+1/2;z,-x+1/2,y+1/2;-y,z+1/2,x+1/2;-y,-x+1/2,z+1/2;y,x+1/2,z+1/2;x,-z+1/2,-y+1/2;"	symLines[224] += "x,z+1/2,y+1/2;-z,y+1/2,-x+1/2;z,y+1/2,x+1/2;x+1/2,y,z+1/2;-y+1/2,x,z+1/2;-x+1/2,-y,z+1/2;y+1/2,-x,z+1/2;"	symLines[224] += "x+1/2,-z,y+1/2;x+1/2,-y,-z+1/2;x+1/2,z,-y+1/2;z+1/2,y,-x+1/2;-x+1/2,y,-z+1/2;-z+1/2,y,x+1/2;z+1/2,x,y+1/2;"	symLines[224] += "y+1/2,z,x+1/2;-y+1/2,-z,x+1/2;z+1/2,-x,-y+1/2;-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;"	symLines[224] += "y+1/2,x,-z+1/2;-y+1/2,-x,-z+1/2;-x+1/2,z,y+1/2;-x+1/2,-z,-y+1/2;z+1/2,-y,x+1/2;-z+1/2,-y,-x+1/2;"	symLines[224] += "-x+1/2,-y,-z+1/2;y+1/2,-x,-z+1/2;x+1/2,y,-z+1/2;-y+1/2,x,-z+1/2;-x+1/2,z,-y+1/2;-x+1/2,y,z+1/2;-x+1/2,-z,y+1/2;"	symLines[224] += "-z+1/2,-y,x+1/2;x+1/2,-y,z+1/2;z+1/2,-y,-x+1/2;-z+1/2,-x,-y+1/2;-y+1/2,-z,-x+1/2;y+1/2,z,-x+1/2;-z+1/2,x,y+1/2;"	symLines[224] += "y+1/2,-z,x+1/2;z+1/2,x,-y+1/2;z+1/2,-x,y+1/2;-y+1/2,z,x+1/2;-y+1/2,-x,z+1/2;y+1/2,x,z+1/2;x+1/2,-z,-y+1/2;"	symLines[224] += "x+1/2,z,y+1/2;-z+1/2,y,-x+1/2;z+1/2,y,x+1/2;x+1/2,y+1/2,z;-y+1/2,x+1/2,z;-x+1/2,-y+1/2,z;y+1/2,-x+1/2,z;"	symLines[224] += "x+1/2,-z+1/2,y;x+1/2,-y+1/2,-z;x+1/2,z+1/2,-y;z+1/2,y+1/2,-x;-x+1/2,y+1/2,-z;-z+1/2,y+1/2,x;z+1/2,x+1/2,y;"	symLines[224] += "y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;z+1/2,-x+1/2,-y;-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;"	symLines[224] += "y+1/2,x+1/2,-z;-y+1/2,-x+1/2,-z;-x+1/2,z+1/2,y;-x+1/2,-z+1/2,-y;z+1/2,-y+1/2,x;-z+1/2,-y+1/2,-x;"	symLines[224] += "-x+1/2,-y+1/2,-z;y+1/2,-x+1/2,-z;x+1/2,y+1/2,-z;-y+1/2,x+1/2,-z;-x+1/2,z+1/2,-y;-x+1/2,y+1/2,z;-x+1/2,-z+1/2,y;"	symLines[224] += "-z+1/2,-y+1/2,x;x+1/2,-y+1/2,z;z+1/2,-y+1/2,-x;-z+1/2,-x+1/2,-y;-y+1/2,-z+1/2,-x;y+1/2,z+1/2,-x;-z+1/2,x+1/2,y;"	symLines[224] += "y+1/2,-z+1/2,x;z+1/2,x+1/2,-y;z+1/2,-x+1/2,y;-y+1/2,z+1/2,x;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z;x+1/2,-z+1/2,-y;"	symLines[224] += "x+1/2,z+1/2,y;-z+1/2,y+1/2,-x;z+1/2,y+1/2,x"	symLines[225]  = "x,y,z;-y,x,z+1/2;-x,-y,z;y,-x,z+1/2;x,-z,y+1/2;x,-y,-z;x,z,-y+1/2;z,y,-x+1/2;-x,y,-z;-z,y,x+1/2;z,x,y;y,z,x;"	symLines[225] += "-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;y,x,-z+1/2;-y,-x,-z+1/2;-x,z,y+1/2;-x,-z,-y+1/2;z,-y,x+1/2;"	symLines[225] += "-z,-y,-x+1/2;-x,-y,-z;y,-x,-z+1/2;x,y,-z;-y,x,-z+1/2;-x,z,-y+1/2;-x,y,z;-x,-z,y+1/2;-z,-y,x+1/2;x,-y,z;"	symLines[225] += "z,-y,-x+1/2;-z,-x,-y;-y,-z,-x;y,z,-x;-z,x,y;y,-z,x;z,x,-y;z,-x,y;-y,z,x;-y,-x,z+1/2;y,x,z+1/2;x,-z,-y+1/2;"	symLines[225] += "x,z,y+1/2;-z,y,-x+1/2;z,y,x+1/2;x,y+1/2,z+1/2;-y,x+1/2,z;-x,-y+1/2,z+1/2;y,-x+1/2,z;x,-z+1/2,y;x,-y+1/2,-z+1/2;"	symLines[225] += "x,z+1/2,-y;z,y+1/2,-x;-x,y+1/2,-z+1/2;-z,y+1/2,x;z,x+1/2,y+1/2;y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;z,-x+1/2,-y+1/2;"	symLines[225] += "-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;y,x+1/2,-z;-y,-x+1/2,-z;-x,z+1/2,y;"	symLines[225] += "-x,-z+1/2,-y;z,-y+1/2,x;-z,-y+1/2,-x;-x,-y+1/2,-z+1/2;y,-x+1/2,-z;x,y+1/2,-z+1/2;-y,x+1/2,-z;-x,z+1/2,-y;"	symLines[225] += "-x,y+1/2,z+1/2;-x,-z+1/2,y;-z,-y+1/2,x;x,-y+1/2,z+1/2;z,-y+1/2,-x;-z,-x+1/2,-y+1/2;-y,-z+1/2,-x+1/2;"	symLines[225] += "y,z+1/2,-x+1/2;-z,x+1/2,y+1/2;y,-z+1/2,x+1/2;z,x+1/2,-y+1/2;z,-x+1/2,y+1/2;-y,z+1/2,x+1/2;-y,-x+1/2,z;"	symLines[225] += "y,x+1/2,z;x,-z+1/2,-y;x,z+1/2,y;-z,y+1/2,-x;z,y+1/2,x;x+1/2,y,z+1/2;-y+1/2,x,z;-x+1/2,-y,z+1/2;y+1/2,-x,z;"	symLines[225] += "x+1/2,-z,y;x+1/2,-y,-z+1/2;x+1/2,z,-y;z+1/2,y,-x;-x+1/2,y,-z+1/2;-z+1/2,y,x;z+1/2,x,y+1/2;y+1/2,z,x+1/2;"	symLines[225] += "-y+1/2,-z,x+1/2;z+1/2,-x,-y+1/2;-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;y+1/2,x,-z;"	symLines[225] += "-y+1/2,-x,-z;-x+1/2,z,y;-x+1/2,-z,-y;z+1/2,-y,x;-z+1/2,-y,-x;-x+1/2,-y,-z+1/2;y+1/2,-x,-z;x+1/2,y,-z+1/2;"	symLines[225] += "-y+1/2,x,-z;-x+1/2,z,-y;-x+1/2,y,z+1/2;-x+1/2,-z,y;-z+1/2,-y,x;x+1/2,-y,z+1/2;z+1/2,-y,-x;-z+1/2,-x,-y+1/2;"	symLines[225] += "-y+1/2,-z,-x+1/2;y+1/2,z,-x+1/2;-z+1/2,x,y+1/2;y+1/2,-z,x+1/2;z+1/2,x,-y+1/2;z+1/2,-x,y+1/2;-y+1/2,z,x+1/2;"	symLines[225] += "-y+1/2,-x,z;y+1/2,x,z;x+1/2,-z,-y;x+1/2,z,y;-z+1/2,y,-x;z+1/2,y,x;x+1/2,y+1/2,z;-y+1/2,x+1/2,z+1/2;"	symLines[225] += "-x+1/2,-y+1/2,z;y+1/2,-x+1/2,z+1/2;x+1/2,-z+1/2,y+1/2;x+1/2,-y+1/2,-z;x+1/2,z+1/2,-y+1/2;z+1/2,y+1/2,-x+1/2;"	symLines[225] += "-x+1/2,y+1/2,-z;-z+1/2,y+1/2,x+1/2;z+1/2,x+1/2,y;y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;z+1/2,-x+1/2,-y;-y+1/2,z+1/2,-x;"	symLines[225] += "-z+1/2,-x+1/2,y;-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;-x+1/2,z+1/2,y+1/2;"	symLines[225] += "-x+1/2,-z+1/2,-y+1/2;z+1/2,-y+1/2,x+1/2;-z+1/2,-y+1/2,-x+1/2;-x+1/2,-y+1/2,-z;y+1/2,-x+1/2,-z+1/2;"	symLines[225] += "x+1/2,y+1/2,-z;-y+1/2,x+1/2,-z+1/2;-x+1/2,z+1/2,-y+1/2;-x+1/2,y+1/2,z;-x+1/2,-z+1/2,y+1/2;-z+1/2,-y+1/2,x+1/2;"	symLines[225] += "x+1/2,-y+1/2,z;z+1/2,-y+1/2,-x+1/2;-z+1/2,-x+1/2,-y;-y+1/2,-z+1/2,-x;y+1/2,z+1/2,-x;-z+1/2,x+1/2,y;"	symLines[225] += "y+1/2,-z+1/2,x;z+1/2,x+1/2,-y;z+1/2,-x+1/2,y;-y+1/2,z+1/2,x;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2;"	symLines[225] += "x+1/2,-z+1/2,-y+1/2;x+1/2,z+1/2,y+1/2;-z+1/2,y+1/2,-x+1/2;z+1/2,y+1/2,x+1/2"	symLines[226]  = "x,y,z;-x+1/4,-y+1/4,-z+1/4;-y+1/4,x+1/4,z+1/4;-x,-y,z;y+1/4,-x+1/4,z+1/4;x+1/4,-z+1/4,y+1/4;x,-y,-z;"	symLines[226] += "x+1/4,z+1/4,-y+1/4;z+1/4,y+1/4,-x+1/4;-x,y,-z;-z+1/4,y+1/4,x+1/4;y,-x,-z;-y,x,-z;-x,z,-y;-x,-z,y;-z,-y,x;"	symLines[226] += "z,-y,-x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;-z+1/4,-x+1/4,-y+1/4;-y+1/4,-z+1/4,-x+1/4;"	symLines[226] += "y+1/4,z+1/4,-x+1/4;-z+1/4,x+1/4,y+1/4;y+1/4,-z+1/4,x+1/4;z+1/4,x+1/4,-y+1/4;z+1/4,-x+1/4,y+1/4;"	symLines[226] += "-y+1/4,z+1/4,x+1/4;y+1/4,x+1/4,-z+1/4;-y+1/4,-x+1/4,-z+1/4;-x+1/4,z+1/4,y+1/4;-x+1/4,-z+1/4,-y+1/4;"	symLines[226] += "z+1/4,-y+1/4,x+1/4;-z+1/4,-y+1/4,-x+1/4;x+1/4,y+1/4,-z+1/4;-x+1/4,y+1/4,z+1/4;x+1/4,-y+1/4,z+1/4;-y,-x,z;y,x,z;"	symLines[226] += "x,-z,-y;x,z,y;-z,y,-x;z,y,x;x,y+1/2,z+1/2;-x+1/4,-y+3/4,-z+3/4;-y+1/4,x+3/4,z+3/4;-x,-y+1/2,z+1/2;"	symLines[226] += "y+1/4,-x+3/4,z+3/4;x+1/4,-z+3/4,y+3/4;x,-y+1/2,-z+1/2;x+1/4,z+3/4,-y+3/4;z+1/4,y+3/4,-x+3/4;-x,y+1/2,-z+1/2;"	symLines[226] += "-z+1/4,y+3/4,x+3/4;y,-x+1/2,-z+1/2;-y,x+1/2,-z+1/2;-x,z+1/2,-y+1/2;-x,-z+1/2,y+1/2;-z,-y+1/2,x+1/2;"	symLines[226] += "z,-y+1/2,-x+1/2;z,x+1/2,y+1/2;y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;z,-x+1/2,-y+1/2;-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;"	symLines[226] += "-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;-z+1/4,-x+3/4,-y+3/4;-y+1/4,-z+3/4,-x+3/4;y+1/4,z+3/4,-x+3/4;"	symLines[226] += "-z+1/4,x+3/4,y+3/4;y+1/4,-z+3/4,x+3/4;z+1/4,x+3/4,-y+3/4;z+1/4,-x+3/4,y+3/4;-y+1/4,z+3/4,x+3/4;"	symLines[226] += "y+1/4,x+3/4,-z+3/4;-y+1/4,-x+3/4,-z+3/4;-x+1/4,z+3/4,y+3/4;-x+1/4,-z+3/4,-y+3/4;z+1/4,-y+3/4,x+3/4;"	symLines[226] += "-z+1/4,-y+3/4,-x+3/4;x+1/4,y+3/4,-z+3/4;-x+1/4,y+3/4,z+3/4;x+1/4,-y+3/4,z+3/4;-y,-x+1/2,z+1/2;y,x+1/2,z+1/2;"	symLines[226] += "x,-z+1/2,-y+1/2;x,z+1/2,y+1/2;-z,y+1/2,-x+1/2;z,y+1/2,x+1/2;x+1/2,y,z+1/2;-x+3/4,-y+1/4,-z+3/4;"	symLines[226] += "-y+3/4,x+1/4,z+3/4;-x+1/2,-y,z+1/2;y+3/4,-x+1/4,z+3/4;x+3/4,-z+1/4,y+3/4;x+1/2,-y,-z+1/2;x+3/4,z+1/4,-y+3/4;"	symLines[226] += "z+3/4,y+1/4,-x+3/4;-x+1/2,y,-z+1/2;-z+3/4,y+1/4,x+3/4;y+1/2,-x,-z+1/2;-y+1/2,x,-z+1/2;-x+1/2,z,-y+1/2;"	symLines[226] += "-x+1/2,-z,y+1/2;-z+1/2,-y,x+1/2;z+1/2,-y,-x+1/2;z+1/2,x,y+1/2;y+1/2,z,x+1/2;-y+1/2,-z,x+1/2;z+1/2,-x,-y+1/2;"	symLines[226] += "-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;-z+3/4,-x+1/4,-y+3/4;-y+3/4,-z+1/4,-x+3/4;"	symLines[226] += "y+3/4,z+1/4,-x+3/4;-z+3/4,x+1/4,y+3/4;y+3/4,-z+1/4,x+3/4;z+3/4,x+1/4,-y+3/4;z+3/4,-x+1/4,y+3/4;"	symLines[226] += "-y+3/4,z+1/4,x+3/4;y+3/4,x+1/4,-z+3/4;-y+3/4,-x+1/4,-z+3/4;-x+3/4,z+1/4,y+3/4;-x+3/4,-z+1/4,-y+3/4;"	symLines[226] += "z+3/4,-y+1/4,x+3/4;-z+3/4,-y+1/4,-x+3/4;x+3/4,y+1/4,-z+3/4;-x+3/4,y+1/4,z+3/4;x+3/4,-y+1/4,z+3/4;"	symLines[226] += "-y+1/2,-x,z+1/2;y+1/2,x,z+1/2;x+1/2,-z,-y+1/2;x+1/2,z,y+1/2;-z+1/2,y,-x+1/2;z+1/2,y,x+1/2;x+1/2,y+1/2,z;"	symLines[226] += "-x+3/4,-y+3/4,-z+1/4;-y+3/4,x+3/4,z+1/4;-x+1/2,-y+1/2,z;y+3/4,-x+3/4,z+1/4;x+3/4,-z+3/4,y+1/4;x+1/2,-y+1/2,-z;"	symLines[226] += "x+3/4,z+3/4,-y+1/4;z+3/4,y+3/4,-x+1/4;-x+1/2,y+1/2,-z;-z+3/4,y+3/4,x+1/4;y+1/2,-x+1/2,-z;-y+1/2,x+1/2,-z;"	symLines[226] += "-x+1/2,z+1/2,-y;-x+1/2,-z+1/2,y;-z+1/2,-y+1/2,x;z+1/2,-y+1/2,-x;z+1/2,x+1/2,y;y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;"	symLines[226] += "z+1/2,-x+1/2,-y;-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;-z+3/4,-x+3/4,-y+1/4;"	symLines[226] += "-y+3/4,-z+3/4,-x+1/4;y+3/4,z+3/4,-x+1/4;-z+3/4,x+3/4,y+1/4;y+3/4,-z+3/4,x+1/4;z+3/4,x+3/4,-y+1/4;"	symLines[226] += "z+3/4,-x+3/4,y+1/4;-y+3/4,z+3/4,x+1/4;y+3/4,x+3/4,-z+1/4;-y+3/4,-x+3/4,-z+1/4;-x+3/4,z+3/4,y+1/4;"	symLines[226] += "-x+3/4,-z+3/4,-y+1/4;z+3/4,-y+3/4,x+1/4;-z+3/4,-y+3/4,-x+1/4;x+3/4,y+3/4,-z+1/4;-x+3/4,y+3/4,z+1/4;"	symLines[226] += "x+3/4,-y+3/4,z+1/4;-y+1/2,-x+1/2,z;y+1/2,x+1/2,z;x+1/2,-z+1/2,-y;x+1/2,z+1/2,y;-z+1/2,y+1/2,-x;z+1/2,y+1/2,x"	symLines[227]  = "x,y,z;-x+1/4,-y+1/4,-z+3/4;-y+1/4,x+1/4,z+1/4;-x,-y,z;y+1/4,-x+1/4,z+1/4;x+1/4,-z+1/4,y+1/4;x,-y,-z;"	symLines[227] += "x+1/4,z+1/4,-y+1/4;z+1/4,y+1/4,-x+1/4;-x,y,-z;-z+1/4,y+1/4,x+1/4;y,-x,-z+1/2;-y,x,-z+1/2;-x,z,-y+1/2;"	symLines[227] += "-x,-z,y+1/2;-z,-y,x+1/2;z,-y,-x+1/2;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;-z,-x,y;-z,x,-y;y,-z,-x;"	symLines[227] += "-z+1/4,-x+1/4,-y+3/4;-y+1/4,-z+1/4,-x+3/4;y+1/4,z+1/4,-x+3/4;-z+1/4,x+1/4,y+3/4;y+1/4,-z+1/4,x+3/4;"	symLines[227] += "z+1/4,x+1/4,-y+3/4;z+1/4,-x+1/4,y+3/4;-y+1/4,z+1/4,x+3/4;y+1/4,x+1/4,-z+1/4;-y+1/4,-x+1/4,-z+1/4;"	symLines[227] += "-x+1/4,z+1/4,y+1/4;-x+1/4,-z+1/4,-y+1/4;z+1/4,-y+1/4,x+1/4;-z+1/4,-y+1/4,-x+1/4;x+1/4,y+1/4,-z+3/4;"	symLines[227] += "-x+1/4,y+1/4,z+3/4;x+1/4,-y+1/4,z+3/4;-y,-x,z+1/2;y,x,z+1/2;x,-z,-y+1/2;x,z,y+1/2;-z,y,-x+1/2;z,y,x+1/2;"	symLines[227] += "x,y+1/2,z+1/2;-x+1/4,-y+3/4,-z+1/4;-y+1/4,x+3/4,z+3/4;-x,-y+1/2,z+1/2;y+1/4,-x+3/4,z+3/4;x+1/4,-z+3/4,y+3/4;"	symLines[227] += "x,-y+1/2,-z+1/2;x+1/4,z+3/4,-y+3/4;z+1/4,y+3/4,-x+3/4;-x,y+1/2,-z+1/2;-z+1/4,y+3/4,x+3/4;y,-x+1/2,-z;"	symLines[227] += "-y,x+1/2,-z;-x,z+1/2,-y;-x,-z+1/2,y;-z,-y+1/2,x;z,-y+1/2,-x;z,x+1/2,y+1/2;y,z+1/2,x+1/2;-y,-z+1/2,x+1/2;"	symLines[227] += "z,-x+1/2,-y+1/2;-y,z+1/2,-x+1/2;-z,-x+1/2,y+1/2;-z,x+1/2,-y+1/2;y,-z+1/2,-x+1/2;-z+1/4,-x+3/4,-y+1/4;"	symLines[227] += "-y+1/4,-z+3/4,-x+1/4;y+1/4,z+3/4,-x+1/4;-z+1/4,x+3/4,y+1/4;y+1/4,-z+3/4,x+1/4;z+1/4,x+3/4,-y+1/4;"	symLines[227] += "z+1/4,-x+3/4,y+1/4;-y+1/4,z+3/4,x+1/4;y+1/4,x+3/4,-z+3/4;-y+1/4,-x+3/4,-z+3/4;-x+1/4,z+3/4,y+3/4;"	symLines[227] += "-x+1/4,-z+3/4,-y+3/4;z+1/4,-y+3/4,x+3/4;-z+1/4,-y+3/4,-x+3/4;x+1/4,y+3/4,-z+1/4;-x+1/4,y+3/4,z+1/4;"	symLines[227] += "x+1/4,-y+3/4,z+1/4;-y,-x+1/2,z;y,x+1/2,z;x,-z+1/2,-y;x,z+1/2,y;-z,y+1/2,-x;z,y+1/2,x;x+1/2,y,z+1/2;"	symLines[227] += "-x+3/4,-y+1/4,-z+1/4;-y+3/4,x+1/4,z+3/4;-x+1/2,-y,z+1/2;y+3/4,-x+1/4,z+3/4;x+3/4,-z+1/4,y+3/4;x+1/2,-y,-z+1/2;"	symLines[227] += "x+3/4,z+1/4,-y+3/4;z+3/4,y+1/4,-x+3/4;-x+1/2,y,-z+1/2;-z+3/4,y+1/4,x+3/4;y+1/2,-x,-z;-y+1/2,x,-z;-x+1/2,z,-y;"	symLines[227] += "-x+1/2,-z,y;-z+1/2,-y,x;z+1/2,-y,-x;z+1/2,x,y+1/2;y+1/2,z,x+1/2;-y+1/2,-z,x+1/2;z+1/2,-x,-y+1/2;"	symLines[227] += "-y+1/2,z,-x+1/2;-z+1/2,-x,y+1/2;-z+1/2,x,-y+1/2;y+1/2,-z,-x+1/2;-z+3/4,-x+1/4,-y+1/4;-y+3/4,-z+1/4,-x+1/4;"	symLines[227] += "y+3/4,z+1/4,-x+1/4;-z+3/4,x+1/4,y+1/4;y+3/4,-z+1/4,x+1/4;z+3/4,x+1/4,-y+1/4;z+3/4,-x+1/4,y+1/4;"	symLines[227] += "-y+3/4,z+1/4,x+1/4;y+3/4,x+1/4,-z+3/4;-y+3/4,-x+1/4,-z+3/4;-x+3/4,z+1/4,y+3/4;-x+3/4,-z+1/4,-y+3/4;"	symLines[227] += "z+3/4,-y+1/4,x+3/4;-z+3/4,-y+1/4,-x+3/4;x+3/4,y+1/4,-z+1/4;-x+3/4,y+1/4,z+1/4;x+3/4,-y+1/4,z+1/4;-y+1/2,-x,z;"	symLines[227] += "y+1/2,x,z;x+1/2,-z,-y;x+1/2,z,y;-z+1/2,y,-x;z+1/2,y,x;x+1/2,y+1/2,z;-x+3/4,-y+3/4,-z+3/4;-y+3/4,x+3/4,z+1/4;"	symLines[227] += "-x+1/2,-y+1/2,z;y+3/4,-x+3/4,z+1/4;x+3/4,-z+3/4,y+1/4;x+1/2,-y+1/2,-z;x+3/4,z+3/4,-y+1/4;z+3/4,y+3/4,-x+1/4;"	symLines[227] += "-x+1/2,y+1/2,-z;-z+3/4,y+3/4,x+1/4;y+1/2,-x+1/2,-z+1/2;-y+1/2,x+1/2,-z+1/2;-x+1/2,z+1/2,-y+1/2;"	symLines[227] += "-x+1/2,-z+1/2,y+1/2;-z+1/2,-y+1/2,x+1/2;z+1/2,-y+1/2,-x+1/2;z+1/2,x+1/2,y;y+1/2,z+1/2,x;-y+1/2,-z+1/2,x;"	symLines[227] += "z+1/2,-x+1/2,-y;-y+1/2,z+1/2,-x;-z+1/2,-x+1/2,y;-z+1/2,x+1/2,-y;y+1/2,-z+1/2,-x;-z+3/4,-x+3/4,-y+3/4;"	symLines[227] += "-y+3/4,-z+3/4,-x+3/4;y+3/4,z+3/4,-x+3/4;-z+3/4,x+3/4,y+3/4;y+3/4,-z+3/4,x+3/4;z+3/4,x+3/4,-y+3/4;"	symLines[227] += "z+3/4,-x+3/4,y+3/4;-y+3/4,z+3/4,x+3/4;y+3/4,x+3/4,-z+1/4;-y+3/4,-x+3/4,-z+1/4;-x+3/4,z+3/4,y+1/4;"	symLines[227] += "-x+3/4,-z+3/4,-y+1/4;z+3/4,-y+3/4,x+1/4;-z+3/4,-y+3/4,-x+1/4;x+3/4,y+3/4,-z+3/4;-x+3/4,y+3/4,z+3/4;"	symLines[227] += "x+3/4,-y+3/4,z+3/4;-y+1/2,-x+1/2,z+1/2;y+1/2,x+1/2,z+1/2;x+1/2,-z+1/2,-y+1/2;x+1/2,z+1/2,y+1/2;"	symLines[227] += "-z+1/2,y+1/2,-x+1/2;z+1/2,y+1/2,x+1/2"	symLines[228]  = "x,y,z;-y,x,z;-x,-y,z;y,-x,z;x,-z,y;x,-y,-z;x,z,-y;z,y,-x;-x,y,-z;-z,y,x;z,x,y;y,z,x;-y,-z,x;z,-x,-y;-y,z,-x;"	symLines[228] += "-z,-x,y;-z,x,-y;y,-z,-x;y,x,-z;-y,-x,-z;-x,z,y;-x,-z,-y;z,-y,x;-z,-y,-x;-x,-y,-z;y,-x,-z;x,y,-z;-y,x,-z;"	symLines[228] += "-x,z,-y;-x,y,z;-x,-z,y;-z,-y,x;x,-y,z;z,-y,-x;-z,-x,-y;-y,-z,-x;y,z,-x;-z,x,y;y,-z,x;z,x,-y;z,-x,y;-y,z,x;"	symLines[228] += "-y,-x,z;y,x,z;x,-z,-y;x,z,y;-z,y,-x;z,y,x;x+1/2,y+1/2,z+1/2;-y+1/2,x+1/2,z+1/2;-x+1/2,-y+1/2,z+1/2;"	symLines[228] += "y+1/2,-x+1/2,z+1/2;x+1/2,-z+1/2,y+1/2;x+1/2,-y+1/2,-z+1/2;x+1/2,z+1/2,-y+1/2;z+1/2,y+1/2,-x+1/2;"	symLines[228] += "-x+1/2,y+1/2,-z+1/2;-z+1/2,y+1/2,x+1/2;z+1/2,x+1/2,y+1/2;y+1/2,z+1/2,x+1/2;-y+1/2,-z+1/2,x+1/2;"	symLines[228] += "z+1/2,-x+1/2,-y+1/2;-y+1/2,z+1/2,-x+1/2;-z+1/2,-x+1/2,y+1/2;-z+1/2,x+1/2,-y+1/2;y+1/2,-z+1/2,-x+1/2;"	symLines[228] += "y+1/2,x+1/2,-z+1/2;-y+1/2,-x+1/2,-z+1/2;-x+1/2,z+1/2,y+1/2;-x+1/2,-z+1/2,-y+1/2;z+1/2,-y+1/2,x+1/2;"	symLines[228] += "-z+1/2,-y+1/2,-x+1/2;-x+1/2,-y+1/2,-z+1/2;y+1/2,-x+1/2,-z+1/2;x+1/2,y+1/2,-z+1/2;-y+1/2,x+1/2,-z+1/2;"	symLines[228] += "-x+1/2,z+1/2,-y+1/2;-x+1/2,y+1/2,z+1/2;-x+1/2,-z+1/2,y+1/2;-z+1/2,-y+1/2,x+1/2;x+1/2,-y+1/2,z+1/2;"	symLines[228] += "z+1/2,-y+1/2,-x+1/2;-z+1/2,-x+1/2,-y+1/2;-y+1/2,-z+1/2,-x+1/2;y+1/2,z+1/2,-x+1/2;-z+1/2,x+1/2,y+1/2;"	symLines[228] += "y+1/2,-z+1/2,x+1/2;z+1/2,x+1/2,-y+1/2;z+1/2,-x+1/2,y+1/2;-y+1/2,z+1/2,x+1/2;-y+1/2,-x+1/2,z+1/2;"	symLines[228] += "y+1/2,x+1/2,z+1/2;x+1/2,-z+1/2,-y+1/2;x+1/2,z+1/2,y+1/2;-z+1/2,y+1/2,-x+1/2;z+1/2,y+1/2,x+1/2"	symLines[229]  = "x,y,z;-y+1/4,x+3/4,z+1/4;-x,-y+1/2,z;y+1/4,-x+1/4,z+3/4;x+1/4,-z+1/4,y+3/4;x,-y,-z+1/2;x+3/4,z+1/4,-y+1/4;"	symLines[229] += "z+3/4,y+1/4,-x+1/4;-x+1/2,y,-z;-z+1/4,y+3/4,x+1/4;z,x,y;y,z,x;-y,-z+1/2,x;z,-x,-y+1/2;-y+1/2,z,-x;-z,-x+1/2,y;"	symLines[229] += "-z+1/2,x,-y;y,-z,-x+1/2;y+3/4,x+1/4,-z+1/4;-y+1/4,-x+1/4,-z+1/4;-x+1/4,z+3/4,y+1/4;-x+1/4,-z+1/4,-y+1/4;"	symLines[229] += "z+1/4,-y+1/4,x+3/4;-z+1/4,-y+1/4,-x+1/4;-x,-y,-z;y+3/4,-x+1/4,-z+3/4;x,y+1/2,-z;-y+3/4,x+3/4,-z+1/4;"	symLines[229] += "-x+3/4,z+3/4,-y+1/4;-x,y,z+1/2;-x+1/4,-z+3/4,y+3/4;-z+1/4,-y+3/4,x+3/4;x+1/2,-y,z;z+3/4,-y+1/4,-x+3/4;-z,-x,-y;"	symLines[229] += "-y,-z,-x;y,z+1/2,-x;-z,x,y+1/2;y+1/2,-z,x;z,x+1/2,-y;z+1/2,-x,y;-y,z,x+1/2;-y+1/4,-x+3/4,z+3/4;"	symLines[229] += "y+3/4,x+3/4,z+3/4;x+3/4,-z+1/4,-y+3/4;x+3/4,z+3/4,y+3/4;-z+3/4,y+3/4,-x+1/4;z+3/4,y+3/4,x+3/4;"	symLines[229] += "x+1/2,y+1/2,z+1/2;-y+3/4,x+1/4,z+3/4;-x+1/2,-y,z+1/2;y+3/4,-x+3/4,z+1/4;x+3/4,-z+3/4,y+1/4;x+1/2,-y+1/2,-z;"	symLines[229] += "x+1/4,z+3/4,-y+3/4;z+1/4,y+3/4,-x+3/4;-x,y+1/2,-z+1/2;-z+3/4,y+1/4,x+3/4;z+1/2,x+1/2,y+1/2;y+1/2,z+1/2,x+1/2;"	symLines[229] += "-y+1/2,-z,x+1/2;z+1/2,-x+1/2,-y;-y,z+1/2,-x+1/2;-z+1/2,-x,y+1/2;-z,x+1/2,-y+1/2;y+1/2,-z+1/2,-x;"	symLines[229] += "y+1/4,x+3/4,-z+3/4;-y+3/4,-x+3/4,-z+3/4;-x+3/4,z+1/4,y+3/4;-x+3/4,-z+3/4,-y+3/4;z+3/4,-y+3/4,x+1/4;"	symLines[229] += "-z+3/4,-y+3/4,-x+3/4;-x+1/2,-y+1/2,-z+1/2;y+1/4,-x+3/4,-z+1/4;x+1/2,y,-z+1/2;-y+1/4,x+1/4,-z+3/4;"	symLines[229] += "-x+1/4,z+1/4,-y+3/4;-x+1/2,y+1/2,z;-x+3/4,-z+1/4,y+1/4;-z+3/4,-y+1/4,x+1/4;x,-y+1/2,z+1/2;z+1/4,-y+3/4,-x+1/4;"	symLines[229] += "-z+1/2,-x+1/2,-y+1/2;-y+1/2,-z+1/2,-x+1/2;y+1/2,z,-x+1/2;-z+1/2,x+1/2,y;y,-z+1/2,x+1/2;z+1/2,x,-y+1/2;"	symLines[229] += "z,-x+1/2,y+1/2;-y+1/2,z+1/2,x;-y+3/4,-x+1/4,z+1/4;y+1/4,x+1/4,z+1/4;x+1/4,-z+3/4,-y+1/4;x+1/4,z+1/4,y+1/4;"	symLines[229] += "-z+1/4,y+1/4,-x+3/4;z+1/4,y+1/4,x+1/4"	String str = symLines[SpaceGroup-1]	KillWaves/Z symLines_temp__	return strEnd